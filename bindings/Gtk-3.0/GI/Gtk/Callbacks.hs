

-- | Copyright  : Will Thompson and Iñaki García Etxebarria
-- License    : LGPL-2.1
-- Maintainer : Iñaki García Etxebarria

#if (MIN_VERSION_haskell_gi_overloading(1,0,0) && !defined(__HADDOCK_VERSION__))
#define ENABLE_OVERLOADING
#endif

module GI.Gtk.Callbacks
    ( 

 -- * Signals


-- ** AccelGroupActivate #signal:AccelGroupActivate#

    AccelGroupActivate                      ,
    C_AccelGroupActivate                    ,
    dynamic_AccelGroupActivate              ,
    genClosure_AccelGroupActivate           ,
    mk_AccelGroupActivate                   ,
    noAccelGroupActivate                    ,
    wrap_AccelGroupActivate                 ,


-- ** AccelGroupFindFunc #signal:AccelGroupFindFunc#

    AccelGroupFindFunc                      ,
    AccelGroupFindFunc_WithClosures         ,
    C_AccelGroupFindFunc                    ,
    drop_closures_AccelGroupFindFunc        ,
    dynamic_AccelGroupFindFunc              ,
    genClosure_AccelGroupFindFunc           ,
    mk_AccelGroupFindFunc                   ,
    noAccelGroupFindFunc                    ,
    noAccelGroupFindFunc_WithClosures       ,
    wrap_AccelGroupFindFunc                 ,


-- ** AccelMapForeach #signal:AccelMapForeach#

    AccelMapForeach                         ,
    C_AccelMapForeach                       ,
    dynamic_AccelMapForeach                 ,
    genClosure_AccelMapForeach              ,
    mk_AccelMapForeach                      ,
    noAccelMapForeach                       ,
    wrap_AccelMapForeach                    ,


-- ** AssistantPageFunc #signal:AssistantPageFunc#

    AssistantPageFunc                       ,
    AssistantPageFunc_WithClosures          ,
    C_AssistantPageFunc                     ,
    drop_closures_AssistantPageFunc         ,
    dynamic_AssistantPageFunc               ,
    genClosure_AssistantPageFunc            ,
    mk_AssistantPageFunc                    ,
    noAssistantPageFunc                     ,
    noAssistantPageFunc_WithClosures        ,
    wrap_AssistantPageFunc                  ,


-- ** BuilderConnectFunc #signal:BuilderConnectFunc#

    BuilderConnectFunc                      ,
    BuilderConnectFunc_WithClosures         ,
    C_BuilderConnectFunc                    ,
    drop_closures_BuilderConnectFunc        ,
    dynamic_BuilderConnectFunc              ,
    genClosure_BuilderConnectFunc           ,
    mk_BuilderConnectFunc                   ,
    noBuilderConnectFunc                    ,
    noBuilderConnectFunc_WithClosures       ,
    wrap_BuilderConnectFunc                 ,


-- ** CalendarDetailFunc #signal:CalendarDetailFunc#

    C_CalendarDetailFunc                    ,
    CalendarDetailFunc                      ,
    CalendarDetailFunc_WithClosures         ,
    drop_closures_CalendarDetailFunc        ,
    dynamic_CalendarDetailFunc              ,
    genClosure_CalendarDetailFunc           ,
    mk_CalendarDetailFunc                   ,
    noCalendarDetailFunc                    ,
    noCalendarDetailFunc_WithClosures       ,
    wrap_CalendarDetailFunc                 ,


-- ** Callback #signal:Callback#

    C_Callback                              ,
    Callback                                ,
    Callback_WithClosures                   ,
    drop_closures_Callback                  ,
    dynamic_Callback                        ,
    genClosure_Callback                     ,
    mk_Callback                             ,
    noCallback                              ,
    noCallback_WithClosures                 ,
    wrap_Callback                           ,


-- ** CellAllocCallback #signal:CellAllocCallback#

    C_CellAllocCallback                     ,
    CellAllocCallback                       ,
    CellAllocCallback_WithClosures          ,
    drop_closures_CellAllocCallback         ,
    dynamic_CellAllocCallback               ,
    genClosure_CellAllocCallback            ,
    mk_CellAllocCallback                    ,
    noCellAllocCallback                     ,
    noCellAllocCallback_WithClosures        ,
    wrap_CellAllocCallback                  ,


-- ** CellCallback #signal:CellCallback#

    C_CellCallback                          ,
    CellCallback                            ,
    CellCallback_WithClosures               ,
    drop_closures_CellCallback              ,
    dynamic_CellCallback                    ,
    genClosure_CellCallback                 ,
    mk_CellCallback                         ,
    noCellCallback                          ,
    noCellCallback_WithClosures             ,
    wrap_CellCallback                       ,


-- ** CellLayoutDataFunc #signal:CellLayoutDataFunc#

    C_CellLayoutDataFunc                    ,
    CellLayoutDataFunc                      ,
    CellLayoutDataFunc_WithClosures         ,
    drop_closures_CellLayoutDataFunc        ,
    dynamic_CellLayoutDataFunc              ,
    genClosure_CellLayoutDataFunc           ,
    mk_CellLayoutDataFunc                   ,
    noCellLayoutDataFunc                    ,
    noCellLayoutDataFunc_WithClosures       ,
    wrap_CellLayoutDataFunc                 ,


-- ** ClipboardClearFunc #signal:ClipboardClearFunc#

    C_ClipboardClearFunc                    ,
    ClipboardClearFunc                      ,
    dynamic_ClipboardClearFunc              ,
    genClosure_ClipboardClearFunc           ,
    mk_ClipboardClearFunc                   ,
    noClipboardClearFunc                    ,
    wrap_ClipboardClearFunc                 ,


-- ** ClipboardGetFunc #signal:ClipboardGetFunc#

    C_ClipboardGetFunc                      ,
    ClipboardGetFunc                        ,
    dynamic_ClipboardGetFunc                ,
    genClosure_ClipboardGetFunc             ,
    mk_ClipboardGetFunc                     ,
    noClipboardGetFunc                      ,
    wrap_ClipboardGetFunc                   ,


-- ** ClipboardImageReceivedFunc #signal:ClipboardImageReceivedFunc#

    C_ClipboardImageReceivedFunc            ,
    ClipboardImageReceivedFunc              ,
    ClipboardImageReceivedFunc_WithClosures ,
    drop_closures_ClipboardImageReceivedFunc,
    dynamic_ClipboardImageReceivedFunc      ,
    genClosure_ClipboardImageReceivedFunc   ,
    mk_ClipboardImageReceivedFunc           ,
    noClipboardImageReceivedFunc            ,
    noClipboardImageReceivedFunc_WithClosures,
    wrap_ClipboardImageReceivedFunc         ,


-- ** ClipboardReceivedFunc #signal:ClipboardReceivedFunc#

    C_ClipboardReceivedFunc                 ,
    ClipboardReceivedFunc                   ,
    ClipboardReceivedFunc_WithClosures      ,
    drop_closures_ClipboardReceivedFunc     ,
    dynamic_ClipboardReceivedFunc           ,
    genClosure_ClipboardReceivedFunc        ,
    mk_ClipboardReceivedFunc                ,
    noClipboardReceivedFunc                 ,
    noClipboardReceivedFunc_WithClosures    ,
    wrap_ClipboardReceivedFunc              ,


-- ** ClipboardRichTextReceivedFunc #signal:ClipboardRichTextReceivedFunc#

    C_ClipboardRichTextReceivedFunc         ,
    ClipboardRichTextReceivedFunc           ,
    ClipboardRichTextReceivedFunc_WithClosures,
    drop_closures_ClipboardRichTextReceivedFunc,
    dynamic_ClipboardRichTextReceivedFunc   ,
    genClosure_ClipboardRichTextReceivedFunc,
    mk_ClipboardRichTextReceivedFunc        ,
    noClipboardRichTextReceivedFunc         ,
    noClipboardRichTextReceivedFunc_WithClosures,
    wrap_ClipboardRichTextReceivedFunc      ,


-- ** ClipboardTargetsReceivedFunc #signal:ClipboardTargetsReceivedFunc#

    C_ClipboardTargetsReceivedFunc          ,
    ClipboardTargetsReceivedFunc            ,
    ClipboardTargetsReceivedFunc_WithClosures,
    drop_closures_ClipboardTargetsReceivedFunc,
    dynamic_ClipboardTargetsReceivedFunc    ,
    genClosure_ClipboardTargetsReceivedFunc ,
    mk_ClipboardTargetsReceivedFunc         ,
    noClipboardTargetsReceivedFunc          ,
    noClipboardTargetsReceivedFunc_WithClosures,
    wrap_ClipboardTargetsReceivedFunc       ,


-- ** ClipboardTextReceivedFunc #signal:ClipboardTextReceivedFunc#

    C_ClipboardTextReceivedFunc             ,
    ClipboardTextReceivedFunc               ,
    ClipboardTextReceivedFunc_WithClosures  ,
    drop_closures_ClipboardTextReceivedFunc ,
    dynamic_ClipboardTextReceivedFunc       ,
    genClosure_ClipboardTextReceivedFunc    ,
    mk_ClipboardTextReceivedFunc            ,
    noClipboardTextReceivedFunc             ,
    noClipboardTextReceivedFunc_WithClosures,
    wrap_ClipboardTextReceivedFunc          ,


-- ** ClipboardURIReceivedFunc #signal:ClipboardURIReceivedFunc#

    C_ClipboardURIReceivedFunc              ,
    ClipboardURIReceivedFunc                ,
    ClipboardURIReceivedFunc_WithClosures   ,
    drop_closures_ClipboardURIReceivedFunc  ,
    dynamic_ClipboardURIReceivedFunc        ,
    genClosure_ClipboardURIReceivedFunc     ,
    mk_ClipboardURIReceivedFunc             ,
    noClipboardURIReceivedFunc              ,
    noClipboardURIReceivedFunc_WithClosures ,
    wrap_ClipboardURIReceivedFunc           ,


-- ** ColorSelectionChangePaletteFunc #signal:ColorSelectionChangePaletteFunc#

    C_ColorSelectionChangePaletteFunc       ,
    ColorSelectionChangePaletteFunc         ,
    dynamic_ColorSelectionChangePaletteFunc ,
    genClosure_ColorSelectionChangePaletteFunc,
    mk_ColorSelectionChangePaletteFunc      ,
    noColorSelectionChangePaletteFunc       ,
    wrap_ColorSelectionChangePaletteFunc    ,


-- ** ColorSelectionChangePaletteWithScreenFunc #signal:ColorSelectionChangePaletteWithScreenFunc#

    C_ColorSelectionChangePaletteWithScreenFunc,
    ColorSelectionChangePaletteWithScreenFunc,
    dynamic_ColorSelectionChangePaletteWithScreenFunc,
    genClosure_ColorSelectionChangePaletteWithScreenFunc,
    mk_ColorSelectionChangePaletteWithScreenFunc,
    noColorSelectionChangePaletteWithScreenFunc,
    wrap_ColorSelectionChangePaletteWithScreenFunc,


-- ** ContainerClassAddFieldCallback #signal:ContainerClassAddFieldCallback#

    C_ContainerClassAddFieldCallback        ,
    ContainerClassAddFieldCallback          ,
    dynamic_ContainerClassAddFieldCallback  ,
    genClosure_ContainerClassAddFieldCallback,
    mk_ContainerClassAddFieldCallback       ,
    noContainerClassAddFieldCallback        ,
    wrap_ContainerClassAddFieldCallback     ,


-- ** ContainerClassCheckResizeFieldCallback #signal:ContainerClassCheckResizeFieldCallback#

    C_ContainerClassCheckResizeFieldCallback,
    ContainerClassCheckResizeFieldCallback  ,
    dynamic_ContainerClassCheckResizeFieldCallback,
    genClosure_ContainerClassCheckResizeFieldCallback,
    mk_ContainerClassCheckResizeFieldCallback,
    noContainerClassCheckResizeFieldCallback,
    wrap_ContainerClassCheckResizeFieldCallback,


-- ** ContainerClassChildTypeFieldCallback #signal:ContainerClassChildTypeFieldCallback#

    C_ContainerClassChildTypeFieldCallback  ,
    ContainerClassChildTypeFieldCallback    ,
    dynamic_ContainerClassChildTypeFieldCallback,
    genClosure_ContainerClassChildTypeFieldCallback,
    mk_ContainerClassChildTypeFieldCallback ,
    noContainerClassChildTypeFieldCallback  ,
    wrap_ContainerClassChildTypeFieldCallback,


-- ** ContainerClassCompositeNameFieldCallback #signal:ContainerClassCompositeNameFieldCallback#

    C_ContainerClassCompositeNameFieldCallback,
    ContainerClassCompositeNameFieldCallback,
    dynamic_ContainerClassCompositeNameFieldCallback,
    genClosure_ContainerClassCompositeNameFieldCallback,
    mk_ContainerClassCompositeNameFieldCallback,
    noContainerClassCompositeNameFieldCallback,
    wrap_ContainerClassCompositeNameFieldCallback,


-- ** ContainerClassForallFieldCallback #signal:ContainerClassForallFieldCallback#

    C_ContainerClassForallFieldCallback     ,
    ContainerClassForallFieldCallback       ,
    ContainerClassForallFieldCallback_WithClosures,
    drop_closures_ContainerClassForallFieldCallback,
    dynamic_ContainerClassForallFieldCallback,
    genClosure_ContainerClassForallFieldCallback,
    mk_ContainerClassForallFieldCallback    ,
    noContainerClassForallFieldCallback     ,
    noContainerClassForallFieldCallback_WithClosures,
    wrap_ContainerClassForallFieldCallback  ,


-- ** ContainerClassGetChildPropertyFieldCallback #signal:ContainerClassGetChildPropertyFieldCallback#

    C_ContainerClassGetChildPropertyFieldCallback,
    ContainerClassGetChildPropertyFieldCallback,
    dynamic_ContainerClassGetChildPropertyFieldCallback,
    genClosure_ContainerClassGetChildPropertyFieldCallback,
    mk_ContainerClassGetChildPropertyFieldCallback,
    noContainerClassGetChildPropertyFieldCallback,
    wrap_ContainerClassGetChildPropertyFieldCallback,


-- ** ContainerClassGetPathForChildFieldCallback #signal:ContainerClassGetPathForChildFieldCallback#

    C_ContainerClassGetPathForChildFieldCallback,
    ContainerClassGetPathForChildFieldCallback,
    dynamic_ContainerClassGetPathForChildFieldCallback,
    genClosure_ContainerClassGetPathForChildFieldCallback,
    mk_ContainerClassGetPathForChildFieldCallback,
    noContainerClassGetPathForChildFieldCallback,
    wrap_ContainerClassGetPathForChildFieldCallback,


-- ** ContainerClassRemoveFieldCallback #signal:ContainerClassRemoveFieldCallback#

    C_ContainerClassRemoveFieldCallback     ,
    ContainerClassRemoveFieldCallback       ,
    dynamic_ContainerClassRemoveFieldCallback,
    genClosure_ContainerClassRemoveFieldCallback,
    mk_ContainerClassRemoveFieldCallback    ,
    noContainerClassRemoveFieldCallback     ,
    wrap_ContainerClassRemoveFieldCallback  ,


-- ** ContainerClassSetChildPropertyFieldCallback #signal:ContainerClassSetChildPropertyFieldCallback#

    C_ContainerClassSetChildPropertyFieldCallback,
    ContainerClassSetChildPropertyFieldCallback,
    dynamic_ContainerClassSetChildPropertyFieldCallback,
    genClosure_ContainerClassSetChildPropertyFieldCallback,
    mk_ContainerClassSetChildPropertyFieldCallback,
    noContainerClassSetChildPropertyFieldCallback,
    wrap_ContainerClassSetChildPropertyFieldCallback,


-- ** ContainerClassSetFocusChildFieldCallback #signal:ContainerClassSetFocusChildFieldCallback#

    C_ContainerClassSetFocusChildFieldCallback,
    ContainerClassSetFocusChildFieldCallback,
    dynamic_ContainerClassSetFocusChildFieldCallback,
    genClosure_ContainerClassSetFocusChildFieldCallback,
    mk_ContainerClassSetFocusChildFieldCallback,
    noContainerClassSetFocusChildFieldCallback,
    wrap_ContainerClassSetFocusChildFieldCallback,


-- ** EntryCompletionMatchFunc #signal:EntryCompletionMatchFunc#

    C_EntryCompletionMatchFunc              ,
    EntryCompletionMatchFunc                ,
    EntryCompletionMatchFunc_WithClosures   ,
    drop_closures_EntryCompletionMatchFunc  ,
    dynamic_EntryCompletionMatchFunc        ,
    genClosure_EntryCompletionMatchFunc     ,
    mk_EntryCompletionMatchFunc             ,
    noEntryCompletionMatchFunc              ,
    noEntryCompletionMatchFunc_WithClosures ,
    wrap_EntryCompletionMatchFunc           ,


-- ** FileFilterFunc #signal:FileFilterFunc#

    C_FileFilterFunc                        ,
    FileFilterFunc                          ,
    FileFilterFunc_WithClosures             ,
    drop_closures_FileFilterFunc            ,
    dynamic_FileFilterFunc                  ,
    genClosure_FileFilterFunc               ,
    mk_FileFilterFunc                       ,
    noFileFilterFunc                        ,
    noFileFilterFunc_WithClosures           ,
    wrap_FileFilterFunc                     ,


-- ** FlowBoxCreateWidgetFunc #signal:FlowBoxCreateWidgetFunc#

    C_FlowBoxCreateWidgetFunc               ,
    FlowBoxCreateWidgetFunc                 ,
    FlowBoxCreateWidgetFunc_WithClosures    ,
    drop_closures_FlowBoxCreateWidgetFunc   ,
    dynamic_FlowBoxCreateWidgetFunc         ,
    genClosure_FlowBoxCreateWidgetFunc      ,
    mk_FlowBoxCreateWidgetFunc              ,
    noFlowBoxCreateWidgetFunc               ,
    noFlowBoxCreateWidgetFunc_WithClosures  ,
    wrap_FlowBoxCreateWidgetFunc            ,


-- ** FlowBoxFilterFunc #signal:FlowBoxFilterFunc#

    C_FlowBoxFilterFunc                     ,
    FlowBoxFilterFunc                       ,
    FlowBoxFilterFunc_WithClosures          ,
    drop_closures_FlowBoxFilterFunc         ,
    dynamic_FlowBoxFilterFunc               ,
    genClosure_FlowBoxFilterFunc            ,
    mk_FlowBoxFilterFunc                    ,
    noFlowBoxFilterFunc                     ,
    noFlowBoxFilterFunc_WithClosures        ,
    wrap_FlowBoxFilterFunc                  ,


-- ** FlowBoxForeachFunc #signal:FlowBoxForeachFunc#

    C_FlowBoxForeachFunc                    ,
    FlowBoxForeachFunc                      ,
    FlowBoxForeachFunc_WithClosures         ,
    drop_closures_FlowBoxForeachFunc        ,
    dynamic_FlowBoxForeachFunc              ,
    genClosure_FlowBoxForeachFunc           ,
    mk_FlowBoxForeachFunc                   ,
    noFlowBoxForeachFunc                    ,
    noFlowBoxForeachFunc_WithClosures       ,
    wrap_FlowBoxForeachFunc                 ,


-- ** FlowBoxSortFunc #signal:FlowBoxSortFunc#

    C_FlowBoxSortFunc                       ,
    FlowBoxSortFunc                         ,
    FlowBoxSortFunc_WithClosures            ,
    drop_closures_FlowBoxSortFunc           ,
    dynamic_FlowBoxSortFunc                 ,
    genClosure_FlowBoxSortFunc              ,
    mk_FlowBoxSortFunc                      ,
    noFlowBoxSortFunc                       ,
    noFlowBoxSortFunc_WithClosures          ,
    wrap_FlowBoxSortFunc                    ,


-- ** FontFilterFunc #signal:FontFilterFunc#

    C_FontFilterFunc                        ,
    FontFilterFunc                          ,
    FontFilterFunc_WithClosures             ,
    drop_closures_FontFilterFunc            ,
    dynamic_FontFilterFunc                  ,
    genClosure_FontFilterFunc               ,
    mk_FontFilterFunc                       ,
    noFontFilterFunc                        ,
    noFontFilterFunc_WithClosures           ,
    wrap_FontFilterFunc                     ,


-- ** IconViewForeachFunc #signal:IconViewForeachFunc#

    C_IconViewForeachFunc                   ,
    IconViewForeachFunc                     ,
    IconViewForeachFunc_WithClosures        ,
    drop_closures_IconViewForeachFunc       ,
    dynamic_IconViewForeachFunc             ,
    genClosure_IconViewForeachFunc          ,
    mk_IconViewForeachFunc                  ,
    noIconViewForeachFunc                   ,
    noIconViewForeachFunc_WithClosures      ,
    wrap_IconViewForeachFunc                ,


-- ** KeySnoopFunc #signal:KeySnoopFunc#

    C_KeySnoopFunc                          ,
    KeySnoopFunc                            ,
    KeySnoopFunc_WithClosures               ,
    drop_closures_KeySnoopFunc              ,
    dynamic_KeySnoopFunc                    ,
    genClosure_KeySnoopFunc                 ,
    mk_KeySnoopFunc                         ,
    noKeySnoopFunc                          ,
    noKeySnoopFunc_WithClosures             ,
    wrap_KeySnoopFunc                       ,


-- ** ListBoxCreateWidgetFunc #signal:ListBoxCreateWidgetFunc#

    C_ListBoxCreateWidgetFunc               ,
    ListBoxCreateWidgetFunc                 ,
    ListBoxCreateWidgetFunc_WithClosures    ,
    drop_closures_ListBoxCreateWidgetFunc   ,
    dynamic_ListBoxCreateWidgetFunc         ,
    genClosure_ListBoxCreateWidgetFunc      ,
    mk_ListBoxCreateWidgetFunc              ,
    noListBoxCreateWidgetFunc               ,
    noListBoxCreateWidgetFunc_WithClosures  ,
    wrap_ListBoxCreateWidgetFunc            ,


-- ** ListBoxFilterFunc #signal:ListBoxFilterFunc#

    C_ListBoxFilterFunc                     ,
    ListBoxFilterFunc                       ,
    ListBoxFilterFunc_WithClosures          ,
    drop_closures_ListBoxFilterFunc         ,
    dynamic_ListBoxFilterFunc               ,
    genClosure_ListBoxFilterFunc            ,
    mk_ListBoxFilterFunc                    ,
    noListBoxFilterFunc                     ,
    noListBoxFilterFunc_WithClosures        ,
    wrap_ListBoxFilterFunc                  ,


-- ** ListBoxForeachFunc #signal:ListBoxForeachFunc#

    C_ListBoxForeachFunc                    ,
    ListBoxForeachFunc                      ,
    ListBoxForeachFunc_WithClosures         ,
    drop_closures_ListBoxForeachFunc        ,
    dynamic_ListBoxForeachFunc              ,
    genClosure_ListBoxForeachFunc           ,
    mk_ListBoxForeachFunc                   ,
    noListBoxForeachFunc                    ,
    noListBoxForeachFunc_WithClosures       ,
    wrap_ListBoxForeachFunc                 ,


-- ** ListBoxSortFunc #signal:ListBoxSortFunc#

    C_ListBoxSortFunc                       ,
    ListBoxSortFunc                         ,
    ListBoxSortFunc_WithClosures            ,
    drop_closures_ListBoxSortFunc           ,
    dynamic_ListBoxSortFunc                 ,
    genClosure_ListBoxSortFunc              ,
    mk_ListBoxSortFunc                      ,
    noListBoxSortFunc                       ,
    noListBoxSortFunc_WithClosures          ,
    wrap_ListBoxSortFunc                    ,


-- ** ListBoxUpdateHeaderFunc #signal:ListBoxUpdateHeaderFunc#

    C_ListBoxUpdateHeaderFunc               ,
    ListBoxUpdateHeaderFunc                 ,
    ListBoxUpdateHeaderFunc_WithClosures    ,
    drop_closures_ListBoxUpdateHeaderFunc   ,
    dynamic_ListBoxUpdateHeaderFunc         ,
    genClosure_ListBoxUpdateHeaderFunc      ,
    mk_ListBoxUpdateHeaderFunc              ,
    noListBoxUpdateHeaderFunc               ,
    noListBoxUpdateHeaderFunc_WithClosures  ,
    wrap_ListBoxUpdateHeaderFunc            ,


-- ** MenuDetachFunc #signal:MenuDetachFunc#

    C_MenuDetachFunc                        ,
    MenuDetachFunc                          ,
    dynamic_MenuDetachFunc                  ,
    genClosure_MenuDetachFunc               ,
    mk_MenuDetachFunc                       ,
    noMenuDetachFunc                        ,
    wrap_MenuDetachFunc                     ,


-- ** MenuPositionFunc #signal:MenuPositionFunc#

    C_MenuPositionFunc                      ,
    MenuPositionFunc                        ,
    MenuPositionFunc_WithClosures           ,
    drop_closures_MenuPositionFunc          ,
    dynamic_MenuPositionFunc                ,
    genClosure_MenuPositionFunc             ,
    mk_MenuPositionFunc                     ,
    noMenuPositionFunc                      ,
    noMenuPositionFunc_WithClosures         ,
    wrap_MenuPositionFunc                   ,


-- ** ModuleDisplayInitFunc #signal:ModuleDisplayInitFunc#

    C_ModuleDisplayInitFunc                 ,
    ModuleDisplayInitFunc                   ,
    dynamic_ModuleDisplayInitFunc           ,
    genClosure_ModuleDisplayInitFunc        ,
    mk_ModuleDisplayInitFunc                ,
    noModuleDisplayInitFunc                 ,
    wrap_ModuleDisplayInitFunc              ,


-- ** ModuleInitFunc #signal:ModuleInitFunc#

    C_ModuleInitFunc                        ,
    ModuleInitFunc                          ,
    dynamic_ModuleInitFunc                  ,
    genClosure_ModuleInitFunc               ,
    mk_ModuleInitFunc                       ,
    noModuleInitFunc                        ,
    wrap_ModuleInitFunc                     ,


-- ** PageSetupDoneFunc #signal:PageSetupDoneFunc#

    C_PageSetupDoneFunc                     ,
    PageSetupDoneFunc                       ,
    PageSetupDoneFunc_WithClosures          ,
    drop_closures_PageSetupDoneFunc         ,
    dynamic_PageSetupDoneFunc               ,
    genClosure_PageSetupDoneFunc            ,
    mk_PageSetupDoneFunc                    ,
    noPageSetupDoneFunc                     ,
    noPageSetupDoneFunc_WithClosures        ,
    wrap_PageSetupDoneFunc                  ,


-- ** PrintSettingsFunc #signal:PrintSettingsFunc#

    C_PrintSettingsFunc                     ,
    PrintSettingsFunc                       ,
    PrintSettingsFunc_WithClosures          ,
    drop_closures_PrintSettingsFunc         ,
    dynamic_PrintSettingsFunc               ,
    genClosure_PrintSettingsFunc            ,
    mk_PrintSettingsFunc                    ,
    noPrintSettingsFunc                     ,
    noPrintSettingsFunc_WithClosures        ,
    wrap_PrintSettingsFunc                  ,


-- ** RcPropertyParser #signal:RcPropertyParser#

    C_RcPropertyParser                      ,
    RcPropertyParser                        ,
    dynamic_RcPropertyParser                ,
    genClosure_RcPropertyParser             ,
    mk_RcPropertyParser                     ,
    noRcPropertyParser                      ,
    wrap_RcPropertyParser                   ,


-- ** RecentFilterFunc #signal:RecentFilterFunc#

    C_RecentFilterFunc                      ,
    RecentFilterFunc                        ,
    RecentFilterFunc_WithClosures           ,
    drop_closures_RecentFilterFunc          ,
    dynamic_RecentFilterFunc                ,
    genClosure_RecentFilterFunc             ,
    mk_RecentFilterFunc                     ,
    noRecentFilterFunc                      ,
    noRecentFilterFunc_WithClosures         ,
    wrap_RecentFilterFunc                   ,


-- ** RecentSortFunc #signal:RecentSortFunc#

    C_RecentSortFunc                        ,
    RecentSortFunc                          ,
    RecentSortFunc_WithClosures             ,
    drop_closures_RecentSortFunc            ,
    dynamic_RecentSortFunc                  ,
    genClosure_RecentSortFunc               ,
    mk_RecentSortFunc                       ,
    noRecentSortFunc                        ,
    noRecentSortFunc_WithClosures           ,
    wrap_RecentSortFunc                     ,


-- ** StylePropertyParser #signal:StylePropertyParser#

    C_StylePropertyParser                   ,
    StylePropertyParser                     ,
    dynamic_StylePropertyParser             ,
    mk_StylePropertyParser                  ,
    noStylePropertyParser                   ,


-- ** TextBufferDeserializeFunc #signal:TextBufferDeserializeFunc#

    C_TextBufferDeserializeFunc             ,
    TextBufferDeserializeFunc               ,
    TextBufferDeserializeFunc_WithClosures  ,
    drop_closures_TextBufferDeserializeFunc ,
    dynamic_TextBufferDeserializeFunc       ,
    mk_TextBufferDeserializeFunc            ,
    noTextBufferDeserializeFunc             ,
    noTextBufferDeserializeFunc_WithClosures,


-- ** TextBufferSerializeFunc #signal:TextBufferSerializeFunc#

    C_TextBufferSerializeFunc               ,
    TextBufferSerializeFunc                 ,
    TextBufferSerializeFunc_WithClosures    ,
    drop_closures_TextBufferSerializeFunc   ,
    dynamic_TextBufferSerializeFunc         ,
    genClosure_TextBufferSerializeFunc      ,
    mk_TextBufferSerializeFunc              ,
    noTextBufferSerializeFunc               ,
    noTextBufferSerializeFunc_WithClosures  ,
    wrap_TextBufferSerializeFunc            ,


-- ** TextCharPredicate #signal:TextCharPredicate#

    C_TextCharPredicate                     ,
    TextCharPredicate                       ,
    TextCharPredicate_WithClosures          ,
    drop_closures_TextCharPredicate         ,
    dynamic_TextCharPredicate               ,
    genClosure_TextCharPredicate            ,
    mk_TextCharPredicate                    ,
    noTextCharPredicate                     ,
    noTextCharPredicate_WithClosures        ,
    wrap_TextCharPredicate                  ,


-- ** TextTagTableForeach #signal:TextTagTableForeach#

    C_TextTagTableForeach                   ,
    TextTagTableForeach                     ,
    TextTagTableForeach_WithClosures        ,
    drop_closures_TextTagTableForeach       ,
    dynamic_TextTagTableForeach             ,
    genClosure_TextTagTableForeach          ,
    mk_TextTagTableForeach                  ,
    noTextTagTableForeach                   ,
    noTextTagTableForeach_WithClosures      ,
    wrap_TextTagTableForeach                ,


-- ** TickCallback #signal:TickCallback#

    C_TickCallback                          ,
    TickCallback                            ,
    TickCallback_WithClosures               ,
    drop_closures_TickCallback              ,
    dynamic_TickCallback                    ,
    genClosure_TickCallback                 ,
    mk_TickCallback                         ,
    noTickCallback                          ,
    noTickCallback_WithClosures             ,
    wrap_TickCallback                       ,


-- ** TranslateFunc #signal:TranslateFunc#

    C_TranslateFunc                         ,
    TranslateFunc                           ,
    TranslateFunc_WithClosures              ,
    drop_closures_TranslateFunc             ,
    dynamic_TranslateFunc                   ,
    genClosure_TranslateFunc                ,
    mk_TranslateFunc                        ,
    noTranslateFunc                         ,
    noTranslateFunc_WithClosures            ,
    wrap_TranslateFunc                      ,


-- ** TreeCellDataFunc #signal:TreeCellDataFunc#

    C_TreeCellDataFunc                      ,
    TreeCellDataFunc                        ,
    TreeCellDataFunc_WithClosures           ,
    drop_closures_TreeCellDataFunc          ,
    dynamic_TreeCellDataFunc                ,
    genClosure_TreeCellDataFunc             ,
    mk_TreeCellDataFunc                     ,
    noTreeCellDataFunc                      ,
    noTreeCellDataFunc_WithClosures         ,
    wrap_TreeCellDataFunc                   ,


-- ** TreeDestroyCountFunc #signal:TreeDestroyCountFunc#

    C_TreeDestroyCountFunc                  ,
    TreeDestroyCountFunc                    ,
    TreeDestroyCountFunc_WithClosures       ,
    drop_closures_TreeDestroyCountFunc      ,
    dynamic_TreeDestroyCountFunc            ,
    genClosure_TreeDestroyCountFunc         ,
    mk_TreeDestroyCountFunc                 ,
    noTreeDestroyCountFunc                  ,
    noTreeDestroyCountFunc_WithClosures     ,
    wrap_TreeDestroyCountFunc               ,


-- ** TreeIterCompareFunc #signal:TreeIterCompareFunc#

    C_TreeIterCompareFunc                   ,
    TreeIterCompareFunc                     ,
    TreeIterCompareFunc_WithClosures        ,
    drop_closures_TreeIterCompareFunc       ,
    dynamic_TreeIterCompareFunc             ,
    genClosure_TreeIterCompareFunc          ,
    mk_TreeIterCompareFunc                  ,
    noTreeIterCompareFunc                   ,
    noTreeIterCompareFunc_WithClosures      ,
    wrap_TreeIterCompareFunc                ,


-- ** TreeModelFilterModifyFunc #signal:TreeModelFilterModifyFunc#

    C_TreeModelFilterModifyFunc             ,
    TreeModelFilterModifyFunc               ,
    TreeModelFilterModifyFunc_WithClosures  ,
    drop_closures_TreeModelFilterModifyFunc ,
    dynamic_TreeModelFilterModifyFunc       ,
    genClosure_TreeModelFilterModifyFunc    ,
    mk_TreeModelFilterModifyFunc            ,
    noTreeModelFilterModifyFunc             ,
    noTreeModelFilterModifyFunc_WithClosures,
    wrap_TreeModelFilterModifyFunc          ,


-- ** TreeModelFilterVisibleFunc #signal:TreeModelFilterVisibleFunc#

    C_TreeModelFilterVisibleFunc            ,
    TreeModelFilterVisibleFunc              ,
    TreeModelFilterVisibleFunc_WithClosures ,
    drop_closures_TreeModelFilterVisibleFunc,
    dynamic_TreeModelFilterVisibleFunc      ,
    genClosure_TreeModelFilterVisibleFunc   ,
    mk_TreeModelFilterVisibleFunc           ,
    noTreeModelFilterVisibleFunc            ,
    noTreeModelFilterVisibleFunc_WithClosures,
    wrap_TreeModelFilterVisibleFunc         ,


-- ** TreeModelForeachFunc #signal:TreeModelForeachFunc#

    C_TreeModelForeachFunc                  ,
    TreeModelForeachFunc                    ,
    TreeModelForeachFunc_WithClosures       ,
    drop_closures_TreeModelForeachFunc      ,
    dynamic_TreeModelForeachFunc            ,
    genClosure_TreeModelForeachFunc         ,
    mk_TreeModelForeachFunc                 ,
    noTreeModelForeachFunc                  ,
    noTreeModelForeachFunc_WithClosures     ,
    wrap_TreeModelForeachFunc               ,


-- ** TreeSelectionForeachFunc #signal:TreeSelectionForeachFunc#

    C_TreeSelectionForeachFunc              ,
    TreeSelectionForeachFunc                ,
    TreeSelectionForeachFunc_WithClosures   ,
    drop_closures_TreeSelectionForeachFunc  ,
    dynamic_TreeSelectionForeachFunc        ,
    genClosure_TreeSelectionForeachFunc     ,
    mk_TreeSelectionForeachFunc             ,
    noTreeSelectionForeachFunc              ,
    noTreeSelectionForeachFunc_WithClosures ,
    wrap_TreeSelectionForeachFunc           ,


-- ** TreeSelectionFunc #signal:TreeSelectionFunc#

    C_TreeSelectionFunc                     ,
    TreeSelectionFunc                       ,
    TreeSelectionFunc_WithClosures          ,
    drop_closures_TreeSelectionFunc         ,
    dynamic_TreeSelectionFunc               ,
    genClosure_TreeSelectionFunc            ,
    mk_TreeSelectionFunc                    ,
    noTreeSelectionFunc                     ,
    noTreeSelectionFunc_WithClosures        ,
    wrap_TreeSelectionFunc                  ,


-- ** TreeViewColumnDropFunc #signal:TreeViewColumnDropFunc#

    C_TreeViewColumnDropFunc                ,
    TreeViewColumnDropFunc                  ,
    TreeViewColumnDropFunc_WithClosures     ,
    drop_closures_TreeViewColumnDropFunc    ,
    dynamic_TreeViewColumnDropFunc          ,
    genClosure_TreeViewColumnDropFunc       ,
    mk_TreeViewColumnDropFunc               ,
    noTreeViewColumnDropFunc                ,
    noTreeViewColumnDropFunc_WithClosures   ,
    wrap_TreeViewColumnDropFunc             ,


-- ** TreeViewMappingFunc #signal:TreeViewMappingFunc#

    C_TreeViewMappingFunc                   ,
    TreeViewMappingFunc                     ,
    TreeViewMappingFunc_WithClosures        ,
    drop_closures_TreeViewMappingFunc       ,
    dynamic_TreeViewMappingFunc             ,
    genClosure_TreeViewMappingFunc          ,
    mk_TreeViewMappingFunc                  ,
    noTreeViewMappingFunc                   ,
    noTreeViewMappingFunc_WithClosures      ,
    wrap_TreeViewMappingFunc                ,


-- ** TreeViewRowSeparatorFunc #signal:TreeViewRowSeparatorFunc#

    C_TreeViewRowSeparatorFunc              ,
    TreeViewRowSeparatorFunc                ,
    TreeViewRowSeparatorFunc_WithClosures   ,
    drop_closures_TreeViewRowSeparatorFunc  ,
    dynamic_TreeViewRowSeparatorFunc        ,
    genClosure_TreeViewRowSeparatorFunc     ,
    mk_TreeViewRowSeparatorFunc             ,
    noTreeViewRowSeparatorFunc              ,
    noTreeViewRowSeparatorFunc_WithClosures ,
    wrap_TreeViewRowSeparatorFunc           ,


-- ** TreeViewSearchEqualFunc #signal:TreeViewSearchEqualFunc#

    C_TreeViewSearchEqualFunc               ,
    TreeViewSearchEqualFunc                 ,
    TreeViewSearchEqualFunc_WithClosures    ,
    drop_closures_TreeViewSearchEqualFunc   ,
    dynamic_TreeViewSearchEqualFunc         ,
    genClosure_TreeViewSearchEqualFunc      ,
    mk_TreeViewSearchEqualFunc              ,
    noTreeViewSearchEqualFunc               ,
    noTreeViewSearchEqualFunc_WithClosures  ,
    wrap_TreeViewSearchEqualFunc            ,


-- ** TreeViewSearchPositionFunc #signal:TreeViewSearchPositionFunc#

    C_TreeViewSearchPositionFunc            ,
    TreeViewSearchPositionFunc              ,
    TreeViewSearchPositionFunc_WithClosures ,
    drop_closures_TreeViewSearchPositionFunc,
    dynamic_TreeViewSearchPositionFunc      ,
    genClosure_TreeViewSearchPositionFunc   ,
    mk_TreeViewSearchPositionFunc           ,
    noTreeViewSearchPositionFunc            ,
    noTreeViewSearchPositionFunc_WithClosures,
    wrap_TreeViewSearchPositionFunc         ,


-- ** WidgetClassAdjustBaselineAllocationFieldCallback #signal:WidgetClassAdjustBaselineAllocationFieldCallback#

    C_WidgetClassAdjustBaselineAllocationFieldCallback,
    WidgetClassAdjustBaselineAllocationFieldCallback,
    dynamic_WidgetClassAdjustBaselineAllocationFieldCallback,
    genClosure_WidgetClassAdjustBaselineAllocationFieldCallback,
    mk_WidgetClassAdjustBaselineAllocationFieldCallback,
    noWidgetClassAdjustBaselineAllocationFieldCallback,
    wrap_WidgetClassAdjustBaselineAllocationFieldCallback,


-- ** WidgetClassAdjustBaselineRequestFieldCallback #signal:WidgetClassAdjustBaselineRequestFieldCallback#

    C_WidgetClassAdjustBaselineRequestFieldCallback,
    WidgetClassAdjustBaselineRequestFieldCallback,
    dynamic_WidgetClassAdjustBaselineRequestFieldCallback,
    genClosure_WidgetClassAdjustBaselineRequestFieldCallback,
    mk_WidgetClassAdjustBaselineRequestFieldCallback,
    noWidgetClassAdjustBaselineRequestFieldCallback,
    wrap_WidgetClassAdjustBaselineRequestFieldCallback,


-- ** WidgetClassAdjustSizeAllocationFieldCallback #signal:WidgetClassAdjustSizeAllocationFieldCallback#

    C_WidgetClassAdjustSizeAllocationFieldCallback,
    WidgetClassAdjustSizeAllocationFieldCallback,
    dynamic_WidgetClassAdjustSizeAllocationFieldCallback,
    genClosure_WidgetClassAdjustSizeAllocationFieldCallback,
    mk_WidgetClassAdjustSizeAllocationFieldCallback,
    noWidgetClassAdjustSizeAllocationFieldCallback,
    wrap_WidgetClassAdjustSizeAllocationFieldCallback,


-- ** WidgetClassAdjustSizeRequestFieldCallback #signal:WidgetClassAdjustSizeRequestFieldCallback#

    C_WidgetClassAdjustSizeRequestFieldCallback,
    WidgetClassAdjustSizeRequestFieldCallback,
    dynamic_WidgetClassAdjustSizeRequestFieldCallback,
    genClosure_WidgetClassAdjustSizeRequestFieldCallback,
    mk_WidgetClassAdjustSizeRequestFieldCallback,
    noWidgetClassAdjustSizeRequestFieldCallback,
    wrap_WidgetClassAdjustSizeRequestFieldCallback,


-- ** WidgetClassButtonPressEventFieldCallback #signal:WidgetClassButtonPressEventFieldCallback#

    C_WidgetClassButtonPressEventFieldCallback,
    WidgetClassButtonPressEventFieldCallback,
    dynamic_WidgetClassButtonPressEventFieldCallback,
    genClosure_WidgetClassButtonPressEventFieldCallback,
    mk_WidgetClassButtonPressEventFieldCallback,
    noWidgetClassButtonPressEventFieldCallback,
    wrap_WidgetClassButtonPressEventFieldCallback,


-- ** WidgetClassButtonReleaseEventFieldCallback #signal:WidgetClassButtonReleaseEventFieldCallback#

    C_WidgetClassButtonReleaseEventFieldCallback,
    WidgetClassButtonReleaseEventFieldCallback,
    dynamic_WidgetClassButtonReleaseEventFieldCallback,
    genClosure_WidgetClassButtonReleaseEventFieldCallback,
    mk_WidgetClassButtonReleaseEventFieldCallback,
    noWidgetClassButtonReleaseEventFieldCallback,
    wrap_WidgetClassButtonReleaseEventFieldCallback,


-- ** WidgetClassCanActivateAccelFieldCallback #signal:WidgetClassCanActivateAccelFieldCallback#

    C_WidgetClassCanActivateAccelFieldCallback,
    WidgetClassCanActivateAccelFieldCallback,
    dynamic_WidgetClassCanActivateAccelFieldCallback,
    genClosure_WidgetClassCanActivateAccelFieldCallback,
    mk_WidgetClassCanActivateAccelFieldCallback,
    noWidgetClassCanActivateAccelFieldCallback,
    wrap_WidgetClassCanActivateAccelFieldCallback,


-- ** WidgetClassChildNotifyFieldCallback #signal:WidgetClassChildNotifyFieldCallback#

    C_WidgetClassChildNotifyFieldCallback   ,
    WidgetClassChildNotifyFieldCallback     ,
    dynamic_WidgetClassChildNotifyFieldCallback,
    genClosure_WidgetClassChildNotifyFieldCallback,
    mk_WidgetClassChildNotifyFieldCallback  ,
    noWidgetClassChildNotifyFieldCallback   ,
    wrap_WidgetClassChildNotifyFieldCallback,


-- ** WidgetClassCompositedChangedFieldCallback #signal:WidgetClassCompositedChangedFieldCallback#

    C_WidgetClassCompositedChangedFieldCallback,
    WidgetClassCompositedChangedFieldCallback,
    dynamic_WidgetClassCompositedChangedFieldCallback,
    genClosure_WidgetClassCompositedChangedFieldCallback,
    mk_WidgetClassCompositedChangedFieldCallback,
    noWidgetClassCompositedChangedFieldCallback,
    wrap_WidgetClassCompositedChangedFieldCallback,


-- ** WidgetClassComputeExpandFieldCallback #signal:WidgetClassComputeExpandFieldCallback#

    C_WidgetClassComputeExpandFieldCallback ,
    WidgetClassComputeExpandFieldCallback   ,
    dynamic_WidgetClassComputeExpandFieldCallback,
    genClosure_WidgetClassComputeExpandFieldCallback,
    mk_WidgetClassComputeExpandFieldCallback,
    noWidgetClassComputeExpandFieldCallback ,
    wrap_WidgetClassComputeExpandFieldCallback,


-- ** WidgetClassConfigureEventFieldCallback #signal:WidgetClassConfigureEventFieldCallback#

    C_WidgetClassConfigureEventFieldCallback,
    WidgetClassConfigureEventFieldCallback  ,
    dynamic_WidgetClassConfigureEventFieldCallback,
    genClosure_WidgetClassConfigureEventFieldCallback,
    mk_WidgetClassConfigureEventFieldCallback,
    noWidgetClassConfigureEventFieldCallback,
    wrap_WidgetClassConfigureEventFieldCallback,


-- ** WidgetClassDamageEventFieldCallback #signal:WidgetClassDamageEventFieldCallback#

    C_WidgetClassDamageEventFieldCallback   ,
    WidgetClassDamageEventFieldCallback     ,
    dynamic_WidgetClassDamageEventFieldCallback,
    genClosure_WidgetClassDamageEventFieldCallback,
    mk_WidgetClassDamageEventFieldCallback  ,
    noWidgetClassDamageEventFieldCallback   ,
    wrap_WidgetClassDamageEventFieldCallback,


-- ** WidgetClassDeleteEventFieldCallback #signal:WidgetClassDeleteEventFieldCallback#

    C_WidgetClassDeleteEventFieldCallback   ,
    WidgetClassDeleteEventFieldCallback     ,
    dynamic_WidgetClassDeleteEventFieldCallback,
    genClosure_WidgetClassDeleteEventFieldCallback,
    mk_WidgetClassDeleteEventFieldCallback  ,
    noWidgetClassDeleteEventFieldCallback   ,
    wrap_WidgetClassDeleteEventFieldCallback,


-- ** WidgetClassDestroyEventFieldCallback #signal:WidgetClassDestroyEventFieldCallback#

    C_WidgetClassDestroyEventFieldCallback  ,
    WidgetClassDestroyEventFieldCallback    ,
    dynamic_WidgetClassDestroyEventFieldCallback,
    genClosure_WidgetClassDestroyEventFieldCallback,
    mk_WidgetClassDestroyEventFieldCallback ,
    noWidgetClassDestroyEventFieldCallback  ,
    wrap_WidgetClassDestroyEventFieldCallback,


-- ** WidgetClassDestroyFieldCallback #signal:WidgetClassDestroyFieldCallback#

    C_WidgetClassDestroyFieldCallback       ,
    WidgetClassDestroyFieldCallback         ,
    dynamic_WidgetClassDestroyFieldCallback ,
    genClosure_WidgetClassDestroyFieldCallback,
    mk_WidgetClassDestroyFieldCallback      ,
    noWidgetClassDestroyFieldCallback       ,
    wrap_WidgetClassDestroyFieldCallback    ,


-- ** WidgetClassDirectionChangedFieldCallback #signal:WidgetClassDirectionChangedFieldCallback#

    C_WidgetClassDirectionChangedFieldCallback,
    WidgetClassDirectionChangedFieldCallback,
    dynamic_WidgetClassDirectionChangedFieldCallback,
    genClosure_WidgetClassDirectionChangedFieldCallback,
    mk_WidgetClassDirectionChangedFieldCallback,
    noWidgetClassDirectionChangedFieldCallback,
    wrap_WidgetClassDirectionChangedFieldCallback,


-- ** WidgetClassDispatchChildPropertiesChangedFieldCallback #signal:WidgetClassDispatchChildPropertiesChangedFieldCallback#

    C_WidgetClassDispatchChildPropertiesChangedFieldCallback,
    WidgetClassDispatchChildPropertiesChangedFieldCallback,
    dynamic_WidgetClassDispatchChildPropertiesChangedFieldCallback,
    genClosure_WidgetClassDispatchChildPropertiesChangedFieldCallback,
    mk_WidgetClassDispatchChildPropertiesChangedFieldCallback,
    noWidgetClassDispatchChildPropertiesChangedFieldCallback,
    wrap_WidgetClassDispatchChildPropertiesChangedFieldCallback,


-- ** WidgetClassDragBeginFieldCallback #signal:WidgetClassDragBeginFieldCallback#

    C_WidgetClassDragBeginFieldCallback     ,
    WidgetClassDragBeginFieldCallback       ,
    dynamic_WidgetClassDragBeginFieldCallback,
    genClosure_WidgetClassDragBeginFieldCallback,
    mk_WidgetClassDragBeginFieldCallback    ,
    noWidgetClassDragBeginFieldCallback     ,
    wrap_WidgetClassDragBeginFieldCallback  ,


-- ** WidgetClassDragDataDeleteFieldCallback #signal:WidgetClassDragDataDeleteFieldCallback#

    C_WidgetClassDragDataDeleteFieldCallback,
    WidgetClassDragDataDeleteFieldCallback  ,
    dynamic_WidgetClassDragDataDeleteFieldCallback,
    genClosure_WidgetClassDragDataDeleteFieldCallback,
    mk_WidgetClassDragDataDeleteFieldCallback,
    noWidgetClassDragDataDeleteFieldCallback,
    wrap_WidgetClassDragDataDeleteFieldCallback,


-- ** WidgetClassDragDataGetFieldCallback #signal:WidgetClassDragDataGetFieldCallback#

    C_WidgetClassDragDataGetFieldCallback   ,
    WidgetClassDragDataGetFieldCallback     ,
    dynamic_WidgetClassDragDataGetFieldCallback,
    genClosure_WidgetClassDragDataGetFieldCallback,
    mk_WidgetClassDragDataGetFieldCallback  ,
    noWidgetClassDragDataGetFieldCallback   ,
    wrap_WidgetClassDragDataGetFieldCallback,


-- ** WidgetClassDragDataReceivedFieldCallback #signal:WidgetClassDragDataReceivedFieldCallback#

    C_WidgetClassDragDataReceivedFieldCallback,
    WidgetClassDragDataReceivedFieldCallback,
    dynamic_WidgetClassDragDataReceivedFieldCallback,
    genClosure_WidgetClassDragDataReceivedFieldCallback,
    mk_WidgetClassDragDataReceivedFieldCallback,
    noWidgetClassDragDataReceivedFieldCallback,
    wrap_WidgetClassDragDataReceivedFieldCallback,


-- ** WidgetClassDragDropFieldCallback #signal:WidgetClassDragDropFieldCallback#

    C_WidgetClassDragDropFieldCallback      ,
    WidgetClassDragDropFieldCallback        ,
    dynamic_WidgetClassDragDropFieldCallback,
    genClosure_WidgetClassDragDropFieldCallback,
    mk_WidgetClassDragDropFieldCallback     ,
    noWidgetClassDragDropFieldCallback      ,
    wrap_WidgetClassDragDropFieldCallback   ,


-- ** WidgetClassDragEndFieldCallback #signal:WidgetClassDragEndFieldCallback#

    C_WidgetClassDragEndFieldCallback       ,
    WidgetClassDragEndFieldCallback         ,
    dynamic_WidgetClassDragEndFieldCallback ,
    genClosure_WidgetClassDragEndFieldCallback,
    mk_WidgetClassDragEndFieldCallback      ,
    noWidgetClassDragEndFieldCallback       ,
    wrap_WidgetClassDragEndFieldCallback    ,


-- ** WidgetClassDragFailedFieldCallback #signal:WidgetClassDragFailedFieldCallback#

    C_WidgetClassDragFailedFieldCallback    ,
    WidgetClassDragFailedFieldCallback      ,
    dynamic_WidgetClassDragFailedFieldCallback,
    genClosure_WidgetClassDragFailedFieldCallback,
    mk_WidgetClassDragFailedFieldCallback   ,
    noWidgetClassDragFailedFieldCallback    ,
    wrap_WidgetClassDragFailedFieldCallback ,


-- ** WidgetClassDragLeaveFieldCallback #signal:WidgetClassDragLeaveFieldCallback#

    C_WidgetClassDragLeaveFieldCallback     ,
    WidgetClassDragLeaveFieldCallback       ,
    dynamic_WidgetClassDragLeaveFieldCallback,
    genClosure_WidgetClassDragLeaveFieldCallback,
    mk_WidgetClassDragLeaveFieldCallback    ,
    noWidgetClassDragLeaveFieldCallback     ,
    wrap_WidgetClassDragLeaveFieldCallback  ,


-- ** WidgetClassDragMotionFieldCallback #signal:WidgetClassDragMotionFieldCallback#

    C_WidgetClassDragMotionFieldCallback    ,
    WidgetClassDragMotionFieldCallback      ,
    dynamic_WidgetClassDragMotionFieldCallback,
    genClosure_WidgetClassDragMotionFieldCallback,
    mk_WidgetClassDragMotionFieldCallback   ,
    noWidgetClassDragMotionFieldCallback    ,
    wrap_WidgetClassDragMotionFieldCallback ,


-- ** WidgetClassDrawFieldCallback #signal:WidgetClassDrawFieldCallback#

    C_WidgetClassDrawFieldCallback          ,
    WidgetClassDrawFieldCallback            ,
    dynamic_WidgetClassDrawFieldCallback    ,
    genClosure_WidgetClassDrawFieldCallback ,
    mk_WidgetClassDrawFieldCallback         ,
    noWidgetClassDrawFieldCallback          ,
    wrap_WidgetClassDrawFieldCallback       ,


-- ** WidgetClassEnterNotifyEventFieldCallback #signal:WidgetClassEnterNotifyEventFieldCallback#

    C_WidgetClassEnterNotifyEventFieldCallback,
    WidgetClassEnterNotifyEventFieldCallback,
    dynamic_WidgetClassEnterNotifyEventFieldCallback,
    genClosure_WidgetClassEnterNotifyEventFieldCallback,
    mk_WidgetClassEnterNotifyEventFieldCallback,
    noWidgetClassEnterNotifyEventFieldCallback,
    wrap_WidgetClassEnterNotifyEventFieldCallback,


-- ** WidgetClassEventFieldCallback #signal:WidgetClassEventFieldCallback#

    C_WidgetClassEventFieldCallback         ,
    WidgetClassEventFieldCallback           ,
    dynamic_WidgetClassEventFieldCallback   ,
    genClosure_WidgetClassEventFieldCallback,
    mk_WidgetClassEventFieldCallback        ,
    noWidgetClassEventFieldCallback         ,
    wrap_WidgetClassEventFieldCallback      ,


-- ** WidgetClassFocusFieldCallback #signal:WidgetClassFocusFieldCallback#

    C_WidgetClassFocusFieldCallback         ,
    WidgetClassFocusFieldCallback           ,
    dynamic_WidgetClassFocusFieldCallback   ,
    genClosure_WidgetClassFocusFieldCallback,
    mk_WidgetClassFocusFieldCallback        ,
    noWidgetClassFocusFieldCallback         ,
    wrap_WidgetClassFocusFieldCallback      ,


-- ** WidgetClassFocusInEventFieldCallback #signal:WidgetClassFocusInEventFieldCallback#

    C_WidgetClassFocusInEventFieldCallback  ,
    WidgetClassFocusInEventFieldCallback    ,
    dynamic_WidgetClassFocusInEventFieldCallback,
    genClosure_WidgetClassFocusInEventFieldCallback,
    mk_WidgetClassFocusInEventFieldCallback ,
    noWidgetClassFocusInEventFieldCallback  ,
    wrap_WidgetClassFocusInEventFieldCallback,


-- ** WidgetClassFocusOutEventFieldCallback #signal:WidgetClassFocusOutEventFieldCallback#

    C_WidgetClassFocusOutEventFieldCallback ,
    WidgetClassFocusOutEventFieldCallback   ,
    dynamic_WidgetClassFocusOutEventFieldCallback,
    genClosure_WidgetClassFocusOutEventFieldCallback,
    mk_WidgetClassFocusOutEventFieldCallback,
    noWidgetClassFocusOutEventFieldCallback ,
    wrap_WidgetClassFocusOutEventFieldCallback,


-- ** WidgetClassGetAccessibleFieldCallback #signal:WidgetClassGetAccessibleFieldCallback#

    C_WidgetClassGetAccessibleFieldCallback ,
    WidgetClassGetAccessibleFieldCallback   ,
    dynamic_WidgetClassGetAccessibleFieldCallback,
    genClosure_WidgetClassGetAccessibleFieldCallback,
    mk_WidgetClassGetAccessibleFieldCallback,
    noWidgetClassGetAccessibleFieldCallback ,
    wrap_WidgetClassGetAccessibleFieldCallback,


-- ** WidgetClassGetPreferredHeightAndBaselineForWidthFieldCallback #signal:WidgetClassGetPreferredHeightAndBaselineForWidthFieldCallback#

    C_WidgetClassGetPreferredHeightAndBaselineForWidthFieldCallback,
    WidgetClassGetPreferredHeightAndBaselineForWidthFieldCallback,
    dynamic_WidgetClassGetPreferredHeightAndBaselineForWidthFieldCallback,
    genClosure_WidgetClassGetPreferredHeightAndBaselineForWidthFieldCallback,
    mk_WidgetClassGetPreferredHeightAndBaselineForWidthFieldCallback,
    noWidgetClassGetPreferredHeightAndBaselineForWidthFieldCallback,
    wrap_WidgetClassGetPreferredHeightAndBaselineForWidthFieldCallback,


-- ** WidgetClassGetPreferredHeightFieldCallback #signal:WidgetClassGetPreferredHeightFieldCallback#

    C_WidgetClassGetPreferredHeightFieldCallback,
    WidgetClassGetPreferredHeightFieldCallback,
    dynamic_WidgetClassGetPreferredHeightFieldCallback,
    genClosure_WidgetClassGetPreferredHeightFieldCallback,
    mk_WidgetClassGetPreferredHeightFieldCallback,
    noWidgetClassGetPreferredHeightFieldCallback,
    wrap_WidgetClassGetPreferredHeightFieldCallback,


-- ** WidgetClassGetPreferredHeightForWidthFieldCallback #signal:WidgetClassGetPreferredHeightForWidthFieldCallback#

    C_WidgetClassGetPreferredHeightForWidthFieldCallback,
    WidgetClassGetPreferredHeightForWidthFieldCallback,
    dynamic_WidgetClassGetPreferredHeightForWidthFieldCallback,
    genClosure_WidgetClassGetPreferredHeightForWidthFieldCallback,
    mk_WidgetClassGetPreferredHeightForWidthFieldCallback,
    noWidgetClassGetPreferredHeightForWidthFieldCallback,
    wrap_WidgetClassGetPreferredHeightForWidthFieldCallback,


-- ** WidgetClassGetPreferredWidthFieldCallback #signal:WidgetClassGetPreferredWidthFieldCallback#

    C_WidgetClassGetPreferredWidthFieldCallback,
    WidgetClassGetPreferredWidthFieldCallback,
    dynamic_WidgetClassGetPreferredWidthFieldCallback,
    genClosure_WidgetClassGetPreferredWidthFieldCallback,
    mk_WidgetClassGetPreferredWidthFieldCallback,
    noWidgetClassGetPreferredWidthFieldCallback,
    wrap_WidgetClassGetPreferredWidthFieldCallback,


-- ** WidgetClassGetPreferredWidthForHeightFieldCallback #signal:WidgetClassGetPreferredWidthForHeightFieldCallback#

    C_WidgetClassGetPreferredWidthForHeightFieldCallback,
    WidgetClassGetPreferredWidthForHeightFieldCallback,
    dynamic_WidgetClassGetPreferredWidthForHeightFieldCallback,
    genClosure_WidgetClassGetPreferredWidthForHeightFieldCallback,
    mk_WidgetClassGetPreferredWidthForHeightFieldCallback,
    noWidgetClassGetPreferredWidthForHeightFieldCallback,
    wrap_WidgetClassGetPreferredWidthForHeightFieldCallback,


-- ** WidgetClassGetRequestModeFieldCallback #signal:WidgetClassGetRequestModeFieldCallback#

    C_WidgetClassGetRequestModeFieldCallback,
    WidgetClassGetRequestModeFieldCallback  ,
    dynamic_WidgetClassGetRequestModeFieldCallback,
    genClosure_WidgetClassGetRequestModeFieldCallback,
    mk_WidgetClassGetRequestModeFieldCallback,
    noWidgetClassGetRequestModeFieldCallback,
    wrap_WidgetClassGetRequestModeFieldCallback,


-- ** WidgetClassGrabBrokenEventFieldCallback #signal:WidgetClassGrabBrokenEventFieldCallback#

    C_WidgetClassGrabBrokenEventFieldCallback,
    WidgetClassGrabBrokenEventFieldCallback ,
    dynamic_WidgetClassGrabBrokenEventFieldCallback,
    genClosure_WidgetClassGrabBrokenEventFieldCallback,
    mk_WidgetClassGrabBrokenEventFieldCallback,
    noWidgetClassGrabBrokenEventFieldCallback,
    wrap_WidgetClassGrabBrokenEventFieldCallback,


-- ** WidgetClassGrabFocusFieldCallback #signal:WidgetClassGrabFocusFieldCallback#

    C_WidgetClassGrabFocusFieldCallback     ,
    WidgetClassGrabFocusFieldCallback       ,
    dynamic_WidgetClassGrabFocusFieldCallback,
    genClosure_WidgetClassGrabFocusFieldCallback,
    mk_WidgetClassGrabFocusFieldCallback    ,
    noWidgetClassGrabFocusFieldCallback     ,
    wrap_WidgetClassGrabFocusFieldCallback  ,


-- ** WidgetClassGrabNotifyFieldCallback #signal:WidgetClassGrabNotifyFieldCallback#

    C_WidgetClassGrabNotifyFieldCallback    ,
    WidgetClassGrabNotifyFieldCallback      ,
    dynamic_WidgetClassGrabNotifyFieldCallback,
    genClosure_WidgetClassGrabNotifyFieldCallback,
    mk_WidgetClassGrabNotifyFieldCallback   ,
    noWidgetClassGrabNotifyFieldCallback    ,
    wrap_WidgetClassGrabNotifyFieldCallback ,


-- ** WidgetClassHideFieldCallback #signal:WidgetClassHideFieldCallback#

    C_WidgetClassHideFieldCallback          ,
    WidgetClassHideFieldCallback            ,
    dynamic_WidgetClassHideFieldCallback    ,
    genClosure_WidgetClassHideFieldCallback ,
    mk_WidgetClassHideFieldCallback         ,
    noWidgetClassHideFieldCallback          ,
    wrap_WidgetClassHideFieldCallback       ,


-- ** WidgetClassHierarchyChangedFieldCallback #signal:WidgetClassHierarchyChangedFieldCallback#

    C_WidgetClassHierarchyChangedFieldCallback,
    WidgetClassHierarchyChangedFieldCallback,
    dynamic_WidgetClassHierarchyChangedFieldCallback,
    genClosure_WidgetClassHierarchyChangedFieldCallback,
    mk_WidgetClassHierarchyChangedFieldCallback,
    noWidgetClassHierarchyChangedFieldCallback,
    wrap_WidgetClassHierarchyChangedFieldCallback,


-- ** WidgetClassKeyPressEventFieldCallback #signal:WidgetClassKeyPressEventFieldCallback#

    C_WidgetClassKeyPressEventFieldCallback ,
    WidgetClassKeyPressEventFieldCallback   ,
    dynamic_WidgetClassKeyPressEventFieldCallback,
    genClosure_WidgetClassKeyPressEventFieldCallback,
    mk_WidgetClassKeyPressEventFieldCallback,
    noWidgetClassKeyPressEventFieldCallback ,
    wrap_WidgetClassKeyPressEventFieldCallback,


-- ** WidgetClassKeyReleaseEventFieldCallback #signal:WidgetClassKeyReleaseEventFieldCallback#

    C_WidgetClassKeyReleaseEventFieldCallback,
    WidgetClassKeyReleaseEventFieldCallback ,
    dynamic_WidgetClassKeyReleaseEventFieldCallback,
    genClosure_WidgetClassKeyReleaseEventFieldCallback,
    mk_WidgetClassKeyReleaseEventFieldCallback,
    noWidgetClassKeyReleaseEventFieldCallback,
    wrap_WidgetClassKeyReleaseEventFieldCallback,


-- ** WidgetClassKeynavFailedFieldCallback #signal:WidgetClassKeynavFailedFieldCallback#

    C_WidgetClassKeynavFailedFieldCallback  ,
    WidgetClassKeynavFailedFieldCallback    ,
    dynamic_WidgetClassKeynavFailedFieldCallback,
    genClosure_WidgetClassKeynavFailedFieldCallback,
    mk_WidgetClassKeynavFailedFieldCallback ,
    noWidgetClassKeynavFailedFieldCallback  ,
    wrap_WidgetClassKeynavFailedFieldCallback,


-- ** WidgetClassLeaveNotifyEventFieldCallback #signal:WidgetClassLeaveNotifyEventFieldCallback#

    C_WidgetClassLeaveNotifyEventFieldCallback,
    WidgetClassLeaveNotifyEventFieldCallback,
    dynamic_WidgetClassLeaveNotifyEventFieldCallback,
    genClosure_WidgetClassLeaveNotifyEventFieldCallback,
    mk_WidgetClassLeaveNotifyEventFieldCallback,
    noWidgetClassLeaveNotifyEventFieldCallback,
    wrap_WidgetClassLeaveNotifyEventFieldCallback,


-- ** WidgetClassMapEventFieldCallback #signal:WidgetClassMapEventFieldCallback#

    C_WidgetClassMapEventFieldCallback      ,
    WidgetClassMapEventFieldCallback        ,
    dynamic_WidgetClassMapEventFieldCallback,
    genClosure_WidgetClassMapEventFieldCallback,
    mk_WidgetClassMapEventFieldCallback     ,
    noWidgetClassMapEventFieldCallback      ,
    wrap_WidgetClassMapEventFieldCallback   ,


-- ** WidgetClassMapFieldCallback #signal:WidgetClassMapFieldCallback#

    C_WidgetClassMapFieldCallback           ,
    WidgetClassMapFieldCallback             ,
    dynamic_WidgetClassMapFieldCallback     ,
    genClosure_WidgetClassMapFieldCallback  ,
    mk_WidgetClassMapFieldCallback          ,
    noWidgetClassMapFieldCallback           ,
    wrap_WidgetClassMapFieldCallback        ,


-- ** WidgetClassMnemonicActivateFieldCallback #signal:WidgetClassMnemonicActivateFieldCallback#

    C_WidgetClassMnemonicActivateFieldCallback,
    WidgetClassMnemonicActivateFieldCallback,
    dynamic_WidgetClassMnemonicActivateFieldCallback,
    genClosure_WidgetClassMnemonicActivateFieldCallback,
    mk_WidgetClassMnemonicActivateFieldCallback,
    noWidgetClassMnemonicActivateFieldCallback,
    wrap_WidgetClassMnemonicActivateFieldCallback,


-- ** WidgetClassMotionNotifyEventFieldCallback #signal:WidgetClassMotionNotifyEventFieldCallback#

    C_WidgetClassMotionNotifyEventFieldCallback,
    WidgetClassMotionNotifyEventFieldCallback,
    dynamic_WidgetClassMotionNotifyEventFieldCallback,
    genClosure_WidgetClassMotionNotifyEventFieldCallback,
    mk_WidgetClassMotionNotifyEventFieldCallback,
    noWidgetClassMotionNotifyEventFieldCallback,
    wrap_WidgetClassMotionNotifyEventFieldCallback,


-- ** WidgetClassMoveFocusFieldCallback #signal:WidgetClassMoveFocusFieldCallback#

    C_WidgetClassMoveFocusFieldCallback     ,
    WidgetClassMoveFocusFieldCallback       ,
    dynamic_WidgetClassMoveFocusFieldCallback,
    genClosure_WidgetClassMoveFocusFieldCallback,
    mk_WidgetClassMoveFocusFieldCallback    ,
    noWidgetClassMoveFocusFieldCallback     ,
    wrap_WidgetClassMoveFocusFieldCallback  ,


-- ** WidgetClassParentSetFieldCallback #signal:WidgetClassParentSetFieldCallback#

    C_WidgetClassParentSetFieldCallback     ,
    WidgetClassParentSetFieldCallback       ,
    dynamic_WidgetClassParentSetFieldCallback,
    genClosure_WidgetClassParentSetFieldCallback,
    mk_WidgetClassParentSetFieldCallback    ,
    noWidgetClassParentSetFieldCallback     ,
    wrap_WidgetClassParentSetFieldCallback  ,


-- ** WidgetClassPopupMenuFieldCallback #signal:WidgetClassPopupMenuFieldCallback#

    C_WidgetClassPopupMenuFieldCallback     ,
    WidgetClassPopupMenuFieldCallback       ,
    dynamic_WidgetClassPopupMenuFieldCallback,
    genClosure_WidgetClassPopupMenuFieldCallback,
    mk_WidgetClassPopupMenuFieldCallback    ,
    noWidgetClassPopupMenuFieldCallback     ,
    wrap_WidgetClassPopupMenuFieldCallback  ,


-- ** WidgetClassPropertyNotifyEventFieldCallback #signal:WidgetClassPropertyNotifyEventFieldCallback#

    C_WidgetClassPropertyNotifyEventFieldCallback,
    WidgetClassPropertyNotifyEventFieldCallback,
    dynamic_WidgetClassPropertyNotifyEventFieldCallback,
    genClosure_WidgetClassPropertyNotifyEventFieldCallback,
    mk_WidgetClassPropertyNotifyEventFieldCallback,
    noWidgetClassPropertyNotifyEventFieldCallback,
    wrap_WidgetClassPropertyNotifyEventFieldCallback,


-- ** WidgetClassProximityInEventFieldCallback #signal:WidgetClassProximityInEventFieldCallback#

    C_WidgetClassProximityInEventFieldCallback,
    WidgetClassProximityInEventFieldCallback,
    dynamic_WidgetClassProximityInEventFieldCallback,
    genClosure_WidgetClassProximityInEventFieldCallback,
    mk_WidgetClassProximityInEventFieldCallback,
    noWidgetClassProximityInEventFieldCallback,
    wrap_WidgetClassProximityInEventFieldCallback,


-- ** WidgetClassProximityOutEventFieldCallback #signal:WidgetClassProximityOutEventFieldCallback#

    C_WidgetClassProximityOutEventFieldCallback,
    WidgetClassProximityOutEventFieldCallback,
    dynamic_WidgetClassProximityOutEventFieldCallback,
    genClosure_WidgetClassProximityOutEventFieldCallback,
    mk_WidgetClassProximityOutEventFieldCallback,
    noWidgetClassProximityOutEventFieldCallback,
    wrap_WidgetClassProximityOutEventFieldCallback,


-- ** WidgetClassQueryTooltipFieldCallback #signal:WidgetClassQueryTooltipFieldCallback#

    C_WidgetClassQueryTooltipFieldCallback  ,
    WidgetClassQueryTooltipFieldCallback    ,
    dynamic_WidgetClassQueryTooltipFieldCallback,
    genClosure_WidgetClassQueryTooltipFieldCallback,
    mk_WidgetClassQueryTooltipFieldCallback ,
    noWidgetClassQueryTooltipFieldCallback  ,
    wrap_WidgetClassQueryTooltipFieldCallback,


-- ** WidgetClassQueueDrawRegionFieldCallback #signal:WidgetClassQueueDrawRegionFieldCallback#

    C_WidgetClassQueueDrawRegionFieldCallback,
    WidgetClassQueueDrawRegionFieldCallback ,
    dynamic_WidgetClassQueueDrawRegionFieldCallback,
    genClosure_WidgetClassQueueDrawRegionFieldCallback,
    mk_WidgetClassQueueDrawRegionFieldCallback,
    noWidgetClassQueueDrawRegionFieldCallback,
    wrap_WidgetClassQueueDrawRegionFieldCallback,


-- ** WidgetClassRealizeFieldCallback #signal:WidgetClassRealizeFieldCallback#

    C_WidgetClassRealizeFieldCallback       ,
    WidgetClassRealizeFieldCallback         ,
    dynamic_WidgetClassRealizeFieldCallback ,
    genClosure_WidgetClassRealizeFieldCallback,
    mk_WidgetClassRealizeFieldCallback      ,
    noWidgetClassRealizeFieldCallback       ,
    wrap_WidgetClassRealizeFieldCallback    ,


-- ** WidgetClassScreenChangedFieldCallback #signal:WidgetClassScreenChangedFieldCallback#

    C_WidgetClassScreenChangedFieldCallback ,
    WidgetClassScreenChangedFieldCallback   ,
    dynamic_WidgetClassScreenChangedFieldCallback,
    genClosure_WidgetClassScreenChangedFieldCallback,
    mk_WidgetClassScreenChangedFieldCallback,
    noWidgetClassScreenChangedFieldCallback ,
    wrap_WidgetClassScreenChangedFieldCallback,


-- ** WidgetClassScrollEventFieldCallback #signal:WidgetClassScrollEventFieldCallback#

    C_WidgetClassScrollEventFieldCallback   ,
    WidgetClassScrollEventFieldCallback     ,
    dynamic_WidgetClassScrollEventFieldCallback,
    genClosure_WidgetClassScrollEventFieldCallback,
    mk_WidgetClassScrollEventFieldCallback  ,
    noWidgetClassScrollEventFieldCallback   ,
    wrap_WidgetClassScrollEventFieldCallback,


-- ** WidgetClassSelectionClearEventFieldCallback #signal:WidgetClassSelectionClearEventFieldCallback#

    C_WidgetClassSelectionClearEventFieldCallback,
    WidgetClassSelectionClearEventFieldCallback,
    dynamic_WidgetClassSelectionClearEventFieldCallback,
    genClosure_WidgetClassSelectionClearEventFieldCallback,
    mk_WidgetClassSelectionClearEventFieldCallback,
    noWidgetClassSelectionClearEventFieldCallback,
    wrap_WidgetClassSelectionClearEventFieldCallback,


-- ** WidgetClassSelectionGetFieldCallback #signal:WidgetClassSelectionGetFieldCallback#

    C_WidgetClassSelectionGetFieldCallback  ,
    WidgetClassSelectionGetFieldCallback    ,
    dynamic_WidgetClassSelectionGetFieldCallback,
    genClosure_WidgetClassSelectionGetFieldCallback,
    mk_WidgetClassSelectionGetFieldCallback ,
    noWidgetClassSelectionGetFieldCallback  ,
    wrap_WidgetClassSelectionGetFieldCallback,


-- ** WidgetClassSelectionNotifyEventFieldCallback #signal:WidgetClassSelectionNotifyEventFieldCallback#

    C_WidgetClassSelectionNotifyEventFieldCallback,
    WidgetClassSelectionNotifyEventFieldCallback,
    dynamic_WidgetClassSelectionNotifyEventFieldCallback,
    genClosure_WidgetClassSelectionNotifyEventFieldCallback,
    mk_WidgetClassSelectionNotifyEventFieldCallback,
    noWidgetClassSelectionNotifyEventFieldCallback,
    wrap_WidgetClassSelectionNotifyEventFieldCallback,


-- ** WidgetClassSelectionReceivedFieldCallback #signal:WidgetClassSelectionReceivedFieldCallback#

    C_WidgetClassSelectionReceivedFieldCallback,
    WidgetClassSelectionReceivedFieldCallback,
    dynamic_WidgetClassSelectionReceivedFieldCallback,
    genClosure_WidgetClassSelectionReceivedFieldCallback,
    mk_WidgetClassSelectionReceivedFieldCallback,
    noWidgetClassSelectionReceivedFieldCallback,
    wrap_WidgetClassSelectionReceivedFieldCallback,


-- ** WidgetClassSelectionRequestEventFieldCallback #signal:WidgetClassSelectionRequestEventFieldCallback#

    C_WidgetClassSelectionRequestEventFieldCallback,
    WidgetClassSelectionRequestEventFieldCallback,
    dynamic_WidgetClassSelectionRequestEventFieldCallback,
    genClosure_WidgetClassSelectionRequestEventFieldCallback,
    mk_WidgetClassSelectionRequestEventFieldCallback,
    noWidgetClassSelectionRequestEventFieldCallback,
    wrap_WidgetClassSelectionRequestEventFieldCallback,


-- ** WidgetClassShowAllFieldCallback #signal:WidgetClassShowAllFieldCallback#

    C_WidgetClassShowAllFieldCallback       ,
    WidgetClassShowAllFieldCallback         ,
    dynamic_WidgetClassShowAllFieldCallback ,
    genClosure_WidgetClassShowAllFieldCallback,
    mk_WidgetClassShowAllFieldCallback      ,
    noWidgetClassShowAllFieldCallback       ,
    wrap_WidgetClassShowAllFieldCallback    ,


-- ** WidgetClassShowFieldCallback #signal:WidgetClassShowFieldCallback#

    C_WidgetClassShowFieldCallback          ,
    WidgetClassShowFieldCallback            ,
    dynamic_WidgetClassShowFieldCallback    ,
    genClosure_WidgetClassShowFieldCallback ,
    mk_WidgetClassShowFieldCallback         ,
    noWidgetClassShowFieldCallback          ,
    wrap_WidgetClassShowFieldCallback       ,


-- ** WidgetClassShowHelpFieldCallback #signal:WidgetClassShowHelpFieldCallback#

    C_WidgetClassShowHelpFieldCallback      ,
    WidgetClassShowHelpFieldCallback        ,
    dynamic_WidgetClassShowHelpFieldCallback,
    genClosure_WidgetClassShowHelpFieldCallback,
    mk_WidgetClassShowHelpFieldCallback     ,
    noWidgetClassShowHelpFieldCallback      ,
    wrap_WidgetClassShowHelpFieldCallback   ,


-- ** WidgetClassSizeAllocateFieldCallback #signal:WidgetClassSizeAllocateFieldCallback#

    C_WidgetClassSizeAllocateFieldCallback  ,
    WidgetClassSizeAllocateFieldCallback    ,
    dynamic_WidgetClassSizeAllocateFieldCallback,
    genClosure_WidgetClassSizeAllocateFieldCallback,
    mk_WidgetClassSizeAllocateFieldCallback ,
    noWidgetClassSizeAllocateFieldCallback  ,
    wrap_WidgetClassSizeAllocateFieldCallback,


-- ** WidgetClassStateChangedFieldCallback #signal:WidgetClassStateChangedFieldCallback#

    C_WidgetClassStateChangedFieldCallback  ,
    WidgetClassStateChangedFieldCallback    ,
    dynamic_WidgetClassStateChangedFieldCallback,
    genClosure_WidgetClassStateChangedFieldCallback,
    mk_WidgetClassStateChangedFieldCallback ,
    noWidgetClassStateChangedFieldCallback  ,
    wrap_WidgetClassStateChangedFieldCallback,


-- ** WidgetClassStateFlagsChangedFieldCallback #signal:WidgetClassStateFlagsChangedFieldCallback#

    C_WidgetClassStateFlagsChangedFieldCallback,
    WidgetClassStateFlagsChangedFieldCallback,
    dynamic_WidgetClassStateFlagsChangedFieldCallback,
    genClosure_WidgetClassStateFlagsChangedFieldCallback,
    mk_WidgetClassStateFlagsChangedFieldCallback,
    noWidgetClassStateFlagsChangedFieldCallback,
    wrap_WidgetClassStateFlagsChangedFieldCallback,


-- ** WidgetClassStyleSetFieldCallback #signal:WidgetClassStyleSetFieldCallback#

    C_WidgetClassStyleSetFieldCallback      ,
    WidgetClassStyleSetFieldCallback        ,
    dynamic_WidgetClassStyleSetFieldCallback,
    genClosure_WidgetClassStyleSetFieldCallback,
    mk_WidgetClassStyleSetFieldCallback     ,
    noWidgetClassStyleSetFieldCallback      ,
    wrap_WidgetClassStyleSetFieldCallback   ,


-- ** WidgetClassStyleUpdatedFieldCallback #signal:WidgetClassStyleUpdatedFieldCallback#

    C_WidgetClassStyleUpdatedFieldCallback  ,
    WidgetClassStyleUpdatedFieldCallback    ,
    dynamic_WidgetClassStyleUpdatedFieldCallback,
    genClosure_WidgetClassStyleUpdatedFieldCallback,
    mk_WidgetClassStyleUpdatedFieldCallback ,
    noWidgetClassStyleUpdatedFieldCallback  ,
    wrap_WidgetClassStyleUpdatedFieldCallback,


-- ** WidgetClassTouchEventFieldCallback #signal:WidgetClassTouchEventFieldCallback#

    C_WidgetClassTouchEventFieldCallback    ,
    WidgetClassTouchEventFieldCallback      ,
    dynamic_WidgetClassTouchEventFieldCallback,
    genClosure_WidgetClassTouchEventFieldCallback,
    mk_WidgetClassTouchEventFieldCallback   ,
    noWidgetClassTouchEventFieldCallback    ,
    wrap_WidgetClassTouchEventFieldCallback ,


-- ** WidgetClassUnmapEventFieldCallback #signal:WidgetClassUnmapEventFieldCallback#

    C_WidgetClassUnmapEventFieldCallback    ,
    WidgetClassUnmapEventFieldCallback      ,
    dynamic_WidgetClassUnmapEventFieldCallback,
    genClosure_WidgetClassUnmapEventFieldCallback,
    mk_WidgetClassUnmapEventFieldCallback   ,
    noWidgetClassUnmapEventFieldCallback    ,
    wrap_WidgetClassUnmapEventFieldCallback ,


-- ** WidgetClassUnmapFieldCallback #signal:WidgetClassUnmapFieldCallback#

    C_WidgetClassUnmapFieldCallback         ,
    WidgetClassUnmapFieldCallback           ,
    dynamic_WidgetClassUnmapFieldCallback   ,
    genClosure_WidgetClassUnmapFieldCallback,
    mk_WidgetClassUnmapFieldCallback        ,
    noWidgetClassUnmapFieldCallback         ,
    wrap_WidgetClassUnmapFieldCallback      ,


-- ** WidgetClassUnrealizeFieldCallback #signal:WidgetClassUnrealizeFieldCallback#

    C_WidgetClassUnrealizeFieldCallback     ,
    WidgetClassUnrealizeFieldCallback       ,
    dynamic_WidgetClassUnrealizeFieldCallback,
    genClosure_WidgetClassUnrealizeFieldCallback,
    mk_WidgetClassUnrealizeFieldCallback    ,
    noWidgetClassUnrealizeFieldCallback     ,
    wrap_WidgetClassUnrealizeFieldCallback  ,


-- ** WidgetClassVisibilityNotifyEventFieldCallback #signal:WidgetClassVisibilityNotifyEventFieldCallback#

    C_WidgetClassVisibilityNotifyEventFieldCallback,
    WidgetClassVisibilityNotifyEventFieldCallback,
    dynamic_WidgetClassVisibilityNotifyEventFieldCallback,
    genClosure_WidgetClassVisibilityNotifyEventFieldCallback,
    mk_WidgetClassVisibilityNotifyEventFieldCallback,
    noWidgetClassVisibilityNotifyEventFieldCallback,
    wrap_WidgetClassVisibilityNotifyEventFieldCallback,


-- ** WidgetClassWindowStateEventFieldCallback #signal:WidgetClassWindowStateEventFieldCallback#

    C_WidgetClassWindowStateEventFieldCallback,
    WidgetClassWindowStateEventFieldCallback,
    dynamic_WidgetClassWindowStateEventFieldCallback,
    genClosure_WidgetClassWindowStateEventFieldCallback,
    mk_WidgetClassWindowStateEventFieldCallback,
    noWidgetClassWindowStateEventFieldCallback,
    wrap_WidgetClassWindowStateEventFieldCallback,




    ) where

import Data.GI.Base.ShortPrelude
import qualified Data.GI.Base.ShortPrelude as SP
import qualified Data.GI.Base.Overloading as O
import qualified Prelude as P

import qualified Data.GI.Base.Attributes as GI.Attributes
import qualified Data.GI.Base.BasicTypes as B.Types
import qualified Data.GI.Base.ManagedPtr as B.ManagedPtr
import qualified Data.GI.Base.GArray as B.GArray
import qualified Data.GI.Base.GClosure as B.GClosure
import qualified Data.GI.Base.GError as B.GError
import qualified Data.GI.Base.GHashTable as B.GHT
import qualified Data.GI.Base.GVariant as B.GVariant
import qualified Data.GI.Base.GValue as B.GValue
import qualified Data.GI.Base.GParamSpec as B.GParamSpec
import qualified Data.GI.Base.CallStack as B.CallStack
import qualified Data.GI.Base.Properties as B.Properties
import qualified Data.GI.Base.Signals as B.Signals
import qualified Control.Monad.IO.Class as MIO
import qualified Data.Coerce as Coerce
import qualified Data.Text as T
import qualified Data.ByteString.Char8 as B
import qualified Data.Map as Map
import qualified Foreign.Ptr as FP
import qualified GHC.OverloadedLabels as OL
import qualified GHC.Records as R

import qualified GI.Atk.Objects.Object as Atk.Object
import qualified GI.Cairo.Structs.Context as Cairo.Context
import qualified GI.Cairo.Structs.Region as Cairo.Region
import qualified GI.GLib.Structs.String as GLib.String
import qualified GI.GObject.Flags as GObject.Flags
import qualified GI.GObject.Objects.Object as GObject.Object
import qualified GI.Gdk.Flags as Gdk.Flags
import qualified GI.Gdk.Objects.Display as Gdk.Display
import qualified GI.Gdk.Objects.DragContext as Gdk.DragContext
import qualified GI.Gdk.Objects.FrameClock as Gdk.FrameClock
import qualified GI.Gdk.Objects.Screen as Gdk.Screen
import qualified GI.Gdk.Structs.Atom as Gdk.Atom
import qualified GI.Gdk.Structs.Color as Gdk.Color
import qualified GI.Gdk.Structs.EventAny as Gdk.EventAny
import qualified GI.Gdk.Structs.EventButton as Gdk.EventButton
import qualified GI.Gdk.Structs.EventConfigure as Gdk.EventConfigure
import qualified GI.Gdk.Structs.EventCrossing as Gdk.EventCrossing
import qualified GI.Gdk.Structs.EventExpose as Gdk.EventExpose
import qualified GI.Gdk.Structs.EventFocus as Gdk.EventFocus
import qualified GI.Gdk.Structs.EventGrabBroken as Gdk.EventGrabBroken
import qualified GI.Gdk.Structs.EventKey as Gdk.EventKey
import qualified GI.Gdk.Structs.EventMotion as Gdk.EventMotion
import qualified GI.Gdk.Structs.EventProperty as Gdk.EventProperty
import qualified GI.Gdk.Structs.EventProximity as Gdk.EventProximity
import qualified GI.Gdk.Structs.EventScroll as Gdk.EventScroll
import qualified GI.Gdk.Structs.EventSelection as Gdk.EventSelection
import qualified GI.Gdk.Structs.EventTouch as Gdk.EventTouch
import qualified GI.Gdk.Structs.EventVisibility as Gdk.EventVisibility
import qualified GI.Gdk.Structs.EventWindowState as Gdk.EventWindowState
import qualified GI.Gdk.Structs.Rectangle as Gdk.Rectangle
import qualified GI.Gdk.Unions.Event as Gdk.Event
import qualified GI.GdkPixbuf.Objects.Pixbuf as GdkPixbuf.Pixbuf
import {-# SOURCE #-} qualified GI.Gtk.Enums as Gtk.Enums
import {-# SOURCE #-} qualified GI.Gtk.Flags as Gtk.Flags
import {-# SOURCE #-} qualified GI.Gtk.Interfaces.CellLayout as Gtk.CellLayout
import {-# SOURCE #-} qualified GI.Gtk.Interfaces.TreeModel as Gtk.TreeModel
import {-# SOURCE #-} qualified GI.Gtk.Objects.AccelGroup as Gtk.AccelGroup
import {-# SOURCE #-} qualified GI.Gtk.Objects.Builder as Gtk.Builder
import {-# SOURCE #-} qualified GI.Gtk.Objects.Calendar as Gtk.Calendar
import {-# SOURCE #-} qualified GI.Gtk.Objects.CellRenderer as Gtk.CellRenderer
import {-# SOURCE #-} qualified GI.Gtk.Objects.Clipboard as Gtk.Clipboard
import {-# SOURCE #-} qualified GI.Gtk.Objects.Container as Gtk.Container
import {-# SOURCE #-} qualified GI.Gtk.Objects.EntryCompletion as Gtk.EntryCompletion
import {-# SOURCE #-} qualified GI.Gtk.Objects.FlowBox as Gtk.FlowBox
import {-# SOURCE #-} qualified GI.Gtk.Objects.FlowBoxChild as Gtk.FlowBoxChild
import {-# SOURCE #-} qualified GI.Gtk.Objects.IconView as Gtk.IconView
import {-# SOURCE #-} qualified GI.Gtk.Objects.ListBox as Gtk.ListBox
import {-# SOURCE #-} qualified GI.Gtk.Objects.ListBoxRow as Gtk.ListBoxRow
import {-# SOURCE #-} qualified GI.Gtk.Objects.Menu as Gtk.Menu
import {-# SOURCE #-} qualified GI.Gtk.Objects.PageSetup as Gtk.PageSetup
import {-# SOURCE #-} qualified GI.Gtk.Objects.Style as Gtk.Style
import {-# SOURCE #-} qualified GI.Gtk.Objects.TextBuffer as Gtk.TextBuffer
import {-# SOURCE #-} qualified GI.Gtk.Objects.TextTag as Gtk.TextTag
import {-# SOURCE #-} qualified GI.Gtk.Objects.Tooltip as Gtk.Tooltip
import {-# SOURCE #-} qualified GI.Gtk.Objects.TreeSelection as Gtk.TreeSelection
import {-# SOURCE #-} qualified GI.Gtk.Objects.TreeView as Gtk.TreeView
import {-# SOURCE #-} qualified GI.Gtk.Objects.TreeViewColumn as Gtk.TreeViewColumn
import {-# SOURCE #-} qualified GI.Gtk.Objects.Widget as Gtk.Widget
import {-# SOURCE #-} qualified GI.Gtk.Structs.AccelKey as Gtk.AccelKey
import {-# SOURCE #-} qualified GI.Gtk.Structs.FileFilterInfo as Gtk.FileFilterInfo
import {-# SOURCE #-} qualified GI.Gtk.Structs.RecentFilterInfo as Gtk.RecentFilterInfo
import {-# SOURCE #-} qualified GI.Gtk.Structs.RecentInfo as Gtk.RecentInfo
import {-# SOURCE #-} qualified GI.Gtk.Structs.SelectionData as Gtk.SelectionData
import {-# SOURCE #-} qualified GI.Gtk.Structs.TextIter as Gtk.TextIter
import {-# SOURCE #-} qualified GI.Gtk.Structs.TreeIter as Gtk.TreeIter
import {-# SOURCE #-} qualified GI.Gtk.Structs.TreePath as Gtk.TreePath
import {-# SOURCE #-} qualified GI.Gtk.Structs.WidgetPath as Gtk.WidgetPath
import qualified GI.Pango.Objects.FontFace as Pango.FontFace
import qualified GI.Pango.Objects.FontFamily as Pango.FontFamily

-- callback WidgetClassWindowStateEventFieldCallback
{- Callable
  { returnType = Just (TBasicType TBoolean)
  , returnMayBeNull = False
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , args =
      [ Arg
          { argCName = "widget"
          , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "event"
          , argType =
              TInterface Name { namespace = "Gdk" , name = "EventWindowState" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_WidgetClassWindowStateEventFieldCallback =
    Ptr Gtk.Widget.Widget ->
    Ptr Gdk.EventWindowState.EventWindowState ->
    IO CInt

-- Args: [ Arg
--           { argCName = "widget"
--           , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "event"
--           , argType =
--               TInterface Name { namespace = "Gdk" , name = "EventWindowState" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Just (TBasicType TBoolean)
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_WidgetClassWindowStateEventFieldCallback :: FunPtr C_WidgetClassWindowStateEventFieldCallback -> C_WidgetClassWindowStateEventFieldCallback

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_WidgetClassWindowStateEventFieldCallback ::
    (B.CallStack.HasCallStack, MonadIO m, Gtk.Widget.IsWidget a) =>
    FunPtr C_WidgetClassWindowStateEventFieldCallback
    -> a
    -> Gdk.EventWindowState.EventWindowState
    -> m Bool
dynamic_WidgetClassWindowStateEventFieldCallback __funPtr widget event = liftIO $ do
    widget' <- unsafeManagedPtrCastPtr widget
    event' <- unsafeManagedPtrGetPtr event
    result <- (__dynamic_C_WidgetClassWindowStateEventFieldCallback __funPtr) widget' event'
    let result' = (/= 0) result
    touchManagedPtr widget
    touchManagedPtr event
    return result'

-- | Generate a function pointer callable from C code, from a `C_WidgetClassWindowStateEventFieldCallback`.
foreign import ccall "wrapper"
    mk_WidgetClassWindowStateEventFieldCallback :: C_WidgetClassWindowStateEventFieldCallback -> IO (FunPtr C_WidgetClassWindowStateEventFieldCallback)

-- | /No description available in the introspection data./
type WidgetClassWindowStateEventFieldCallback =
    Gtk.Widget.Widget
    -> Gdk.EventWindowState.EventWindowState
    -> IO Bool

-- | A convenience synonym for @`Nothing` :: `Maybe` `WidgetClassWindowStateEventFieldCallback`@.
noWidgetClassWindowStateEventFieldCallback :: Maybe WidgetClassWindowStateEventFieldCallback
noWidgetClassWindowStateEventFieldCallback = Nothing

-- | Wrap the callback into a `GClosure`.
genClosure_WidgetClassWindowStateEventFieldCallback :: MonadIO m => WidgetClassWindowStateEventFieldCallback -> m (GClosure C_WidgetClassWindowStateEventFieldCallback)
genClosure_WidgetClassWindowStateEventFieldCallback cb = liftIO $ do
    let cb' = wrap_WidgetClassWindowStateEventFieldCallback Nothing cb
    mk_WidgetClassWindowStateEventFieldCallback cb' >>= B.GClosure.newGClosure


-- | Wrap a `WidgetClassWindowStateEventFieldCallback` into a `C_WidgetClassWindowStateEventFieldCallback`.
wrap_WidgetClassWindowStateEventFieldCallback :: 
    Maybe (Ptr (FunPtr C_WidgetClassWindowStateEventFieldCallback)) ->
    WidgetClassWindowStateEventFieldCallback ->
    C_WidgetClassWindowStateEventFieldCallback
wrap_WidgetClassWindowStateEventFieldCallback gi'funptrptr gi'cb widget event = do
    widget' <- (newObject Gtk.Widget.Widget) widget
    event' <- (newPtr Gdk.EventWindowState.EventWindowState) event
    result <- gi'cb  widget' event'
    maybeReleaseFunPtr gi'funptrptr
    let result' = (fromIntegral . fromEnum) result
    return result'


-- callback WidgetClassVisibilityNotifyEventFieldCallback
{- Callable
  { returnType = Just (TBasicType TBoolean)
  , returnMayBeNull = False
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , args =
      [ Arg
          { argCName = "widget"
          , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "event"
          , argType =
              TInterface Name { namespace = "Gdk" , name = "EventVisibility" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_WidgetClassVisibilityNotifyEventFieldCallback =
    Ptr Gtk.Widget.Widget ->
    Ptr Gdk.EventVisibility.EventVisibility ->
    IO CInt

-- Args: [ Arg
--           { argCName = "widget"
--           , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "event"
--           , argType =
--               TInterface Name { namespace = "Gdk" , name = "EventVisibility" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Just (TBasicType TBoolean)
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_WidgetClassVisibilityNotifyEventFieldCallback :: FunPtr C_WidgetClassVisibilityNotifyEventFieldCallback -> C_WidgetClassVisibilityNotifyEventFieldCallback

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_WidgetClassVisibilityNotifyEventFieldCallback ::
    (B.CallStack.HasCallStack, MonadIO m, Gtk.Widget.IsWidget a) =>
    FunPtr C_WidgetClassVisibilityNotifyEventFieldCallback
    -> a
    -> Gdk.EventVisibility.EventVisibility
    -> m Bool
dynamic_WidgetClassVisibilityNotifyEventFieldCallback __funPtr widget event = liftIO $ do
    widget' <- unsafeManagedPtrCastPtr widget
    event' <- unsafeManagedPtrGetPtr event
    result <- (__dynamic_C_WidgetClassVisibilityNotifyEventFieldCallback __funPtr) widget' event'
    let result' = (/= 0) result
    touchManagedPtr widget
    touchManagedPtr event
    return result'

-- | Generate a function pointer callable from C code, from a `C_WidgetClassVisibilityNotifyEventFieldCallback`.
foreign import ccall "wrapper"
    mk_WidgetClassVisibilityNotifyEventFieldCallback :: C_WidgetClassVisibilityNotifyEventFieldCallback -> IO (FunPtr C_WidgetClassVisibilityNotifyEventFieldCallback)

-- | /No description available in the introspection data./
type WidgetClassVisibilityNotifyEventFieldCallback =
    Gtk.Widget.Widget
    -> Gdk.EventVisibility.EventVisibility
    -> IO Bool

-- | A convenience synonym for @`Nothing` :: `Maybe` `WidgetClassVisibilityNotifyEventFieldCallback`@.
noWidgetClassVisibilityNotifyEventFieldCallback :: Maybe WidgetClassVisibilityNotifyEventFieldCallback
noWidgetClassVisibilityNotifyEventFieldCallback = Nothing

-- | Wrap the callback into a `GClosure`.
genClosure_WidgetClassVisibilityNotifyEventFieldCallback :: MonadIO m => WidgetClassVisibilityNotifyEventFieldCallback -> m (GClosure C_WidgetClassVisibilityNotifyEventFieldCallback)
genClosure_WidgetClassVisibilityNotifyEventFieldCallback cb = liftIO $ do
    let cb' = wrap_WidgetClassVisibilityNotifyEventFieldCallback Nothing cb
    mk_WidgetClassVisibilityNotifyEventFieldCallback cb' >>= B.GClosure.newGClosure


-- | Wrap a `WidgetClassVisibilityNotifyEventFieldCallback` into a `C_WidgetClassVisibilityNotifyEventFieldCallback`.
wrap_WidgetClassVisibilityNotifyEventFieldCallback :: 
    Maybe (Ptr (FunPtr C_WidgetClassVisibilityNotifyEventFieldCallback)) ->
    WidgetClassVisibilityNotifyEventFieldCallback ->
    C_WidgetClassVisibilityNotifyEventFieldCallback
wrap_WidgetClassVisibilityNotifyEventFieldCallback gi'funptrptr gi'cb widget event = do
    widget' <- (newObject Gtk.Widget.Widget) widget
    event' <- (newPtr Gdk.EventVisibility.EventVisibility) event
    result <- gi'cb  widget' event'
    maybeReleaseFunPtr gi'funptrptr
    let result' = (fromIntegral . fromEnum) result
    return result'


-- callback WidgetClassUnrealizeFieldCallback
{- Callable
  { returnType = Nothing
  , returnMayBeNull = False
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , args =
      [ Arg
          { argCName = "widget"
          , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText = Just "a #GtkWidget" , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_WidgetClassUnrealizeFieldCallback =
    Ptr Gtk.Widget.Widget ->
    IO ()

-- Args: [ Arg
--           { argCName = "widget"
--           , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "a #GtkWidget" , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Nothing
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_WidgetClassUnrealizeFieldCallback :: FunPtr C_WidgetClassUnrealizeFieldCallback -> C_WidgetClassUnrealizeFieldCallback

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_WidgetClassUnrealizeFieldCallback ::
    (B.CallStack.HasCallStack, MonadIO m, Gtk.Widget.IsWidget a) =>
    FunPtr C_WidgetClassUnrealizeFieldCallback
    -> a
    -- ^ /@widget@/: a t'GI.Gtk.Objects.Widget.Widget'
    -> m ()
dynamic_WidgetClassUnrealizeFieldCallback __funPtr widget = liftIO $ do
    widget' <- unsafeManagedPtrCastPtr widget
    (__dynamic_C_WidgetClassUnrealizeFieldCallback __funPtr) widget'
    touchManagedPtr widget
    return ()

-- | Generate a function pointer callable from C code, from a `C_WidgetClassUnrealizeFieldCallback`.
foreign import ccall "wrapper"
    mk_WidgetClassUnrealizeFieldCallback :: C_WidgetClassUnrealizeFieldCallback -> IO (FunPtr C_WidgetClassUnrealizeFieldCallback)

-- | /No description available in the introspection data./
type WidgetClassUnrealizeFieldCallback =
    Gtk.Widget.Widget
    -- ^ /@widget@/: a t'GI.Gtk.Objects.Widget.Widget'
    -> IO ()

-- | A convenience synonym for @`Nothing` :: `Maybe` `WidgetClassUnrealizeFieldCallback`@.
noWidgetClassUnrealizeFieldCallback :: Maybe WidgetClassUnrealizeFieldCallback
noWidgetClassUnrealizeFieldCallback = Nothing

-- | Wrap the callback into a `GClosure`.
genClosure_WidgetClassUnrealizeFieldCallback :: MonadIO m => WidgetClassUnrealizeFieldCallback -> m (GClosure C_WidgetClassUnrealizeFieldCallback)
genClosure_WidgetClassUnrealizeFieldCallback cb = liftIO $ do
    let cb' = wrap_WidgetClassUnrealizeFieldCallback Nothing cb
    mk_WidgetClassUnrealizeFieldCallback cb' >>= B.GClosure.newGClosure


-- | Wrap a `WidgetClassUnrealizeFieldCallback` into a `C_WidgetClassUnrealizeFieldCallback`.
wrap_WidgetClassUnrealizeFieldCallback :: 
    Maybe (Ptr (FunPtr C_WidgetClassUnrealizeFieldCallback)) ->
    WidgetClassUnrealizeFieldCallback ->
    C_WidgetClassUnrealizeFieldCallback
wrap_WidgetClassUnrealizeFieldCallback gi'funptrptr gi'cb widget = do
    widget' <- (newObject Gtk.Widget.Widget) widget
    gi'cb  widget'
    maybeReleaseFunPtr gi'funptrptr


-- callback WidgetClassUnmapFieldCallback
{- Callable
  { returnType = Nothing
  , returnMayBeNull = False
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , args =
      [ Arg
          { argCName = "widget"
          , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText = Just "a #GtkWidget" , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_WidgetClassUnmapFieldCallback =
    Ptr Gtk.Widget.Widget ->
    IO ()

-- Args: [ Arg
--           { argCName = "widget"
--           , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "a #GtkWidget" , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Nothing
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_WidgetClassUnmapFieldCallback :: FunPtr C_WidgetClassUnmapFieldCallback -> C_WidgetClassUnmapFieldCallback

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_WidgetClassUnmapFieldCallback ::
    (B.CallStack.HasCallStack, MonadIO m, Gtk.Widget.IsWidget a) =>
    FunPtr C_WidgetClassUnmapFieldCallback
    -> a
    -- ^ /@widget@/: a t'GI.Gtk.Objects.Widget.Widget'
    -> m ()
dynamic_WidgetClassUnmapFieldCallback __funPtr widget = liftIO $ do
    widget' <- unsafeManagedPtrCastPtr widget
    (__dynamic_C_WidgetClassUnmapFieldCallback __funPtr) widget'
    touchManagedPtr widget
    return ()

-- | Generate a function pointer callable from C code, from a `C_WidgetClassUnmapFieldCallback`.
foreign import ccall "wrapper"
    mk_WidgetClassUnmapFieldCallback :: C_WidgetClassUnmapFieldCallback -> IO (FunPtr C_WidgetClassUnmapFieldCallback)

-- | /No description available in the introspection data./
type WidgetClassUnmapFieldCallback =
    Gtk.Widget.Widget
    -- ^ /@widget@/: a t'GI.Gtk.Objects.Widget.Widget'
    -> IO ()

-- | A convenience synonym for @`Nothing` :: `Maybe` `WidgetClassUnmapFieldCallback`@.
noWidgetClassUnmapFieldCallback :: Maybe WidgetClassUnmapFieldCallback
noWidgetClassUnmapFieldCallback = Nothing

-- | Wrap the callback into a `GClosure`.
genClosure_WidgetClassUnmapFieldCallback :: MonadIO m => WidgetClassUnmapFieldCallback -> m (GClosure C_WidgetClassUnmapFieldCallback)
genClosure_WidgetClassUnmapFieldCallback cb = liftIO $ do
    let cb' = wrap_WidgetClassUnmapFieldCallback Nothing cb
    mk_WidgetClassUnmapFieldCallback cb' >>= B.GClosure.newGClosure


-- | Wrap a `WidgetClassUnmapFieldCallback` into a `C_WidgetClassUnmapFieldCallback`.
wrap_WidgetClassUnmapFieldCallback :: 
    Maybe (Ptr (FunPtr C_WidgetClassUnmapFieldCallback)) ->
    WidgetClassUnmapFieldCallback ->
    C_WidgetClassUnmapFieldCallback
wrap_WidgetClassUnmapFieldCallback gi'funptrptr gi'cb widget = do
    widget' <- (newObject Gtk.Widget.Widget) widget
    gi'cb  widget'
    maybeReleaseFunPtr gi'funptrptr


-- callback WidgetClassUnmapEventFieldCallback
{- Callable
  { returnType = Just (TBasicType TBoolean)
  , returnMayBeNull = False
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , args =
      [ Arg
          { argCName = "widget"
          , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "event"
          , argType =
              TInterface Name { namespace = "Gdk" , name = "EventAny" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_WidgetClassUnmapEventFieldCallback =
    Ptr Gtk.Widget.Widget ->
    Ptr Gdk.EventAny.EventAny ->
    IO CInt

-- Args: [ Arg
--           { argCName = "widget"
--           , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "event"
--           , argType =
--               TInterface Name { namespace = "Gdk" , name = "EventAny" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Just (TBasicType TBoolean)
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_WidgetClassUnmapEventFieldCallback :: FunPtr C_WidgetClassUnmapEventFieldCallback -> C_WidgetClassUnmapEventFieldCallback

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_WidgetClassUnmapEventFieldCallback ::
    (B.CallStack.HasCallStack, MonadIO m, Gtk.Widget.IsWidget a) =>
    FunPtr C_WidgetClassUnmapEventFieldCallback
    -> a
    -> Gdk.EventAny.EventAny
    -> m Bool
dynamic_WidgetClassUnmapEventFieldCallback __funPtr widget event = liftIO $ do
    widget' <- unsafeManagedPtrCastPtr widget
    event' <- unsafeManagedPtrGetPtr event
    result <- (__dynamic_C_WidgetClassUnmapEventFieldCallback __funPtr) widget' event'
    let result' = (/= 0) result
    touchManagedPtr widget
    touchManagedPtr event
    return result'

-- | Generate a function pointer callable from C code, from a `C_WidgetClassUnmapEventFieldCallback`.
foreign import ccall "wrapper"
    mk_WidgetClassUnmapEventFieldCallback :: C_WidgetClassUnmapEventFieldCallback -> IO (FunPtr C_WidgetClassUnmapEventFieldCallback)

-- | /No description available in the introspection data./
type WidgetClassUnmapEventFieldCallback =
    Gtk.Widget.Widget
    -> Gdk.EventAny.EventAny
    -> IO Bool

-- | A convenience synonym for @`Nothing` :: `Maybe` `WidgetClassUnmapEventFieldCallback`@.
noWidgetClassUnmapEventFieldCallback :: Maybe WidgetClassUnmapEventFieldCallback
noWidgetClassUnmapEventFieldCallback = Nothing

-- | Wrap the callback into a `GClosure`.
genClosure_WidgetClassUnmapEventFieldCallback :: MonadIO m => WidgetClassUnmapEventFieldCallback -> m (GClosure C_WidgetClassUnmapEventFieldCallback)
genClosure_WidgetClassUnmapEventFieldCallback cb = liftIO $ do
    let cb' = wrap_WidgetClassUnmapEventFieldCallback Nothing cb
    mk_WidgetClassUnmapEventFieldCallback cb' >>= B.GClosure.newGClosure


-- | Wrap a `WidgetClassUnmapEventFieldCallback` into a `C_WidgetClassUnmapEventFieldCallback`.
wrap_WidgetClassUnmapEventFieldCallback :: 
    Maybe (Ptr (FunPtr C_WidgetClassUnmapEventFieldCallback)) ->
    WidgetClassUnmapEventFieldCallback ->
    C_WidgetClassUnmapEventFieldCallback
wrap_WidgetClassUnmapEventFieldCallback gi'funptrptr gi'cb widget event = do
    widget' <- (newObject Gtk.Widget.Widget) widget
    event' <- (newPtr Gdk.EventAny.EventAny) event
    result <- gi'cb  widget' event'
    maybeReleaseFunPtr gi'funptrptr
    let result' = (fromIntegral . fromEnum) result
    return result'


-- callback WidgetClassTouchEventFieldCallback
{- Callable
  { returnType = Just (TBasicType TBoolean)
  , returnMayBeNull = False
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , args =
      [ Arg
          { argCName = "widget"
          , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "event"
          , argType =
              TInterface Name { namespace = "Gdk" , name = "EventTouch" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_WidgetClassTouchEventFieldCallback =
    Ptr Gtk.Widget.Widget ->
    Ptr Gdk.EventTouch.EventTouch ->
    IO CInt

-- Args: [ Arg
--           { argCName = "widget"
--           , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "event"
--           , argType =
--               TInterface Name { namespace = "Gdk" , name = "EventTouch" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Just (TBasicType TBoolean)
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_WidgetClassTouchEventFieldCallback :: FunPtr C_WidgetClassTouchEventFieldCallback -> C_WidgetClassTouchEventFieldCallback

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_WidgetClassTouchEventFieldCallback ::
    (B.CallStack.HasCallStack, MonadIO m, Gtk.Widget.IsWidget a) =>
    FunPtr C_WidgetClassTouchEventFieldCallback
    -> a
    -> Gdk.EventTouch.EventTouch
    -> m Bool
dynamic_WidgetClassTouchEventFieldCallback __funPtr widget event = liftIO $ do
    widget' <- unsafeManagedPtrCastPtr widget
    event' <- unsafeManagedPtrGetPtr event
    result <- (__dynamic_C_WidgetClassTouchEventFieldCallback __funPtr) widget' event'
    let result' = (/= 0) result
    touchManagedPtr widget
    touchManagedPtr event
    return result'

-- | Generate a function pointer callable from C code, from a `C_WidgetClassTouchEventFieldCallback`.
foreign import ccall "wrapper"
    mk_WidgetClassTouchEventFieldCallback :: C_WidgetClassTouchEventFieldCallback -> IO (FunPtr C_WidgetClassTouchEventFieldCallback)

-- | /No description available in the introspection data./
type WidgetClassTouchEventFieldCallback =
    Gtk.Widget.Widget
    -> Gdk.EventTouch.EventTouch
    -> IO Bool

-- | A convenience synonym for @`Nothing` :: `Maybe` `WidgetClassTouchEventFieldCallback`@.
noWidgetClassTouchEventFieldCallback :: Maybe WidgetClassTouchEventFieldCallback
noWidgetClassTouchEventFieldCallback = Nothing

-- | Wrap the callback into a `GClosure`.
genClosure_WidgetClassTouchEventFieldCallback :: MonadIO m => WidgetClassTouchEventFieldCallback -> m (GClosure C_WidgetClassTouchEventFieldCallback)
genClosure_WidgetClassTouchEventFieldCallback cb = liftIO $ do
    let cb' = wrap_WidgetClassTouchEventFieldCallback Nothing cb
    mk_WidgetClassTouchEventFieldCallback cb' >>= B.GClosure.newGClosure


-- | Wrap a `WidgetClassTouchEventFieldCallback` into a `C_WidgetClassTouchEventFieldCallback`.
wrap_WidgetClassTouchEventFieldCallback :: 
    Maybe (Ptr (FunPtr C_WidgetClassTouchEventFieldCallback)) ->
    WidgetClassTouchEventFieldCallback ->
    C_WidgetClassTouchEventFieldCallback
wrap_WidgetClassTouchEventFieldCallback gi'funptrptr gi'cb widget event = do
    widget' <- (newObject Gtk.Widget.Widget) widget
    event' <- (newPtr Gdk.EventTouch.EventTouch) event
    result <- gi'cb  widget' event'
    maybeReleaseFunPtr gi'funptrptr
    let result' = (fromIntegral . fromEnum) result
    return result'


-- callback WidgetClassStyleUpdatedFieldCallback
{- Callable
  { returnType = Nothing
  , returnMayBeNull = False
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , args =
      [ Arg
          { argCName = "widget"
          , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_WidgetClassStyleUpdatedFieldCallback =
    Ptr Gtk.Widget.Widget ->
    IO ()

-- Args: [ Arg
--           { argCName = "widget"
--           , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Nothing
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_WidgetClassStyleUpdatedFieldCallback :: FunPtr C_WidgetClassStyleUpdatedFieldCallback -> C_WidgetClassStyleUpdatedFieldCallback

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_WidgetClassStyleUpdatedFieldCallback ::
    (B.CallStack.HasCallStack, MonadIO m, Gtk.Widget.IsWidget a) =>
    FunPtr C_WidgetClassStyleUpdatedFieldCallback
    -> a
    -> m ()
dynamic_WidgetClassStyleUpdatedFieldCallback __funPtr widget = liftIO $ do
    widget' <- unsafeManagedPtrCastPtr widget
    (__dynamic_C_WidgetClassStyleUpdatedFieldCallback __funPtr) widget'
    touchManagedPtr widget
    return ()

-- | Generate a function pointer callable from C code, from a `C_WidgetClassStyleUpdatedFieldCallback`.
foreign import ccall "wrapper"
    mk_WidgetClassStyleUpdatedFieldCallback :: C_WidgetClassStyleUpdatedFieldCallback -> IO (FunPtr C_WidgetClassStyleUpdatedFieldCallback)

-- | /No description available in the introspection data./
type WidgetClassStyleUpdatedFieldCallback =
    Gtk.Widget.Widget
    -> IO ()

-- | A convenience synonym for @`Nothing` :: `Maybe` `WidgetClassStyleUpdatedFieldCallback`@.
noWidgetClassStyleUpdatedFieldCallback :: Maybe WidgetClassStyleUpdatedFieldCallback
noWidgetClassStyleUpdatedFieldCallback = Nothing

-- | Wrap the callback into a `GClosure`.
genClosure_WidgetClassStyleUpdatedFieldCallback :: MonadIO m => WidgetClassStyleUpdatedFieldCallback -> m (GClosure C_WidgetClassStyleUpdatedFieldCallback)
genClosure_WidgetClassStyleUpdatedFieldCallback cb = liftIO $ do
    let cb' = wrap_WidgetClassStyleUpdatedFieldCallback Nothing cb
    mk_WidgetClassStyleUpdatedFieldCallback cb' >>= B.GClosure.newGClosure


-- | Wrap a `WidgetClassStyleUpdatedFieldCallback` into a `C_WidgetClassStyleUpdatedFieldCallback`.
wrap_WidgetClassStyleUpdatedFieldCallback :: 
    Maybe (Ptr (FunPtr C_WidgetClassStyleUpdatedFieldCallback)) ->
    WidgetClassStyleUpdatedFieldCallback ->
    C_WidgetClassStyleUpdatedFieldCallback
wrap_WidgetClassStyleUpdatedFieldCallback gi'funptrptr gi'cb widget = do
    widget' <- (newObject Gtk.Widget.Widget) widget
    gi'cb  widget'
    maybeReleaseFunPtr gi'funptrptr


-- callback WidgetClassStyleSetFieldCallback
{- Callable
  { returnType = Nothing
  , returnMayBeNull = False
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , args =
      [ Arg
          { argCName = "widget"
          , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "previous_style"
          , argType = TInterface Name { namespace = "Gtk" , name = "Style" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_WidgetClassStyleSetFieldCallback =
    Ptr Gtk.Widget.Widget ->
    Ptr Gtk.Style.Style ->
    IO ()

-- Args: [ Arg
--           { argCName = "widget"
--           , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "previous_style"
--           , argType = TInterface Name { namespace = "Gtk" , name = "Style" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Nothing
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_WidgetClassStyleSetFieldCallback :: FunPtr C_WidgetClassStyleSetFieldCallback -> C_WidgetClassStyleSetFieldCallback

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_WidgetClassStyleSetFieldCallback ::
    (B.CallStack.HasCallStack, MonadIO m, Gtk.Widget.IsWidget a, Gtk.Style.IsStyle b) =>
    FunPtr C_WidgetClassStyleSetFieldCallback
    -> a
    -> b
    -> m ()
dynamic_WidgetClassStyleSetFieldCallback __funPtr widget previousStyle = liftIO $ do
    widget' <- unsafeManagedPtrCastPtr widget
    previousStyle' <- unsafeManagedPtrCastPtr previousStyle
    (__dynamic_C_WidgetClassStyleSetFieldCallback __funPtr) widget' previousStyle'
    touchManagedPtr widget
    touchManagedPtr previousStyle
    return ()

-- | Generate a function pointer callable from C code, from a `C_WidgetClassStyleSetFieldCallback`.
foreign import ccall "wrapper"
    mk_WidgetClassStyleSetFieldCallback :: C_WidgetClassStyleSetFieldCallback -> IO (FunPtr C_WidgetClassStyleSetFieldCallback)

-- | /No description available in the introspection data./
type WidgetClassStyleSetFieldCallback =
    Gtk.Widget.Widget
    -> Gtk.Style.Style
    -> IO ()

-- | A convenience synonym for @`Nothing` :: `Maybe` `WidgetClassStyleSetFieldCallback`@.
noWidgetClassStyleSetFieldCallback :: Maybe WidgetClassStyleSetFieldCallback
noWidgetClassStyleSetFieldCallback = Nothing

-- | Wrap the callback into a `GClosure`.
genClosure_WidgetClassStyleSetFieldCallback :: MonadIO m => WidgetClassStyleSetFieldCallback -> m (GClosure C_WidgetClassStyleSetFieldCallback)
genClosure_WidgetClassStyleSetFieldCallback cb = liftIO $ do
    let cb' = wrap_WidgetClassStyleSetFieldCallback Nothing cb
    mk_WidgetClassStyleSetFieldCallback cb' >>= B.GClosure.newGClosure


-- | Wrap a `WidgetClassStyleSetFieldCallback` into a `C_WidgetClassStyleSetFieldCallback`.
wrap_WidgetClassStyleSetFieldCallback :: 
    Maybe (Ptr (FunPtr C_WidgetClassStyleSetFieldCallback)) ->
    WidgetClassStyleSetFieldCallback ->
    C_WidgetClassStyleSetFieldCallback
wrap_WidgetClassStyleSetFieldCallback gi'funptrptr gi'cb widget previousStyle = do
    widget' <- (newObject Gtk.Widget.Widget) widget
    previousStyle' <- (newObject Gtk.Style.Style) previousStyle
    gi'cb  widget' previousStyle'
    maybeReleaseFunPtr gi'funptrptr


-- callback WidgetClassStateFlagsChangedFieldCallback
{- Callable
  { returnType = Nothing
  , returnMayBeNull = False
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , args =
      [ Arg
          { argCName = "widget"
          , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "previous_state_flags"
          , argType =
              TInterface Name { namespace = "Gtk" , name = "StateFlags" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_WidgetClassStateFlagsChangedFieldCallback =
    Ptr Gtk.Widget.Widget ->
    CUInt ->
    IO ()

-- Args: [ Arg
--           { argCName = "widget"
--           , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "previous_state_flags"
--           , argType =
--               TInterface Name { namespace = "Gtk" , name = "StateFlags" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Nothing
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_WidgetClassStateFlagsChangedFieldCallback :: FunPtr C_WidgetClassStateFlagsChangedFieldCallback -> C_WidgetClassStateFlagsChangedFieldCallback

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_WidgetClassStateFlagsChangedFieldCallback ::
    (B.CallStack.HasCallStack, MonadIO m, Gtk.Widget.IsWidget a) =>
    FunPtr C_WidgetClassStateFlagsChangedFieldCallback
    -> a
    -> [Gtk.Flags.StateFlags]
    -> m ()
dynamic_WidgetClassStateFlagsChangedFieldCallback __funPtr widget previousStateFlags = liftIO $ do
    widget' <- unsafeManagedPtrCastPtr widget
    let previousStateFlags' = gflagsToWord previousStateFlags
    (__dynamic_C_WidgetClassStateFlagsChangedFieldCallback __funPtr) widget' previousStateFlags'
    touchManagedPtr widget
    return ()

-- | Generate a function pointer callable from C code, from a `C_WidgetClassStateFlagsChangedFieldCallback`.
foreign import ccall "wrapper"
    mk_WidgetClassStateFlagsChangedFieldCallback :: C_WidgetClassStateFlagsChangedFieldCallback -> IO (FunPtr C_WidgetClassStateFlagsChangedFieldCallback)

-- | /No description available in the introspection data./
type WidgetClassStateFlagsChangedFieldCallback =
    Gtk.Widget.Widget
    -> [Gtk.Flags.StateFlags]
    -> IO ()

-- | A convenience synonym for @`Nothing` :: `Maybe` `WidgetClassStateFlagsChangedFieldCallback`@.
noWidgetClassStateFlagsChangedFieldCallback :: Maybe WidgetClassStateFlagsChangedFieldCallback
noWidgetClassStateFlagsChangedFieldCallback = Nothing

-- | Wrap the callback into a `GClosure`.
genClosure_WidgetClassStateFlagsChangedFieldCallback :: MonadIO m => WidgetClassStateFlagsChangedFieldCallback -> m (GClosure C_WidgetClassStateFlagsChangedFieldCallback)
genClosure_WidgetClassStateFlagsChangedFieldCallback cb = liftIO $ do
    let cb' = wrap_WidgetClassStateFlagsChangedFieldCallback Nothing cb
    mk_WidgetClassStateFlagsChangedFieldCallback cb' >>= B.GClosure.newGClosure


-- | Wrap a `WidgetClassStateFlagsChangedFieldCallback` into a `C_WidgetClassStateFlagsChangedFieldCallback`.
wrap_WidgetClassStateFlagsChangedFieldCallback :: 
    Maybe (Ptr (FunPtr C_WidgetClassStateFlagsChangedFieldCallback)) ->
    WidgetClassStateFlagsChangedFieldCallback ->
    C_WidgetClassStateFlagsChangedFieldCallback
wrap_WidgetClassStateFlagsChangedFieldCallback gi'funptrptr gi'cb widget previousStateFlags = do
    widget' <- (newObject Gtk.Widget.Widget) widget
    let previousStateFlags' = wordToGFlags previousStateFlags
    gi'cb  widget' previousStateFlags'
    maybeReleaseFunPtr gi'funptrptr


-- callback WidgetClassStateChangedFieldCallback
{- Callable
  { returnType = Nothing
  , returnMayBeNull = False
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , args =
      [ Arg
          { argCName = "widget"
          , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "previous_state"
          , argType =
              TInterface Name { namespace = "Gtk" , name = "StateType" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_WidgetClassStateChangedFieldCallback =
    Ptr Gtk.Widget.Widget ->
    CUInt ->
    IO ()

-- Args: [ Arg
--           { argCName = "widget"
--           , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "previous_state"
--           , argType =
--               TInterface Name { namespace = "Gtk" , name = "StateType" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Nothing
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_WidgetClassStateChangedFieldCallback :: FunPtr C_WidgetClassStateChangedFieldCallback -> C_WidgetClassStateChangedFieldCallback

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_WidgetClassStateChangedFieldCallback ::
    (B.CallStack.HasCallStack, MonadIO m, Gtk.Widget.IsWidget a) =>
    FunPtr C_WidgetClassStateChangedFieldCallback
    -> a
    -> Gtk.Enums.StateType
    -> m ()
dynamic_WidgetClassStateChangedFieldCallback __funPtr widget previousState = liftIO $ do
    widget' <- unsafeManagedPtrCastPtr widget
    let previousState' = (fromIntegral . fromEnum) previousState
    (__dynamic_C_WidgetClassStateChangedFieldCallback __funPtr) widget' previousState'
    touchManagedPtr widget
    return ()

-- | Generate a function pointer callable from C code, from a `C_WidgetClassStateChangedFieldCallback`.
foreign import ccall "wrapper"
    mk_WidgetClassStateChangedFieldCallback :: C_WidgetClassStateChangedFieldCallback -> IO (FunPtr C_WidgetClassStateChangedFieldCallback)

-- | /No description available in the introspection data./
type WidgetClassStateChangedFieldCallback =
    Gtk.Widget.Widget
    -> Gtk.Enums.StateType
    -> IO ()

-- | A convenience synonym for @`Nothing` :: `Maybe` `WidgetClassStateChangedFieldCallback`@.
noWidgetClassStateChangedFieldCallback :: Maybe WidgetClassStateChangedFieldCallback
noWidgetClassStateChangedFieldCallback = Nothing

-- | Wrap the callback into a `GClosure`.
genClosure_WidgetClassStateChangedFieldCallback :: MonadIO m => WidgetClassStateChangedFieldCallback -> m (GClosure C_WidgetClassStateChangedFieldCallback)
genClosure_WidgetClassStateChangedFieldCallback cb = liftIO $ do
    let cb' = wrap_WidgetClassStateChangedFieldCallback Nothing cb
    mk_WidgetClassStateChangedFieldCallback cb' >>= B.GClosure.newGClosure


-- | Wrap a `WidgetClassStateChangedFieldCallback` into a `C_WidgetClassStateChangedFieldCallback`.
wrap_WidgetClassStateChangedFieldCallback :: 
    Maybe (Ptr (FunPtr C_WidgetClassStateChangedFieldCallback)) ->
    WidgetClassStateChangedFieldCallback ->
    C_WidgetClassStateChangedFieldCallback
wrap_WidgetClassStateChangedFieldCallback gi'funptrptr gi'cb widget previousState = do
    widget' <- (newObject Gtk.Widget.Widget) widget
    let previousState' = (toEnum . fromIntegral) previousState
    gi'cb  widget' previousState'
    maybeReleaseFunPtr gi'funptrptr


-- callback WidgetClassSizeAllocateFieldCallback
{- Callable
  { returnType = Nothing
  , returnMayBeNull = False
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , args =
      [ Arg
          { argCName = "widget"
          , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText = Just "a #GtkWidget" , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "allocation"
          , argType =
              TInterface Name { namespace = "Gdk" , name = "Rectangle" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText = Just "position and size to be allocated to @widget"
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_WidgetClassSizeAllocateFieldCallback =
    Ptr Gtk.Widget.Widget ->
    Ptr Gdk.Rectangle.Rectangle ->
    IO ()

-- Args: [ Arg
--           { argCName = "widget"
--           , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "a #GtkWidget" , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "allocation"
--           , argType =
--               TInterface Name { namespace = "Gdk" , name = "Rectangle" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "position and size to be allocated to @widget"
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Nothing
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_WidgetClassSizeAllocateFieldCallback :: FunPtr C_WidgetClassSizeAllocateFieldCallback -> C_WidgetClassSizeAllocateFieldCallback

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_WidgetClassSizeAllocateFieldCallback ::
    (B.CallStack.HasCallStack, MonadIO m, Gtk.Widget.IsWidget a) =>
    FunPtr C_WidgetClassSizeAllocateFieldCallback
    -> a
    -- ^ /@widget@/: a t'GI.Gtk.Objects.Widget.Widget'
    -> Gdk.Rectangle.Rectangle
    -- ^ /@allocation@/: position and size to be allocated to /@widget@/
    -> m ()
dynamic_WidgetClassSizeAllocateFieldCallback __funPtr widget allocation = liftIO $ do
    widget' <- unsafeManagedPtrCastPtr widget
    allocation' <- unsafeManagedPtrGetPtr allocation
    (__dynamic_C_WidgetClassSizeAllocateFieldCallback __funPtr) widget' allocation'
    touchManagedPtr widget
    touchManagedPtr allocation
    return ()

-- | Generate a function pointer callable from C code, from a `C_WidgetClassSizeAllocateFieldCallback`.
foreign import ccall "wrapper"
    mk_WidgetClassSizeAllocateFieldCallback :: C_WidgetClassSizeAllocateFieldCallback -> IO (FunPtr C_WidgetClassSizeAllocateFieldCallback)

-- | /No description available in the introspection data./
type WidgetClassSizeAllocateFieldCallback =
    Gtk.Widget.Widget
    -- ^ /@widget@/: a t'GI.Gtk.Objects.Widget.Widget'
    -> Gdk.Rectangle.Rectangle
    -- ^ /@allocation@/: position and size to be allocated to /@widget@/
    -> IO ()

-- | A convenience synonym for @`Nothing` :: `Maybe` `WidgetClassSizeAllocateFieldCallback`@.
noWidgetClassSizeAllocateFieldCallback :: Maybe WidgetClassSizeAllocateFieldCallback
noWidgetClassSizeAllocateFieldCallback = Nothing

-- | Wrap the callback into a `GClosure`.
genClosure_WidgetClassSizeAllocateFieldCallback :: MonadIO m => WidgetClassSizeAllocateFieldCallback -> m (GClosure C_WidgetClassSizeAllocateFieldCallback)
genClosure_WidgetClassSizeAllocateFieldCallback cb = liftIO $ do
    let cb' = wrap_WidgetClassSizeAllocateFieldCallback Nothing cb
    mk_WidgetClassSizeAllocateFieldCallback cb' >>= B.GClosure.newGClosure


-- | Wrap a `WidgetClassSizeAllocateFieldCallback` into a `C_WidgetClassSizeAllocateFieldCallback`.
wrap_WidgetClassSizeAllocateFieldCallback :: 
    Maybe (Ptr (FunPtr C_WidgetClassSizeAllocateFieldCallback)) ->
    WidgetClassSizeAllocateFieldCallback ->
    C_WidgetClassSizeAllocateFieldCallback
wrap_WidgetClassSizeAllocateFieldCallback gi'funptrptr gi'cb widget allocation = do
    widget' <- (newObject Gtk.Widget.Widget) widget
    B.ManagedPtr.withTransient  allocation $ \allocation' -> do
        gi'cb  widget' allocation'
        maybeReleaseFunPtr gi'funptrptr


-- callback WidgetClassShowHelpFieldCallback
{- Callable
  { returnType = Just (TBasicType TBoolean)
  , returnMayBeNull = False
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , args =
      [ Arg
          { argCName = "widget"
          , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "help_type"
          , argType =
              TInterface Name { namespace = "Gtk" , name = "WidgetHelpType" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_WidgetClassShowHelpFieldCallback =
    Ptr Gtk.Widget.Widget ->
    CUInt ->
    IO CInt

-- Args: [ Arg
--           { argCName = "widget"
--           , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "help_type"
--           , argType =
--               TInterface Name { namespace = "Gtk" , name = "WidgetHelpType" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Just (TBasicType TBoolean)
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_WidgetClassShowHelpFieldCallback :: FunPtr C_WidgetClassShowHelpFieldCallback -> C_WidgetClassShowHelpFieldCallback

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_WidgetClassShowHelpFieldCallback ::
    (B.CallStack.HasCallStack, MonadIO m, Gtk.Widget.IsWidget a) =>
    FunPtr C_WidgetClassShowHelpFieldCallback
    -> a
    -> Gtk.Enums.WidgetHelpType
    -> m Bool
dynamic_WidgetClassShowHelpFieldCallback __funPtr widget helpType = liftIO $ do
    widget' <- unsafeManagedPtrCastPtr widget
    let helpType' = (fromIntegral . fromEnum) helpType
    result <- (__dynamic_C_WidgetClassShowHelpFieldCallback __funPtr) widget' helpType'
    let result' = (/= 0) result
    touchManagedPtr widget
    return result'

-- | Generate a function pointer callable from C code, from a `C_WidgetClassShowHelpFieldCallback`.
foreign import ccall "wrapper"
    mk_WidgetClassShowHelpFieldCallback :: C_WidgetClassShowHelpFieldCallback -> IO (FunPtr C_WidgetClassShowHelpFieldCallback)

-- | /No description available in the introspection data./
type WidgetClassShowHelpFieldCallback =
    Gtk.Widget.Widget
    -> Gtk.Enums.WidgetHelpType
    -> IO Bool

-- | A convenience synonym for @`Nothing` :: `Maybe` `WidgetClassShowHelpFieldCallback`@.
noWidgetClassShowHelpFieldCallback :: Maybe WidgetClassShowHelpFieldCallback
noWidgetClassShowHelpFieldCallback = Nothing

-- | Wrap the callback into a `GClosure`.
genClosure_WidgetClassShowHelpFieldCallback :: MonadIO m => WidgetClassShowHelpFieldCallback -> m (GClosure C_WidgetClassShowHelpFieldCallback)
genClosure_WidgetClassShowHelpFieldCallback cb = liftIO $ do
    let cb' = wrap_WidgetClassShowHelpFieldCallback Nothing cb
    mk_WidgetClassShowHelpFieldCallback cb' >>= B.GClosure.newGClosure


-- | Wrap a `WidgetClassShowHelpFieldCallback` into a `C_WidgetClassShowHelpFieldCallback`.
wrap_WidgetClassShowHelpFieldCallback :: 
    Maybe (Ptr (FunPtr C_WidgetClassShowHelpFieldCallback)) ->
    WidgetClassShowHelpFieldCallback ->
    C_WidgetClassShowHelpFieldCallback
wrap_WidgetClassShowHelpFieldCallback gi'funptrptr gi'cb widget helpType = do
    widget' <- (newObject Gtk.Widget.Widget) widget
    let helpType' = (toEnum . fromIntegral) helpType
    result <- gi'cb  widget' helpType'
    maybeReleaseFunPtr gi'funptrptr
    let result' = (fromIntegral . fromEnum) result
    return result'


-- callback WidgetClassShowFieldCallback
{- Callable
  { returnType = Nothing
  , returnMayBeNull = False
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , args =
      [ Arg
          { argCName = "widget"
          , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText = Just "a #GtkWidget" , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_WidgetClassShowFieldCallback =
    Ptr Gtk.Widget.Widget ->
    IO ()

-- Args: [ Arg
--           { argCName = "widget"
--           , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "a #GtkWidget" , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Nothing
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_WidgetClassShowFieldCallback :: FunPtr C_WidgetClassShowFieldCallback -> C_WidgetClassShowFieldCallback

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_WidgetClassShowFieldCallback ::
    (B.CallStack.HasCallStack, MonadIO m, Gtk.Widget.IsWidget a) =>
    FunPtr C_WidgetClassShowFieldCallback
    -> a
    -- ^ /@widget@/: a t'GI.Gtk.Objects.Widget.Widget'
    -> m ()
dynamic_WidgetClassShowFieldCallback __funPtr widget = liftIO $ do
    widget' <- unsafeManagedPtrCastPtr widget
    (__dynamic_C_WidgetClassShowFieldCallback __funPtr) widget'
    touchManagedPtr widget
    return ()

-- | Generate a function pointer callable from C code, from a `C_WidgetClassShowFieldCallback`.
foreign import ccall "wrapper"
    mk_WidgetClassShowFieldCallback :: C_WidgetClassShowFieldCallback -> IO (FunPtr C_WidgetClassShowFieldCallback)

-- | /No description available in the introspection data./
type WidgetClassShowFieldCallback =
    Gtk.Widget.Widget
    -- ^ /@widget@/: a t'GI.Gtk.Objects.Widget.Widget'
    -> IO ()

-- | A convenience synonym for @`Nothing` :: `Maybe` `WidgetClassShowFieldCallback`@.
noWidgetClassShowFieldCallback :: Maybe WidgetClassShowFieldCallback
noWidgetClassShowFieldCallback = Nothing

-- | Wrap the callback into a `GClosure`.
genClosure_WidgetClassShowFieldCallback :: MonadIO m => WidgetClassShowFieldCallback -> m (GClosure C_WidgetClassShowFieldCallback)
genClosure_WidgetClassShowFieldCallback cb = liftIO $ do
    let cb' = wrap_WidgetClassShowFieldCallback Nothing cb
    mk_WidgetClassShowFieldCallback cb' >>= B.GClosure.newGClosure


-- | Wrap a `WidgetClassShowFieldCallback` into a `C_WidgetClassShowFieldCallback`.
wrap_WidgetClassShowFieldCallback :: 
    Maybe (Ptr (FunPtr C_WidgetClassShowFieldCallback)) ->
    WidgetClassShowFieldCallback ->
    C_WidgetClassShowFieldCallback
wrap_WidgetClassShowFieldCallback gi'funptrptr gi'cb widget = do
    widget' <- (newObject Gtk.Widget.Widget) widget
    gi'cb  widget'
    maybeReleaseFunPtr gi'funptrptr


-- callback WidgetClassShowAllFieldCallback
{- Callable
  { returnType = Nothing
  , returnMayBeNull = False
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , args =
      [ Arg
          { argCName = "widget"
          , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText = Just "a #GtkWidget" , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_WidgetClassShowAllFieldCallback =
    Ptr Gtk.Widget.Widget ->
    IO ()

-- Args: [ Arg
--           { argCName = "widget"
--           , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "a #GtkWidget" , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Nothing
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_WidgetClassShowAllFieldCallback :: FunPtr C_WidgetClassShowAllFieldCallback -> C_WidgetClassShowAllFieldCallback

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_WidgetClassShowAllFieldCallback ::
    (B.CallStack.HasCallStack, MonadIO m, Gtk.Widget.IsWidget a) =>
    FunPtr C_WidgetClassShowAllFieldCallback
    -> a
    -- ^ /@widget@/: a t'GI.Gtk.Objects.Widget.Widget'
    -> m ()
dynamic_WidgetClassShowAllFieldCallback __funPtr widget = liftIO $ do
    widget' <- unsafeManagedPtrCastPtr widget
    (__dynamic_C_WidgetClassShowAllFieldCallback __funPtr) widget'
    touchManagedPtr widget
    return ()

-- | Generate a function pointer callable from C code, from a `C_WidgetClassShowAllFieldCallback`.
foreign import ccall "wrapper"
    mk_WidgetClassShowAllFieldCallback :: C_WidgetClassShowAllFieldCallback -> IO (FunPtr C_WidgetClassShowAllFieldCallback)

-- | /No description available in the introspection data./
type WidgetClassShowAllFieldCallback =
    Gtk.Widget.Widget
    -- ^ /@widget@/: a t'GI.Gtk.Objects.Widget.Widget'
    -> IO ()

-- | A convenience synonym for @`Nothing` :: `Maybe` `WidgetClassShowAllFieldCallback`@.
noWidgetClassShowAllFieldCallback :: Maybe WidgetClassShowAllFieldCallback
noWidgetClassShowAllFieldCallback = Nothing

-- | Wrap the callback into a `GClosure`.
genClosure_WidgetClassShowAllFieldCallback :: MonadIO m => WidgetClassShowAllFieldCallback -> m (GClosure C_WidgetClassShowAllFieldCallback)
genClosure_WidgetClassShowAllFieldCallback cb = liftIO $ do
    let cb' = wrap_WidgetClassShowAllFieldCallback Nothing cb
    mk_WidgetClassShowAllFieldCallback cb' >>= B.GClosure.newGClosure


-- | Wrap a `WidgetClassShowAllFieldCallback` into a `C_WidgetClassShowAllFieldCallback`.
wrap_WidgetClassShowAllFieldCallback :: 
    Maybe (Ptr (FunPtr C_WidgetClassShowAllFieldCallback)) ->
    WidgetClassShowAllFieldCallback ->
    C_WidgetClassShowAllFieldCallback
wrap_WidgetClassShowAllFieldCallback gi'funptrptr gi'cb widget = do
    widget' <- (newObject Gtk.Widget.Widget) widget
    gi'cb  widget'
    maybeReleaseFunPtr gi'funptrptr


-- callback WidgetClassSelectionRequestEventFieldCallback
{- Callable
  { returnType = Just (TBasicType TBoolean)
  , returnMayBeNull = False
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , args =
      [ Arg
          { argCName = "widget"
          , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "event"
          , argType =
              TInterface Name { namespace = "Gdk" , name = "EventSelection" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_WidgetClassSelectionRequestEventFieldCallback =
    Ptr Gtk.Widget.Widget ->
    Ptr Gdk.EventSelection.EventSelection ->
    IO CInt

-- Args: [ Arg
--           { argCName = "widget"
--           , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "event"
--           , argType =
--               TInterface Name { namespace = "Gdk" , name = "EventSelection" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Just (TBasicType TBoolean)
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_WidgetClassSelectionRequestEventFieldCallback :: FunPtr C_WidgetClassSelectionRequestEventFieldCallback -> C_WidgetClassSelectionRequestEventFieldCallback

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_WidgetClassSelectionRequestEventFieldCallback ::
    (B.CallStack.HasCallStack, MonadIO m, Gtk.Widget.IsWidget a) =>
    FunPtr C_WidgetClassSelectionRequestEventFieldCallback
    -> a
    -> Gdk.EventSelection.EventSelection
    -> m Bool
dynamic_WidgetClassSelectionRequestEventFieldCallback __funPtr widget event = liftIO $ do
    widget' <- unsafeManagedPtrCastPtr widget
    event' <- unsafeManagedPtrGetPtr event
    result <- (__dynamic_C_WidgetClassSelectionRequestEventFieldCallback __funPtr) widget' event'
    let result' = (/= 0) result
    touchManagedPtr widget
    touchManagedPtr event
    return result'

-- | Generate a function pointer callable from C code, from a `C_WidgetClassSelectionRequestEventFieldCallback`.
foreign import ccall "wrapper"
    mk_WidgetClassSelectionRequestEventFieldCallback :: C_WidgetClassSelectionRequestEventFieldCallback -> IO (FunPtr C_WidgetClassSelectionRequestEventFieldCallback)

-- | /No description available in the introspection data./
type WidgetClassSelectionRequestEventFieldCallback =
    Gtk.Widget.Widget
    -> Gdk.EventSelection.EventSelection
    -> IO Bool

-- | A convenience synonym for @`Nothing` :: `Maybe` `WidgetClassSelectionRequestEventFieldCallback`@.
noWidgetClassSelectionRequestEventFieldCallback :: Maybe WidgetClassSelectionRequestEventFieldCallback
noWidgetClassSelectionRequestEventFieldCallback = Nothing

-- | Wrap the callback into a `GClosure`.
genClosure_WidgetClassSelectionRequestEventFieldCallback :: MonadIO m => WidgetClassSelectionRequestEventFieldCallback -> m (GClosure C_WidgetClassSelectionRequestEventFieldCallback)
genClosure_WidgetClassSelectionRequestEventFieldCallback cb = liftIO $ do
    let cb' = wrap_WidgetClassSelectionRequestEventFieldCallback Nothing cb
    mk_WidgetClassSelectionRequestEventFieldCallback cb' >>= B.GClosure.newGClosure


-- | Wrap a `WidgetClassSelectionRequestEventFieldCallback` into a `C_WidgetClassSelectionRequestEventFieldCallback`.
wrap_WidgetClassSelectionRequestEventFieldCallback :: 
    Maybe (Ptr (FunPtr C_WidgetClassSelectionRequestEventFieldCallback)) ->
    WidgetClassSelectionRequestEventFieldCallback ->
    C_WidgetClassSelectionRequestEventFieldCallback
wrap_WidgetClassSelectionRequestEventFieldCallback gi'funptrptr gi'cb widget event = do
    widget' <- (newObject Gtk.Widget.Widget) widget
    event' <- (newPtr Gdk.EventSelection.EventSelection) event
    result <- gi'cb  widget' event'
    maybeReleaseFunPtr gi'funptrptr
    let result' = (fromIntegral . fromEnum) result
    return result'


-- callback WidgetClassSelectionReceivedFieldCallback
{- Callable
  { returnType = Nothing
  , returnMayBeNull = False
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , args =
      [ Arg
          { argCName = "widget"
          , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "selection_data"
          , argType =
              TInterface Name { namespace = "Gtk" , name = "SelectionData" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "time_"
          , argType = TBasicType TUInt
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_WidgetClassSelectionReceivedFieldCallback =
    Ptr Gtk.Widget.Widget ->
    Ptr Gtk.SelectionData.SelectionData ->
    Word32 ->
    IO ()

-- Args: [ Arg
--           { argCName = "widget"
--           , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "selection_data"
--           , argType =
--               TInterface Name { namespace = "Gtk" , name = "SelectionData" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "time_"
--           , argType = TBasicType TUInt
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Nothing
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_WidgetClassSelectionReceivedFieldCallback :: FunPtr C_WidgetClassSelectionReceivedFieldCallback -> C_WidgetClassSelectionReceivedFieldCallback

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_WidgetClassSelectionReceivedFieldCallback ::
    (B.CallStack.HasCallStack, MonadIO m, Gtk.Widget.IsWidget a) =>
    FunPtr C_WidgetClassSelectionReceivedFieldCallback
    -> a
    -> Gtk.SelectionData.SelectionData
    -> Word32
    -> m ()
dynamic_WidgetClassSelectionReceivedFieldCallback __funPtr widget selectionData time_ = liftIO $ do
    widget' <- unsafeManagedPtrCastPtr widget
    selectionData' <- unsafeManagedPtrGetPtr selectionData
    (__dynamic_C_WidgetClassSelectionReceivedFieldCallback __funPtr) widget' selectionData' time_
    touchManagedPtr widget
    touchManagedPtr selectionData
    return ()

-- | Generate a function pointer callable from C code, from a `C_WidgetClassSelectionReceivedFieldCallback`.
foreign import ccall "wrapper"
    mk_WidgetClassSelectionReceivedFieldCallback :: C_WidgetClassSelectionReceivedFieldCallback -> IO (FunPtr C_WidgetClassSelectionReceivedFieldCallback)

-- | /No description available in the introspection data./
type WidgetClassSelectionReceivedFieldCallback =
    Gtk.Widget.Widget
    -> Gtk.SelectionData.SelectionData
    -> Word32
    -> IO ()

-- | A convenience synonym for @`Nothing` :: `Maybe` `WidgetClassSelectionReceivedFieldCallback`@.
noWidgetClassSelectionReceivedFieldCallback :: Maybe WidgetClassSelectionReceivedFieldCallback
noWidgetClassSelectionReceivedFieldCallback = Nothing

-- | Wrap the callback into a `GClosure`.
genClosure_WidgetClassSelectionReceivedFieldCallback :: MonadIO m => WidgetClassSelectionReceivedFieldCallback -> m (GClosure C_WidgetClassSelectionReceivedFieldCallback)
genClosure_WidgetClassSelectionReceivedFieldCallback cb = liftIO $ do
    let cb' = wrap_WidgetClassSelectionReceivedFieldCallback Nothing cb
    mk_WidgetClassSelectionReceivedFieldCallback cb' >>= B.GClosure.newGClosure


-- | Wrap a `WidgetClassSelectionReceivedFieldCallback` into a `C_WidgetClassSelectionReceivedFieldCallback`.
wrap_WidgetClassSelectionReceivedFieldCallback :: 
    Maybe (Ptr (FunPtr C_WidgetClassSelectionReceivedFieldCallback)) ->
    WidgetClassSelectionReceivedFieldCallback ->
    C_WidgetClassSelectionReceivedFieldCallback
wrap_WidgetClassSelectionReceivedFieldCallback gi'funptrptr gi'cb widget selectionData time_ = do
    widget' <- (newObject Gtk.Widget.Widget) widget
    B.ManagedPtr.withTransient  selectionData $ \selectionData' -> do
        gi'cb  widget' selectionData' time_
        maybeReleaseFunPtr gi'funptrptr


-- callback WidgetClassSelectionNotifyEventFieldCallback
{- Callable
  { returnType = Just (TBasicType TBoolean)
  , returnMayBeNull = False
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , args =
      [ Arg
          { argCName = "widget"
          , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "event"
          , argType =
              TInterface Name { namespace = "Gdk" , name = "EventSelection" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_WidgetClassSelectionNotifyEventFieldCallback =
    Ptr Gtk.Widget.Widget ->
    Ptr Gdk.EventSelection.EventSelection ->
    IO CInt

-- Args: [ Arg
--           { argCName = "widget"
--           , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "event"
--           , argType =
--               TInterface Name { namespace = "Gdk" , name = "EventSelection" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Just (TBasicType TBoolean)
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_WidgetClassSelectionNotifyEventFieldCallback :: FunPtr C_WidgetClassSelectionNotifyEventFieldCallback -> C_WidgetClassSelectionNotifyEventFieldCallback

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_WidgetClassSelectionNotifyEventFieldCallback ::
    (B.CallStack.HasCallStack, MonadIO m, Gtk.Widget.IsWidget a) =>
    FunPtr C_WidgetClassSelectionNotifyEventFieldCallback
    -> a
    -> Gdk.EventSelection.EventSelection
    -> m Bool
dynamic_WidgetClassSelectionNotifyEventFieldCallback __funPtr widget event = liftIO $ do
    widget' <- unsafeManagedPtrCastPtr widget
    event' <- unsafeManagedPtrGetPtr event
    result <- (__dynamic_C_WidgetClassSelectionNotifyEventFieldCallback __funPtr) widget' event'
    let result' = (/= 0) result
    touchManagedPtr widget
    touchManagedPtr event
    return result'

-- | Generate a function pointer callable from C code, from a `C_WidgetClassSelectionNotifyEventFieldCallback`.
foreign import ccall "wrapper"
    mk_WidgetClassSelectionNotifyEventFieldCallback :: C_WidgetClassSelectionNotifyEventFieldCallback -> IO (FunPtr C_WidgetClassSelectionNotifyEventFieldCallback)

-- | /No description available in the introspection data./
type WidgetClassSelectionNotifyEventFieldCallback =
    Gtk.Widget.Widget
    -> Gdk.EventSelection.EventSelection
    -> IO Bool

-- | A convenience synonym for @`Nothing` :: `Maybe` `WidgetClassSelectionNotifyEventFieldCallback`@.
noWidgetClassSelectionNotifyEventFieldCallback :: Maybe WidgetClassSelectionNotifyEventFieldCallback
noWidgetClassSelectionNotifyEventFieldCallback = Nothing

-- | Wrap the callback into a `GClosure`.
genClosure_WidgetClassSelectionNotifyEventFieldCallback :: MonadIO m => WidgetClassSelectionNotifyEventFieldCallback -> m (GClosure C_WidgetClassSelectionNotifyEventFieldCallback)
genClosure_WidgetClassSelectionNotifyEventFieldCallback cb = liftIO $ do
    let cb' = wrap_WidgetClassSelectionNotifyEventFieldCallback Nothing cb
    mk_WidgetClassSelectionNotifyEventFieldCallback cb' >>= B.GClosure.newGClosure


-- | Wrap a `WidgetClassSelectionNotifyEventFieldCallback` into a `C_WidgetClassSelectionNotifyEventFieldCallback`.
wrap_WidgetClassSelectionNotifyEventFieldCallback :: 
    Maybe (Ptr (FunPtr C_WidgetClassSelectionNotifyEventFieldCallback)) ->
    WidgetClassSelectionNotifyEventFieldCallback ->
    C_WidgetClassSelectionNotifyEventFieldCallback
wrap_WidgetClassSelectionNotifyEventFieldCallback gi'funptrptr gi'cb widget event = do
    widget' <- (newObject Gtk.Widget.Widget) widget
    event' <- (newPtr Gdk.EventSelection.EventSelection) event
    result <- gi'cb  widget' event'
    maybeReleaseFunPtr gi'funptrptr
    let result' = (fromIntegral . fromEnum) result
    return result'


-- callback WidgetClassSelectionGetFieldCallback
{- Callable
  { returnType = Nothing
  , returnMayBeNull = False
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , args =
      [ Arg
          { argCName = "widget"
          , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "selection_data"
          , argType =
              TInterface Name { namespace = "Gtk" , name = "SelectionData" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "info"
          , argType = TBasicType TUInt
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "time_"
          , argType = TBasicType TUInt
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_WidgetClassSelectionGetFieldCallback =
    Ptr Gtk.Widget.Widget ->
    Ptr Gtk.SelectionData.SelectionData ->
    Word32 ->
    Word32 ->
    IO ()

-- Args: [ Arg
--           { argCName = "widget"
--           , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "selection_data"
--           , argType =
--               TInterface Name { namespace = "Gtk" , name = "SelectionData" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "info"
--           , argType = TBasicType TUInt
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "time_"
--           , argType = TBasicType TUInt
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Nothing
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_WidgetClassSelectionGetFieldCallback :: FunPtr C_WidgetClassSelectionGetFieldCallback -> C_WidgetClassSelectionGetFieldCallback

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_WidgetClassSelectionGetFieldCallback ::
    (B.CallStack.HasCallStack, MonadIO m, Gtk.Widget.IsWidget a) =>
    FunPtr C_WidgetClassSelectionGetFieldCallback
    -> a
    -> Gtk.SelectionData.SelectionData
    -> Word32
    -> Word32
    -> m ()
dynamic_WidgetClassSelectionGetFieldCallback __funPtr widget selectionData info time_ = liftIO $ do
    widget' <- unsafeManagedPtrCastPtr widget
    selectionData' <- unsafeManagedPtrGetPtr selectionData
    (__dynamic_C_WidgetClassSelectionGetFieldCallback __funPtr) widget' selectionData' info time_
    touchManagedPtr widget
    touchManagedPtr selectionData
    return ()

-- | Generate a function pointer callable from C code, from a `C_WidgetClassSelectionGetFieldCallback`.
foreign import ccall "wrapper"
    mk_WidgetClassSelectionGetFieldCallback :: C_WidgetClassSelectionGetFieldCallback -> IO (FunPtr C_WidgetClassSelectionGetFieldCallback)

-- | /No description available in the introspection data./
type WidgetClassSelectionGetFieldCallback =
    Gtk.Widget.Widget
    -> Gtk.SelectionData.SelectionData
    -> Word32
    -> Word32
    -> IO ()

-- | A convenience synonym for @`Nothing` :: `Maybe` `WidgetClassSelectionGetFieldCallback`@.
noWidgetClassSelectionGetFieldCallback :: Maybe WidgetClassSelectionGetFieldCallback
noWidgetClassSelectionGetFieldCallback = Nothing

-- | Wrap the callback into a `GClosure`.
genClosure_WidgetClassSelectionGetFieldCallback :: MonadIO m => WidgetClassSelectionGetFieldCallback -> m (GClosure C_WidgetClassSelectionGetFieldCallback)
genClosure_WidgetClassSelectionGetFieldCallback cb = liftIO $ do
    let cb' = wrap_WidgetClassSelectionGetFieldCallback Nothing cb
    mk_WidgetClassSelectionGetFieldCallback cb' >>= B.GClosure.newGClosure


-- | Wrap a `WidgetClassSelectionGetFieldCallback` into a `C_WidgetClassSelectionGetFieldCallback`.
wrap_WidgetClassSelectionGetFieldCallback :: 
    Maybe (Ptr (FunPtr C_WidgetClassSelectionGetFieldCallback)) ->
    WidgetClassSelectionGetFieldCallback ->
    C_WidgetClassSelectionGetFieldCallback
wrap_WidgetClassSelectionGetFieldCallback gi'funptrptr gi'cb widget selectionData info time_ = do
    widget' <- (newObject Gtk.Widget.Widget) widget
    B.ManagedPtr.withTransient  selectionData $ \selectionData' -> do
        gi'cb  widget' selectionData' info time_
        maybeReleaseFunPtr gi'funptrptr


-- callback WidgetClassSelectionClearEventFieldCallback
{- Callable
  { returnType = Just (TBasicType TBoolean)
  , returnMayBeNull = False
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , args =
      [ Arg
          { argCName = "widget"
          , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "event"
          , argType =
              TInterface Name { namespace = "Gdk" , name = "EventSelection" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_WidgetClassSelectionClearEventFieldCallback =
    Ptr Gtk.Widget.Widget ->
    Ptr Gdk.EventSelection.EventSelection ->
    IO CInt

-- Args: [ Arg
--           { argCName = "widget"
--           , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "event"
--           , argType =
--               TInterface Name { namespace = "Gdk" , name = "EventSelection" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Just (TBasicType TBoolean)
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_WidgetClassSelectionClearEventFieldCallback :: FunPtr C_WidgetClassSelectionClearEventFieldCallback -> C_WidgetClassSelectionClearEventFieldCallback

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_WidgetClassSelectionClearEventFieldCallback ::
    (B.CallStack.HasCallStack, MonadIO m, Gtk.Widget.IsWidget a) =>
    FunPtr C_WidgetClassSelectionClearEventFieldCallback
    -> a
    -> Gdk.EventSelection.EventSelection
    -> m Bool
dynamic_WidgetClassSelectionClearEventFieldCallback __funPtr widget event = liftIO $ do
    widget' <- unsafeManagedPtrCastPtr widget
    event' <- unsafeManagedPtrGetPtr event
    result <- (__dynamic_C_WidgetClassSelectionClearEventFieldCallback __funPtr) widget' event'
    let result' = (/= 0) result
    touchManagedPtr widget
    touchManagedPtr event
    return result'

-- | Generate a function pointer callable from C code, from a `C_WidgetClassSelectionClearEventFieldCallback`.
foreign import ccall "wrapper"
    mk_WidgetClassSelectionClearEventFieldCallback :: C_WidgetClassSelectionClearEventFieldCallback -> IO (FunPtr C_WidgetClassSelectionClearEventFieldCallback)

-- | /No description available in the introspection data./
type WidgetClassSelectionClearEventFieldCallback =
    Gtk.Widget.Widget
    -> Gdk.EventSelection.EventSelection
    -> IO Bool

-- | A convenience synonym for @`Nothing` :: `Maybe` `WidgetClassSelectionClearEventFieldCallback`@.
noWidgetClassSelectionClearEventFieldCallback :: Maybe WidgetClassSelectionClearEventFieldCallback
noWidgetClassSelectionClearEventFieldCallback = Nothing

-- | Wrap the callback into a `GClosure`.
genClosure_WidgetClassSelectionClearEventFieldCallback :: MonadIO m => WidgetClassSelectionClearEventFieldCallback -> m (GClosure C_WidgetClassSelectionClearEventFieldCallback)
genClosure_WidgetClassSelectionClearEventFieldCallback cb = liftIO $ do
    let cb' = wrap_WidgetClassSelectionClearEventFieldCallback Nothing cb
    mk_WidgetClassSelectionClearEventFieldCallback cb' >>= B.GClosure.newGClosure


-- | Wrap a `WidgetClassSelectionClearEventFieldCallback` into a `C_WidgetClassSelectionClearEventFieldCallback`.
wrap_WidgetClassSelectionClearEventFieldCallback :: 
    Maybe (Ptr (FunPtr C_WidgetClassSelectionClearEventFieldCallback)) ->
    WidgetClassSelectionClearEventFieldCallback ->
    C_WidgetClassSelectionClearEventFieldCallback
wrap_WidgetClassSelectionClearEventFieldCallback gi'funptrptr gi'cb widget event = do
    widget' <- (newObject Gtk.Widget.Widget) widget
    event' <- (newPtr Gdk.EventSelection.EventSelection) event
    result <- gi'cb  widget' event'
    maybeReleaseFunPtr gi'funptrptr
    let result' = (fromIntegral . fromEnum) result
    return result'


-- callback WidgetClassScrollEventFieldCallback
{- Callable
  { returnType = Just (TBasicType TBoolean)
  , returnMayBeNull = False
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , args =
      [ Arg
          { argCName = "widget"
          , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "event"
          , argType =
              TInterface Name { namespace = "Gdk" , name = "EventScroll" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_WidgetClassScrollEventFieldCallback =
    Ptr Gtk.Widget.Widget ->
    Ptr Gdk.EventScroll.EventScroll ->
    IO CInt

-- Args: [ Arg
--           { argCName = "widget"
--           , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "event"
--           , argType =
--               TInterface Name { namespace = "Gdk" , name = "EventScroll" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Just (TBasicType TBoolean)
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_WidgetClassScrollEventFieldCallback :: FunPtr C_WidgetClassScrollEventFieldCallback -> C_WidgetClassScrollEventFieldCallback

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_WidgetClassScrollEventFieldCallback ::
    (B.CallStack.HasCallStack, MonadIO m, Gtk.Widget.IsWidget a) =>
    FunPtr C_WidgetClassScrollEventFieldCallback
    -> a
    -> Gdk.EventScroll.EventScroll
    -> m Bool
dynamic_WidgetClassScrollEventFieldCallback __funPtr widget event = liftIO $ do
    widget' <- unsafeManagedPtrCastPtr widget
    event' <- unsafeManagedPtrGetPtr event
    result <- (__dynamic_C_WidgetClassScrollEventFieldCallback __funPtr) widget' event'
    let result' = (/= 0) result
    touchManagedPtr widget
    touchManagedPtr event
    return result'

-- | Generate a function pointer callable from C code, from a `C_WidgetClassScrollEventFieldCallback`.
foreign import ccall "wrapper"
    mk_WidgetClassScrollEventFieldCallback :: C_WidgetClassScrollEventFieldCallback -> IO (FunPtr C_WidgetClassScrollEventFieldCallback)

-- | /No description available in the introspection data./
type WidgetClassScrollEventFieldCallback =
    Gtk.Widget.Widget
    -> Gdk.EventScroll.EventScroll
    -> IO Bool

-- | A convenience synonym for @`Nothing` :: `Maybe` `WidgetClassScrollEventFieldCallback`@.
noWidgetClassScrollEventFieldCallback :: Maybe WidgetClassScrollEventFieldCallback
noWidgetClassScrollEventFieldCallback = Nothing

-- | Wrap the callback into a `GClosure`.
genClosure_WidgetClassScrollEventFieldCallback :: MonadIO m => WidgetClassScrollEventFieldCallback -> m (GClosure C_WidgetClassScrollEventFieldCallback)
genClosure_WidgetClassScrollEventFieldCallback cb = liftIO $ do
    let cb' = wrap_WidgetClassScrollEventFieldCallback Nothing cb
    mk_WidgetClassScrollEventFieldCallback cb' >>= B.GClosure.newGClosure


-- | Wrap a `WidgetClassScrollEventFieldCallback` into a `C_WidgetClassScrollEventFieldCallback`.
wrap_WidgetClassScrollEventFieldCallback :: 
    Maybe (Ptr (FunPtr C_WidgetClassScrollEventFieldCallback)) ->
    WidgetClassScrollEventFieldCallback ->
    C_WidgetClassScrollEventFieldCallback
wrap_WidgetClassScrollEventFieldCallback gi'funptrptr gi'cb widget event = do
    widget' <- (newObject Gtk.Widget.Widget) widget
    event' <- (newPtr Gdk.EventScroll.EventScroll) event
    result <- gi'cb  widget' event'
    maybeReleaseFunPtr gi'funptrptr
    let result' = (fromIntegral . fromEnum) result
    return result'


-- callback WidgetClassScreenChangedFieldCallback
{- Callable
  { returnType = Nothing
  , returnMayBeNull = False
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , args =
      [ Arg
          { argCName = "widget"
          , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "previous_screen"
          , argType = TInterface Name { namespace = "Gdk" , name = "Screen" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_WidgetClassScreenChangedFieldCallback =
    Ptr Gtk.Widget.Widget ->
    Ptr Gdk.Screen.Screen ->
    IO ()

-- Args: [ Arg
--           { argCName = "widget"
--           , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "previous_screen"
--           , argType = TInterface Name { namespace = "Gdk" , name = "Screen" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Nothing
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_WidgetClassScreenChangedFieldCallback :: FunPtr C_WidgetClassScreenChangedFieldCallback -> C_WidgetClassScreenChangedFieldCallback

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_WidgetClassScreenChangedFieldCallback ::
    (B.CallStack.HasCallStack, MonadIO m, Gtk.Widget.IsWidget a, Gdk.Screen.IsScreen b) =>
    FunPtr C_WidgetClassScreenChangedFieldCallback
    -> a
    -> b
    -> m ()
dynamic_WidgetClassScreenChangedFieldCallback __funPtr widget previousScreen = liftIO $ do
    widget' <- unsafeManagedPtrCastPtr widget
    previousScreen' <- unsafeManagedPtrCastPtr previousScreen
    (__dynamic_C_WidgetClassScreenChangedFieldCallback __funPtr) widget' previousScreen'
    touchManagedPtr widget
    touchManagedPtr previousScreen
    return ()

-- | Generate a function pointer callable from C code, from a `C_WidgetClassScreenChangedFieldCallback`.
foreign import ccall "wrapper"
    mk_WidgetClassScreenChangedFieldCallback :: C_WidgetClassScreenChangedFieldCallback -> IO (FunPtr C_WidgetClassScreenChangedFieldCallback)

-- | /No description available in the introspection data./
type WidgetClassScreenChangedFieldCallback =
    Gtk.Widget.Widget
    -> Gdk.Screen.Screen
    -> IO ()

-- | A convenience synonym for @`Nothing` :: `Maybe` `WidgetClassScreenChangedFieldCallback`@.
noWidgetClassScreenChangedFieldCallback :: Maybe WidgetClassScreenChangedFieldCallback
noWidgetClassScreenChangedFieldCallback = Nothing

-- | Wrap the callback into a `GClosure`.
genClosure_WidgetClassScreenChangedFieldCallback :: MonadIO m => WidgetClassScreenChangedFieldCallback -> m (GClosure C_WidgetClassScreenChangedFieldCallback)
genClosure_WidgetClassScreenChangedFieldCallback cb = liftIO $ do
    let cb' = wrap_WidgetClassScreenChangedFieldCallback Nothing cb
    mk_WidgetClassScreenChangedFieldCallback cb' >>= B.GClosure.newGClosure


-- | Wrap a `WidgetClassScreenChangedFieldCallback` into a `C_WidgetClassScreenChangedFieldCallback`.
wrap_WidgetClassScreenChangedFieldCallback :: 
    Maybe (Ptr (FunPtr C_WidgetClassScreenChangedFieldCallback)) ->
    WidgetClassScreenChangedFieldCallback ->
    C_WidgetClassScreenChangedFieldCallback
wrap_WidgetClassScreenChangedFieldCallback gi'funptrptr gi'cb widget previousScreen = do
    widget' <- (newObject Gtk.Widget.Widget) widget
    previousScreen' <- (newObject Gdk.Screen.Screen) previousScreen
    gi'cb  widget' previousScreen'
    maybeReleaseFunPtr gi'funptrptr


-- callback WidgetClassRealizeFieldCallback
{- Callable
  { returnType = Nothing
  , returnMayBeNull = False
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , args =
      [ Arg
          { argCName = "widget"
          , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText = Just "a #GtkWidget" , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_WidgetClassRealizeFieldCallback =
    Ptr Gtk.Widget.Widget ->
    IO ()

-- Args: [ Arg
--           { argCName = "widget"
--           , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "a #GtkWidget" , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Nothing
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_WidgetClassRealizeFieldCallback :: FunPtr C_WidgetClassRealizeFieldCallback -> C_WidgetClassRealizeFieldCallback

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_WidgetClassRealizeFieldCallback ::
    (B.CallStack.HasCallStack, MonadIO m, Gtk.Widget.IsWidget a) =>
    FunPtr C_WidgetClassRealizeFieldCallback
    -> a
    -- ^ /@widget@/: a t'GI.Gtk.Objects.Widget.Widget'
    -> m ()
dynamic_WidgetClassRealizeFieldCallback __funPtr widget = liftIO $ do
    widget' <- unsafeManagedPtrCastPtr widget
    (__dynamic_C_WidgetClassRealizeFieldCallback __funPtr) widget'
    touchManagedPtr widget
    return ()

-- | Generate a function pointer callable from C code, from a `C_WidgetClassRealizeFieldCallback`.
foreign import ccall "wrapper"
    mk_WidgetClassRealizeFieldCallback :: C_WidgetClassRealizeFieldCallback -> IO (FunPtr C_WidgetClassRealizeFieldCallback)

-- | /No description available in the introspection data./
type WidgetClassRealizeFieldCallback =
    Gtk.Widget.Widget
    -- ^ /@widget@/: a t'GI.Gtk.Objects.Widget.Widget'
    -> IO ()

-- | A convenience synonym for @`Nothing` :: `Maybe` `WidgetClassRealizeFieldCallback`@.
noWidgetClassRealizeFieldCallback :: Maybe WidgetClassRealizeFieldCallback
noWidgetClassRealizeFieldCallback = Nothing

-- | Wrap the callback into a `GClosure`.
genClosure_WidgetClassRealizeFieldCallback :: MonadIO m => WidgetClassRealizeFieldCallback -> m (GClosure C_WidgetClassRealizeFieldCallback)
genClosure_WidgetClassRealizeFieldCallback cb = liftIO $ do
    let cb' = wrap_WidgetClassRealizeFieldCallback Nothing cb
    mk_WidgetClassRealizeFieldCallback cb' >>= B.GClosure.newGClosure


-- | Wrap a `WidgetClassRealizeFieldCallback` into a `C_WidgetClassRealizeFieldCallback`.
wrap_WidgetClassRealizeFieldCallback :: 
    Maybe (Ptr (FunPtr C_WidgetClassRealizeFieldCallback)) ->
    WidgetClassRealizeFieldCallback ->
    C_WidgetClassRealizeFieldCallback
wrap_WidgetClassRealizeFieldCallback gi'funptrptr gi'cb widget = do
    widget' <- (newObject Gtk.Widget.Widget) widget
    gi'cb  widget'
    maybeReleaseFunPtr gi'funptrptr


-- callback WidgetClassQueueDrawRegionFieldCallback
{- Callable
  { returnType = Nothing
  , returnMayBeNull = False
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , args =
      [ Arg
          { argCName = "widget"
          , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText = Just "a #GtkWidget" , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "region"
          , argType =
              TInterface Name { namespace = "cairo" , name = "Region" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText = Just "region to draw" , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_WidgetClassQueueDrawRegionFieldCallback =
    Ptr Gtk.Widget.Widget ->
    Ptr Cairo.Region.Region ->
    IO ()

-- Args: [ Arg
--           { argCName = "widget"
--           , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "a #GtkWidget" , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "region"
--           , argType =
--               TInterface Name { namespace = "cairo" , name = "Region" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "region to draw" , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Nothing
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_WidgetClassQueueDrawRegionFieldCallback :: FunPtr C_WidgetClassQueueDrawRegionFieldCallback -> C_WidgetClassQueueDrawRegionFieldCallback

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_WidgetClassQueueDrawRegionFieldCallback ::
    (B.CallStack.HasCallStack, MonadIO m, Gtk.Widget.IsWidget a) =>
    FunPtr C_WidgetClassQueueDrawRegionFieldCallback
    -> a
    -- ^ /@widget@/: a t'GI.Gtk.Objects.Widget.Widget'
    -> Cairo.Region.Region
    -- ^ /@region@/: region to draw
    -> m ()
dynamic_WidgetClassQueueDrawRegionFieldCallback __funPtr widget region = liftIO $ do
    widget' <- unsafeManagedPtrCastPtr widget
    region' <- unsafeManagedPtrGetPtr region
    (__dynamic_C_WidgetClassQueueDrawRegionFieldCallback __funPtr) widget' region'
    touchManagedPtr widget
    touchManagedPtr region
    return ()

-- | Generate a function pointer callable from C code, from a `C_WidgetClassQueueDrawRegionFieldCallback`.
foreign import ccall "wrapper"
    mk_WidgetClassQueueDrawRegionFieldCallback :: C_WidgetClassQueueDrawRegionFieldCallback -> IO (FunPtr C_WidgetClassQueueDrawRegionFieldCallback)

-- | /No description available in the introspection data./
type WidgetClassQueueDrawRegionFieldCallback =
    Gtk.Widget.Widget
    -- ^ /@widget@/: a t'GI.Gtk.Objects.Widget.Widget'
    -> Cairo.Region.Region
    -- ^ /@region@/: region to draw
    -> IO ()

-- | A convenience synonym for @`Nothing` :: `Maybe` `WidgetClassQueueDrawRegionFieldCallback`@.
noWidgetClassQueueDrawRegionFieldCallback :: Maybe WidgetClassQueueDrawRegionFieldCallback
noWidgetClassQueueDrawRegionFieldCallback = Nothing

-- | Wrap the callback into a `GClosure`.
genClosure_WidgetClassQueueDrawRegionFieldCallback :: MonadIO m => WidgetClassQueueDrawRegionFieldCallback -> m (GClosure C_WidgetClassQueueDrawRegionFieldCallback)
genClosure_WidgetClassQueueDrawRegionFieldCallback cb = liftIO $ do
    let cb' = wrap_WidgetClassQueueDrawRegionFieldCallback Nothing cb
    mk_WidgetClassQueueDrawRegionFieldCallback cb' >>= B.GClosure.newGClosure


-- | Wrap a `WidgetClassQueueDrawRegionFieldCallback` into a `C_WidgetClassQueueDrawRegionFieldCallback`.
wrap_WidgetClassQueueDrawRegionFieldCallback :: 
    Maybe (Ptr (FunPtr C_WidgetClassQueueDrawRegionFieldCallback)) ->
    WidgetClassQueueDrawRegionFieldCallback ->
    C_WidgetClassQueueDrawRegionFieldCallback
wrap_WidgetClassQueueDrawRegionFieldCallback gi'funptrptr gi'cb widget region = do
    widget' <- (newObject Gtk.Widget.Widget) widget
    B.ManagedPtr.withTransient  region $ \region' -> do
        gi'cb  widget' region'
        maybeReleaseFunPtr gi'funptrptr


-- callback WidgetClassQueryTooltipFieldCallback
{- Callable
  { returnType = Just (TBasicType TBoolean)
  , returnMayBeNull = False
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , args =
      [ Arg
          { argCName = "widget"
          , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "x"
          , argType = TBasicType TInt
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "y"
          , argType = TBasicType TInt
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "keyboard_tooltip"
          , argType = TBasicType TBoolean
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "tooltip"
          , argType =
              TInterface Name { namespace = "Gtk" , name = "Tooltip" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_WidgetClassQueryTooltipFieldCallback =
    Ptr Gtk.Widget.Widget ->
    Int32 ->
    Int32 ->
    CInt ->
    Ptr Gtk.Tooltip.Tooltip ->
    IO CInt

-- Args: [ Arg
--           { argCName = "widget"
--           , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "x"
--           , argType = TBasicType TInt
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "y"
--           , argType = TBasicType TInt
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "keyboard_tooltip"
--           , argType = TBasicType TBoolean
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "tooltip"
--           , argType =
--               TInterface Name { namespace = "Gtk" , name = "Tooltip" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Just (TBasicType TBoolean)
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_WidgetClassQueryTooltipFieldCallback :: FunPtr C_WidgetClassQueryTooltipFieldCallback -> C_WidgetClassQueryTooltipFieldCallback

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_WidgetClassQueryTooltipFieldCallback ::
    (B.CallStack.HasCallStack, MonadIO m, Gtk.Widget.IsWidget a, Gtk.Tooltip.IsTooltip b) =>
    FunPtr C_WidgetClassQueryTooltipFieldCallback
    -> a
    -> Int32
    -> Int32
    -> Bool
    -> b
    -> m Bool
dynamic_WidgetClassQueryTooltipFieldCallback __funPtr widget x y keyboardTooltip tooltip = liftIO $ do
    widget' <- unsafeManagedPtrCastPtr widget
    let keyboardTooltip' = (fromIntegral . fromEnum) keyboardTooltip
    tooltip' <- unsafeManagedPtrCastPtr tooltip
    result <- (__dynamic_C_WidgetClassQueryTooltipFieldCallback __funPtr) widget' x y keyboardTooltip' tooltip'
    let result' = (/= 0) result
    touchManagedPtr widget
    touchManagedPtr tooltip
    return result'

-- | Generate a function pointer callable from C code, from a `C_WidgetClassQueryTooltipFieldCallback`.
foreign import ccall "wrapper"
    mk_WidgetClassQueryTooltipFieldCallback :: C_WidgetClassQueryTooltipFieldCallback -> IO (FunPtr C_WidgetClassQueryTooltipFieldCallback)

-- | /No description available in the introspection data./
type WidgetClassQueryTooltipFieldCallback =
    Gtk.Widget.Widget
    -> Int32
    -> Int32
    -> Bool
    -> Gtk.Tooltip.Tooltip
    -> IO Bool

-- | A convenience synonym for @`Nothing` :: `Maybe` `WidgetClassQueryTooltipFieldCallback`@.
noWidgetClassQueryTooltipFieldCallback :: Maybe WidgetClassQueryTooltipFieldCallback
noWidgetClassQueryTooltipFieldCallback = Nothing

-- | Wrap the callback into a `GClosure`.
genClosure_WidgetClassQueryTooltipFieldCallback :: MonadIO m => WidgetClassQueryTooltipFieldCallback -> m (GClosure C_WidgetClassQueryTooltipFieldCallback)
genClosure_WidgetClassQueryTooltipFieldCallback cb = liftIO $ do
    let cb' = wrap_WidgetClassQueryTooltipFieldCallback Nothing cb
    mk_WidgetClassQueryTooltipFieldCallback cb' >>= B.GClosure.newGClosure


-- | Wrap a `WidgetClassQueryTooltipFieldCallback` into a `C_WidgetClassQueryTooltipFieldCallback`.
wrap_WidgetClassQueryTooltipFieldCallback :: 
    Maybe (Ptr (FunPtr C_WidgetClassQueryTooltipFieldCallback)) ->
    WidgetClassQueryTooltipFieldCallback ->
    C_WidgetClassQueryTooltipFieldCallback
wrap_WidgetClassQueryTooltipFieldCallback gi'funptrptr gi'cb widget x y keyboardTooltip tooltip = do
    widget' <- (newObject Gtk.Widget.Widget) widget
    let keyboardTooltip' = (/= 0) keyboardTooltip
    tooltip' <- (newObject Gtk.Tooltip.Tooltip) tooltip
    result <- gi'cb  widget' x y keyboardTooltip' tooltip'
    maybeReleaseFunPtr gi'funptrptr
    let result' = (fromIntegral . fromEnum) result
    return result'


-- callback WidgetClassProximityOutEventFieldCallback
{- Callable
  { returnType = Just (TBasicType TBoolean)
  , returnMayBeNull = False
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , args =
      [ Arg
          { argCName = "widget"
          , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "event"
          , argType =
              TInterface Name { namespace = "Gdk" , name = "EventProximity" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_WidgetClassProximityOutEventFieldCallback =
    Ptr Gtk.Widget.Widget ->
    Ptr Gdk.EventProximity.EventProximity ->
    IO CInt

-- Args: [ Arg
--           { argCName = "widget"
--           , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "event"
--           , argType =
--               TInterface Name { namespace = "Gdk" , name = "EventProximity" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Just (TBasicType TBoolean)
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_WidgetClassProximityOutEventFieldCallback :: FunPtr C_WidgetClassProximityOutEventFieldCallback -> C_WidgetClassProximityOutEventFieldCallback

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_WidgetClassProximityOutEventFieldCallback ::
    (B.CallStack.HasCallStack, MonadIO m, Gtk.Widget.IsWidget a) =>
    FunPtr C_WidgetClassProximityOutEventFieldCallback
    -> a
    -> Gdk.EventProximity.EventProximity
    -> m Bool
dynamic_WidgetClassProximityOutEventFieldCallback __funPtr widget event = liftIO $ do
    widget' <- unsafeManagedPtrCastPtr widget
    event' <- unsafeManagedPtrGetPtr event
    result <- (__dynamic_C_WidgetClassProximityOutEventFieldCallback __funPtr) widget' event'
    let result' = (/= 0) result
    touchManagedPtr widget
    touchManagedPtr event
    return result'

-- | Generate a function pointer callable from C code, from a `C_WidgetClassProximityOutEventFieldCallback`.
foreign import ccall "wrapper"
    mk_WidgetClassProximityOutEventFieldCallback :: C_WidgetClassProximityOutEventFieldCallback -> IO (FunPtr C_WidgetClassProximityOutEventFieldCallback)

-- | /No description available in the introspection data./
type WidgetClassProximityOutEventFieldCallback =
    Gtk.Widget.Widget
    -> Gdk.EventProximity.EventProximity
    -> IO Bool

-- | A convenience synonym for @`Nothing` :: `Maybe` `WidgetClassProximityOutEventFieldCallback`@.
noWidgetClassProximityOutEventFieldCallback :: Maybe WidgetClassProximityOutEventFieldCallback
noWidgetClassProximityOutEventFieldCallback = Nothing

-- | Wrap the callback into a `GClosure`.
genClosure_WidgetClassProximityOutEventFieldCallback :: MonadIO m => WidgetClassProximityOutEventFieldCallback -> m (GClosure C_WidgetClassProximityOutEventFieldCallback)
genClosure_WidgetClassProximityOutEventFieldCallback cb = liftIO $ do
    let cb' = wrap_WidgetClassProximityOutEventFieldCallback Nothing cb
    mk_WidgetClassProximityOutEventFieldCallback cb' >>= B.GClosure.newGClosure


-- | Wrap a `WidgetClassProximityOutEventFieldCallback` into a `C_WidgetClassProximityOutEventFieldCallback`.
wrap_WidgetClassProximityOutEventFieldCallback :: 
    Maybe (Ptr (FunPtr C_WidgetClassProximityOutEventFieldCallback)) ->
    WidgetClassProximityOutEventFieldCallback ->
    C_WidgetClassProximityOutEventFieldCallback
wrap_WidgetClassProximityOutEventFieldCallback gi'funptrptr gi'cb widget event = do
    widget' <- (newObject Gtk.Widget.Widget) widget
    event' <- (newPtr Gdk.EventProximity.EventProximity) event
    result <- gi'cb  widget' event'
    maybeReleaseFunPtr gi'funptrptr
    let result' = (fromIntegral . fromEnum) result
    return result'


-- callback WidgetClassProximityInEventFieldCallback
{- Callable
  { returnType = Just (TBasicType TBoolean)
  , returnMayBeNull = False
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , args =
      [ Arg
          { argCName = "widget"
          , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "event"
          , argType =
              TInterface Name { namespace = "Gdk" , name = "EventProximity" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_WidgetClassProximityInEventFieldCallback =
    Ptr Gtk.Widget.Widget ->
    Ptr Gdk.EventProximity.EventProximity ->
    IO CInt

-- Args: [ Arg
--           { argCName = "widget"
--           , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "event"
--           , argType =
--               TInterface Name { namespace = "Gdk" , name = "EventProximity" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Just (TBasicType TBoolean)
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_WidgetClassProximityInEventFieldCallback :: FunPtr C_WidgetClassProximityInEventFieldCallback -> C_WidgetClassProximityInEventFieldCallback

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_WidgetClassProximityInEventFieldCallback ::
    (B.CallStack.HasCallStack, MonadIO m, Gtk.Widget.IsWidget a) =>
    FunPtr C_WidgetClassProximityInEventFieldCallback
    -> a
    -> Gdk.EventProximity.EventProximity
    -> m Bool
dynamic_WidgetClassProximityInEventFieldCallback __funPtr widget event = liftIO $ do
    widget' <- unsafeManagedPtrCastPtr widget
    event' <- unsafeManagedPtrGetPtr event
    result <- (__dynamic_C_WidgetClassProximityInEventFieldCallback __funPtr) widget' event'
    let result' = (/= 0) result
    touchManagedPtr widget
    touchManagedPtr event
    return result'

-- | Generate a function pointer callable from C code, from a `C_WidgetClassProximityInEventFieldCallback`.
foreign import ccall "wrapper"
    mk_WidgetClassProximityInEventFieldCallback :: C_WidgetClassProximityInEventFieldCallback -> IO (FunPtr C_WidgetClassProximityInEventFieldCallback)

-- | /No description available in the introspection data./
type WidgetClassProximityInEventFieldCallback =
    Gtk.Widget.Widget
    -> Gdk.EventProximity.EventProximity
    -> IO Bool

-- | A convenience synonym for @`Nothing` :: `Maybe` `WidgetClassProximityInEventFieldCallback`@.
noWidgetClassProximityInEventFieldCallback :: Maybe WidgetClassProximityInEventFieldCallback
noWidgetClassProximityInEventFieldCallback = Nothing

-- | Wrap the callback into a `GClosure`.
genClosure_WidgetClassProximityInEventFieldCallback :: MonadIO m => WidgetClassProximityInEventFieldCallback -> m (GClosure C_WidgetClassProximityInEventFieldCallback)
genClosure_WidgetClassProximityInEventFieldCallback cb = liftIO $ do
    let cb' = wrap_WidgetClassProximityInEventFieldCallback Nothing cb
    mk_WidgetClassProximityInEventFieldCallback cb' >>= B.GClosure.newGClosure


-- | Wrap a `WidgetClassProximityInEventFieldCallback` into a `C_WidgetClassProximityInEventFieldCallback`.
wrap_WidgetClassProximityInEventFieldCallback :: 
    Maybe (Ptr (FunPtr C_WidgetClassProximityInEventFieldCallback)) ->
    WidgetClassProximityInEventFieldCallback ->
    C_WidgetClassProximityInEventFieldCallback
wrap_WidgetClassProximityInEventFieldCallback gi'funptrptr gi'cb widget event = do
    widget' <- (newObject Gtk.Widget.Widget) widget
    event' <- (newPtr Gdk.EventProximity.EventProximity) event
    result <- gi'cb  widget' event'
    maybeReleaseFunPtr gi'funptrptr
    let result' = (fromIntegral . fromEnum) result
    return result'


-- callback WidgetClassPropertyNotifyEventFieldCallback
{- Callable
  { returnType = Just (TBasicType TBoolean)
  , returnMayBeNull = False
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , args =
      [ Arg
          { argCName = "widget"
          , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "event"
          , argType =
              TInterface Name { namespace = "Gdk" , name = "EventProperty" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_WidgetClassPropertyNotifyEventFieldCallback =
    Ptr Gtk.Widget.Widget ->
    Ptr Gdk.EventProperty.EventProperty ->
    IO CInt

-- Args: [ Arg
--           { argCName = "widget"
--           , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "event"
--           , argType =
--               TInterface Name { namespace = "Gdk" , name = "EventProperty" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Just (TBasicType TBoolean)
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_WidgetClassPropertyNotifyEventFieldCallback :: FunPtr C_WidgetClassPropertyNotifyEventFieldCallback -> C_WidgetClassPropertyNotifyEventFieldCallback

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_WidgetClassPropertyNotifyEventFieldCallback ::
    (B.CallStack.HasCallStack, MonadIO m, Gtk.Widget.IsWidget a) =>
    FunPtr C_WidgetClassPropertyNotifyEventFieldCallback
    -> a
    -> Gdk.EventProperty.EventProperty
    -> m Bool
dynamic_WidgetClassPropertyNotifyEventFieldCallback __funPtr widget event = liftIO $ do
    widget' <- unsafeManagedPtrCastPtr widget
    event' <- unsafeManagedPtrGetPtr event
    result <- (__dynamic_C_WidgetClassPropertyNotifyEventFieldCallback __funPtr) widget' event'
    let result' = (/= 0) result
    touchManagedPtr widget
    touchManagedPtr event
    return result'

-- | Generate a function pointer callable from C code, from a `C_WidgetClassPropertyNotifyEventFieldCallback`.
foreign import ccall "wrapper"
    mk_WidgetClassPropertyNotifyEventFieldCallback :: C_WidgetClassPropertyNotifyEventFieldCallback -> IO (FunPtr C_WidgetClassPropertyNotifyEventFieldCallback)

-- | /No description available in the introspection data./
type WidgetClassPropertyNotifyEventFieldCallback =
    Gtk.Widget.Widget
    -> Gdk.EventProperty.EventProperty
    -> IO Bool

-- | A convenience synonym for @`Nothing` :: `Maybe` `WidgetClassPropertyNotifyEventFieldCallback`@.
noWidgetClassPropertyNotifyEventFieldCallback :: Maybe WidgetClassPropertyNotifyEventFieldCallback
noWidgetClassPropertyNotifyEventFieldCallback = Nothing

-- | Wrap the callback into a `GClosure`.
genClosure_WidgetClassPropertyNotifyEventFieldCallback :: MonadIO m => WidgetClassPropertyNotifyEventFieldCallback -> m (GClosure C_WidgetClassPropertyNotifyEventFieldCallback)
genClosure_WidgetClassPropertyNotifyEventFieldCallback cb = liftIO $ do
    let cb' = wrap_WidgetClassPropertyNotifyEventFieldCallback Nothing cb
    mk_WidgetClassPropertyNotifyEventFieldCallback cb' >>= B.GClosure.newGClosure


-- | Wrap a `WidgetClassPropertyNotifyEventFieldCallback` into a `C_WidgetClassPropertyNotifyEventFieldCallback`.
wrap_WidgetClassPropertyNotifyEventFieldCallback :: 
    Maybe (Ptr (FunPtr C_WidgetClassPropertyNotifyEventFieldCallback)) ->
    WidgetClassPropertyNotifyEventFieldCallback ->
    C_WidgetClassPropertyNotifyEventFieldCallback
wrap_WidgetClassPropertyNotifyEventFieldCallback gi'funptrptr gi'cb widget event = do
    widget' <- (newObject Gtk.Widget.Widget) widget
    event' <- (newPtr Gdk.EventProperty.EventProperty) event
    result <- gi'cb  widget' event'
    maybeReleaseFunPtr gi'funptrptr
    let result' = (fromIntegral . fromEnum) result
    return result'


-- callback WidgetClassPopupMenuFieldCallback
{- Callable
  { returnType = Just (TBasicType TBoolean)
  , returnMayBeNull = False
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , args =
      [ Arg
          { argCName = "widget"
          , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_WidgetClassPopupMenuFieldCallback =
    Ptr Gtk.Widget.Widget ->
    IO CInt

-- Args: [ Arg
--           { argCName = "widget"
--           , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Just (TBasicType TBoolean)
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_WidgetClassPopupMenuFieldCallback :: FunPtr C_WidgetClassPopupMenuFieldCallback -> C_WidgetClassPopupMenuFieldCallback

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_WidgetClassPopupMenuFieldCallback ::
    (B.CallStack.HasCallStack, MonadIO m, Gtk.Widget.IsWidget a) =>
    FunPtr C_WidgetClassPopupMenuFieldCallback
    -> a
    -> m Bool
dynamic_WidgetClassPopupMenuFieldCallback __funPtr widget = liftIO $ do
    widget' <- unsafeManagedPtrCastPtr widget
    result <- (__dynamic_C_WidgetClassPopupMenuFieldCallback __funPtr) widget'
    let result' = (/= 0) result
    touchManagedPtr widget
    return result'

-- | Generate a function pointer callable from C code, from a `C_WidgetClassPopupMenuFieldCallback`.
foreign import ccall "wrapper"
    mk_WidgetClassPopupMenuFieldCallback :: C_WidgetClassPopupMenuFieldCallback -> IO (FunPtr C_WidgetClassPopupMenuFieldCallback)

-- | /No description available in the introspection data./
type WidgetClassPopupMenuFieldCallback =
    Gtk.Widget.Widget
    -> IO Bool

-- | A convenience synonym for @`Nothing` :: `Maybe` `WidgetClassPopupMenuFieldCallback`@.
noWidgetClassPopupMenuFieldCallback :: Maybe WidgetClassPopupMenuFieldCallback
noWidgetClassPopupMenuFieldCallback = Nothing

-- | Wrap the callback into a `GClosure`.
genClosure_WidgetClassPopupMenuFieldCallback :: MonadIO m => WidgetClassPopupMenuFieldCallback -> m (GClosure C_WidgetClassPopupMenuFieldCallback)
genClosure_WidgetClassPopupMenuFieldCallback cb = liftIO $ do
    let cb' = wrap_WidgetClassPopupMenuFieldCallback Nothing cb
    mk_WidgetClassPopupMenuFieldCallback cb' >>= B.GClosure.newGClosure


-- | Wrap a `WidgetClassPopupMenuFieldCallback` into a `C_WidgetClassPopupMenuFieldCallback`.
wrap_WidgetClassPopupMenuFieldCallback :: 
    Maybe (Ptr (FunPtr C_WidgetClassPopupMenuFieldCallback)) ->
    WidgetClassPopupMenuFieldCallback ->
    C_WidgetClassPopupMenuFieldCallback
wrap_WidgetClassPopupMenuFieldCallback gi'funptrptr gi'cb widget = do
    widget' <- (newObject Gtk.Widget.Widget) widget
    result <- gi'cb  widget'
    maybeReleaseFunPtr gi'funptrptr
    let result' = (fromIntegral . fromEnum) result
    return result'


-- callback WidgetClassParentSetFieldCallback
{- Callable
  { returnType = Nothing
  , returnMayBeNull = False
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , args =
      [ Arg
          { argCName = "widget"
          , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "previous_parent"
          , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_WidgetClassParentSetFieldCallback =
    Ptr Gtk.Widget.Widget ->
    Ptr Gtk.Widget.Widget ->
    IO ()

-- Args: [ Arg
--           { argCName = "widget"
--           , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "previous_parent"
--           , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Nothing
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_WidgetClassParentSetFieldCallback :: FunPtr C_WidgetClassParentSetFieldCallback -> C_WidgetClassParentSetFieldCallback

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_WidgetClassParentSetFieldCallback ::
    (B.CallStack.HasCallStack, MonadIO m, Gtk.Widget.IsWidget a, Gtk.Widget.IsWidget b) =>
    FunPtr C_WidgetClassParentSetFieldCallback
    -> a
    -> b
    -> m ()
dynamic_WidgetClassParentSetFieldCallback __funPtr widget previousParent = liftIO $ do
    widget' <- unsafeManagedPtrCastPtr widget
    previousParent' <- unsafeManagedPtrCastPtr previousParent
    (__dynamic_C_WidgetClassParentSetFieldCallback __funPtr) widget' previousParent'
    touchManagedPtr widget
    touchManagedPtr previousParent
    return ()

-- | Generate a function pointer callable from C code, from a `C_WidgetClassParentSetFieldCallback`.
foreign import ccall "wrapper"
    mk_WidgetClassParentSetFieldCallback :: C_WidgetClassParentSetFieldCallback -> IO (FunPtr C_WidgetClassParentSetFieldCallback)

-- | /No description available in the introspection data./
type WidgetClassParentSetFieldCallback =
    Gtk.Widget.Widget
    -> Gtk.Widget.Widget
    -> IO ()

-- | A convenience synonym for @`Nothing` :: `Maybe` `WidgetClassParentSetFieldCallback`@.
noWidgetClassParentSetFieldCallback :: Maybe WidgetClassParentSetFieldCallback
noWidgetClassParentSetFieldCallback = Nothing

-- | Wrap the callback into a `GClosure`.
genClosure_WidgetClassParentSetFieldCallback :: MonadIO m => WidgetClassParentSetFieldCallback -> m (GClosure C_WidgetClassParentSetFieldCallback)
genClosure_WidgetClassParentSetFieldCallback cb = liftIO $ do
    let cb' = wrap_WidgetClassParentSetFieldCallback Nothing cb
    mk_WidgetClassParentSetFieldCallback cb' >>= B.GClosure.newGClosure


-- | Wrap a `WidgetClassParentSetFieldCallback` into a `C_WidgetClassParentSetFieldCallback`.
wrap_WidgetClassParentSetFieldCallback :: 
    Maybe (Ptr (FunPtr C_WidgetClassParentSetFieldCallback)) ->
    WidgetClassParentSetFieldCallback ->
    C_WidgetClassParentSetFieldCallback
wrap_WidgetClassParentSetFieldCallback gi'funptrptr gi'cb widget previousParent = do
    widget' <- (newObject Gtk.Widget.Widget) widget
    previousParent' <- (newObject Gtk.Widget.Widget) previousParent
    gi'cb  widget' previousParent'
    maybeReleaseFunPtr gi'funptrptr


-- callback WidgetClassMoveFocusFieldCallback
{- Callable
  { returnType = Nothing
  , returnMayBeNull = False
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , args =
      [ Arg
          { argCName = "widget"
          , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "direction"
          , argType =
              TInterface Name { namespace = "Gtk" , name = "DirectionType" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_WidgetClassMoveFocusFieldCallback =
    Ptr Gtk.Widget.Widget ->
    CUInt ->
    IO ()

-- Args: [ Arg
--           { argCName = "widget"
--           , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "direction"
--           , argType =
--               TInterface Name { namespace = "Gtk" , name = "DirectionType" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Nothing
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_WidgetClassMoveFocusFieldCallback :: FunPtr C_WidgetClassMoveFocusFieldCallback -> C_WidgetClassMoveFocusFieldCallback

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_WidgetClassMoveFocusFieldCallback ::
    (B.CallStack.HasCallStack, MonadIO m, Gtk.Widget.IsWidget a) =>
    FunPtr C_WidgetClassMoveFocusFieldCallback
    -> a
    -> Gtk.Enums.DirectionType
    -> m ()
dynamic_WidgetClassMoveFocusFieldCallback __funPtr widget direction = liftIO $ do
    widget' <- unsafeManagedPtrCastPtr widget
    let direction' = (fromIntegral . fromEnum) direction
    (__dynamic_C_WidgetClassMoveFocusFieldCallback __funPtr) widget' direction'
    touchManagedPtr widget
    return ()

-- | Generate a function pointer callable from C code, from a `C_WidgetClassMoveFocusFieldCallback`.
foreign import ccall "wrapper"
    mk_WidgetClassMoveFocusFieldCallback :: C_WidgetClassMoveFocusFieldCallback -> IO (FunPtr C_WidgetClassMoveFocusFieldCallback)

-- | /No description available in the introspection data./
type WidgetClassMoveFocusFieldCallback =
    Gtk.Widget.Widget
    -> Gtk.Enums.DirectionType
    -> IO ()

-- | A convenience synonym for @`Nothing` :: `Maybe` `WidgetClassMoveFocusFieldCallback`@.
noWidgetClassMoveFocusFieldCallback :: Maybe WidgetClassMoveFocusFieldCallback
noWidgetClassMoveFocusFieldCallback = Nothing

-- | Wrap the callback into a `GClosure`.
genClosure_WidgetClassMoveFocusFieldCallback :: MonadIO m => WidgetClassMoveFocusFieldCallback -> m (GClosure C_WidgetClassMoveFocusFieldCallback)
genClosure_WidgetClassMoveFocusFieldCallback cb = liftIO $ do
    let cb' = wrap_WidgetClassMoveFocusFieldCallback Nothing cb
    mk_WidgetClassMoveFocusFieldCallback cb' >>= B.GClosure.newGClosure


-- | Wrap a `WidgetClassMoveFocusFieldCallback` into a `C_WidgetClassMoveFocusFieldCallback`.
wrap_WidgetClassMoveFocusFieldCallback :: 
    Maybe (Ptr (FunPtr C_WidgetClassMoveFocusFieldCallback)) ->
    WidgetClassMoveFocusFieldCallback ->
    C_WidgetClassMoveFocusFieldCallback
wrap_WidgetClassMoveFocusFieldCallback gi'funptrptr gi'cb widget direction = do
    widget' <- (newObject Gtk.Widget.Widget) widget
    let direction' = (toEnum . fromIntegral) direction
    gi'cb  widget' direction'
    maybeReleaseFunPtr gi'funptrptr


-- callback WidgetClassMotionNotifyEventFieldCallback
{- Callable
  { returnType = Just (TBasicType TBoolean)
  , returnMayBeNull = False
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , args =
      [ Arg
          { argCName = "widget"
          , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "event"
          , argType =
              TInterface Name { namespace = "Gdk" , name = "EventMotion" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_WidgetClassMotionNotifyEventFieldCallback =
    Ptr Gtk.Widget.Widget ->
    Ptr Gdk.EventMotion.EventMotion ->
    IO CInt

-- Args: [ Arg
--           { argCName = "widget"
--           , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "event"
--           , argType =
--               TInterface Name { namespace = "Gdk" , name = "EventMotion" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Just (TBasicType TBoolean)
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_WidgetClassMotionNotifyEventFieldCallback :: FunPtr C_WidgetClassMotionNotifyEventFieldCallback -> C_WidgetClassMotionNotifyEventFieldCallback

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_WidgetClassMotionNotifyEventFieldCallback ::
    (B.CallStack.HasCallStack, MonadIO m, Gtk.Widget.IsWidget a) =>
    FunPtr C_WidgetClassMotionNotifyEventFieldCallback
    -> a
    -> Gdk.EventMotion.EventMotion
    -> m Bool
dynamic_WidgetClassMotionNotifyEventFieldCallback __funPtr widget event = liftIO $ do
    widget' <- unsafeManagedPtrCastPtr widget
    event' <- unsafeManagedPtrGetPtr event
    result <- (__dynamic_C_WidgetClassMotionNotifyEventFieldCallback __funPtr) widget' event'
    let result' = (/= 0) result
    touchManagedPtr widget
    touchManagedPtr event
    return result'

-- | Generate a function pointer callable from C code, from a `C_WidgetClassMotionNotifyEventFieldCallback`.
foreign import ccall "wrapper"
    mk_WidgetClassMotionNotifyEventFieldCallback :: C_WidgetClassMotionNotifyEventFieldCallback -> IO (FunPtr C_WidgetClassMotionNotifyEventFieldCallback)

-- | /No description available in the introspection data./
type WidgetClassMotionNotifyEventFieldCallback =
    Gtk.Widget.Widget
    -> Gdk.EventMotion.EventMotion
    -> IO Bool

-- | A convenience synonym for @`Nothing` :: `Maybe` `WidgetClassMotionNotifyEventFieldCallback`@.
noWidgetClassMotionNotifyEventFieldCallback :: Maybe WidgetClassMotionNotifyEventFieldCallback
noWidgetClassMotionNotifyEventFieldCallback = Nothing

-- | Wrap the callback into a `GClosure`.
genClosure_WidgetClassMotionNotifyEventFieldCallback :: MonadIO m => WidgetClassMotionNotifyEventFieldCallback -> m (GClosure C_WidgetClassMotionNotifyEventFieldCallback)
genClosure_WidgetClassMotionNotifyEventFieldCallback cb = liftIO $ do
    let cb' = wrap_WidgetClassMotionNotifyEventFieldCallback Nothing cb
    mk_WidgetClassMotionNotifyEventFieldCallback cb' >>= B.GClosure.newGClosure


-- | Wrap a `WidgetClassMotionNotifyEventFieldCallback` into a `C_WidgetClassMotionNotifyEventFieldCallback`.
wrap_WidgetClassMotionNotifyEventFieldCallback :: 
    Maybe (Ptr (FunPtr C_WidgetClassMotionNotifyEventFieldCallback)) ->
    WidgetClassMotionNotifyEventFieldCallback ->
    C_WidgetClassMotionNotifyEventFieldCallback
wrap_WidgetClassMotionNotifyEventFieldCallback gi'funptrptr gi'cb widget event = do
    widget' <- (newObject Gtk.Widget.Widget) widget
    event' <- (newPtr Gdk.EventMotion.EventMotion) event
    result <- gi'cb  widget' event'
    maybeReleaseFunPtr gi'funptrptr
    let result' = (fromIntegral . fromEnum) result
    return result'


-- callback WidgetClassMnemonicActivateFieldCallback
{- Callable
  { returnType = Just (TBasicType TBoolean)
  , returnMayBeNull = False
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation
        { rawDocText = Just "%TRUE if the signal has been handled"
        , sinceVersion = Nothing
        }
  , args =
      [ Arg
          { argCName = "widget"
          , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText = Just "a #GtkWidget" , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "group_cycling"
          , argType = TBasicType TBoolean
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText =
                    Just "%TRUE if there are other widgets with the same mnemonic"
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_WidgetClassMnemonicActivateFieldCallback =
    Ptr Gtk.Widget.Widget ->
    CInt ->
    IO CInt

-- Args: [ Arg
--           { argCName = "widget"
--           , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "a #GtkWidget" , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "group_cycling"
--           , argType = TBasicType TBoolean
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText =
--                     Just "%TRUE if there are other widgets with the same mnemonic"
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Just (TBasicType TBoolean)
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_WidgetClassMnemonicActivateFieldCallback :: FunPtr C_WidgetClassMnemonicActivateFieldCallback -> C_WidgetClassMnemonicActivateFieldCallback

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_WidgetClassMnemonicActivateFieldCallback ::
    (B.CallStack.HasCallStack, MonadIO m, Gtk.Widget.IsWidget a) =>
    FunPtr C_WidgetClassMnemonicActivateFieldCallback
    -> a
    -- ^ /@widget@/: a t'GI.Gtk.Objects.Widget.Widget'
    -> Bool
    -- ^ /@groupCycling@/: 'P.True' if there are other widgets with the same mnemonic
    -> m Bool
    -- ^ __Returns:__ 'P.True' if the signal has been handled
dynamic_WidgetClassMnemonicActivateFieldCallback __funPtr widget groupCycling = liftIO $ do
    widget' <- unsafeManagedPtrCastPtr widget
    let groupCycling' = (fromIntegral . fromEnum) groupCycling
    result <- (__dynamic_C_WidgetClassMnemonicActivateFieldCallback __funPtr) widget' groupCycling'
    let result' = (/= 0) result
    touchManagedPtr widget
    return result'

-- | Generate a function pointer callable from C code, from a `C_WidgetClassMnemonicActivateFieldCallback`.
foreign import ccall "wrapper"
    mk_WidgetClassMnemonicActivateFieldCallback :: C_WidgetClassMnemonicActivateFieldCallback -> IO (FunPtr C_WidgetClassMnemonicActivateFieldCallback)

-- | /No description available in the introspection data./
type WidgetClassMnemonicActivateFieldCallback =
    Gtk.Widget.Widget
    -- ^ /@widget@/: a t'GI.Gtk.Objects.Widget.Widget'
    -> Bool
    -- ^ /@groupCycling@/: 'P.True' if there are other widgets with the same mnemonic
    -> IO Bool
    -- ^ __Returns:__ 'P.True' if the signal has been handled

-- | A convenience synonym for @`Nothing` :: `Maybe` `WidgetClassMnemonicActivateFieldCallback`@.
noWidgetClassMnemonicActivateFieldCallback :: Maybe WidgetClassMnemonicActivateFieldCallback
noWidgetClassMnemonicActivateFieldCallback = Nothing

-- | Wrap the callback into a `GClosure`.
genClosure_WidgetClassMnemonicActivateFieldCallback :: MonadIO m => WidgetClassMnemonicActivateFieldCallback -> m (GClosure C_WidgetClassMnemonicActivateFieldCallback)
genClosure_WidgetClassMnemonicActivateFieldCallback cb = liftIO $ do
    let cb' = wrap_WidgetClassMnemonicActivateFieldCallback Nothing cb
    mk_WidgetClassMnemonicActivateFieldCallback cb' >>= B.GClosure.newGClosure


-- | Wrap a `WidgetClassMnemonicActivateFieldCallback` into a `C_WidgetClassMnemonicActivateFieldCallback`.
wrap_WidgetClassMnemonicActivateFieldCallback :: 
    Maybe (Ptr (FunPtr C_WidgetClassMnemonicActivateFieldCallback)) ->
    WidgetClassMnemonicActivateFieldCallback ->
    C_WidgetClassMnemonicActivateFieldCallback
wrap_WidgetClassMnemonicActivateFieldCallback gi'funptrptr gi'cb widget groupCycling = do
    widget' <- (newObject Gtk.Widget.Widget) widget
    let groupCycling' = (/= 0) groupCycling
    result <- gi'cb  widget' groupCycling'
    maybeReleaseFunPtr gi'funptrptr
    let result' = (fromIntegral . fromEnum) result
    return result'


-- callback WidgetClassMapFieldCallback
{- Callable
  { returnType = Nothing
  , returnMayBeNull = False
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , args =
      [ Arg
          { argCName = "widget"
          , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText = Just "a #GtkWidget" , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_WidgetClassMapFieldCallback =
    Ptr Gtk.Widget.Widget ->
    IO ()

-- Args: [ Arg
--           { argCName = "widget"
--           , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "a #GtkWidget" , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Nothing
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_WidgetClassMapFieldCallback :: FunPtr C_WidgetClassMapFieldCallback -> C_WidgetClassMapFieldCallback

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_WidgetClassMapFieldCallback ::
    (B.CallStack.HasCallStack, MonadIO m, Gtk.Widget.IsWidget a) =>
    FunPtr C_WidgetClassMapFieldCallback
    -> a
    -- ^ /@widget@/: a t'GI.Gtk.Objects.Widget.Widget'
    -> m ()
dynamic_WidgetClassMapFieldCallback __funPtr widget = liftIO $ do
    widget' <- unsafeManagedPtrCastPtr widget
    (__dynamic_C_WidgetClassMapFieldCallback __funPtr) widget'
    touchManagedPtr widget
    return ()

-- | Generate a function pointer callable from C code, from a `C_WidgetClassMapFieldCallback`.
foreign import ccall "wrapper"
    mk_WidgetClassMapFieldCallback :: C_WidgetClassMapFieldCallback -> IO (FunPtr C_WidgetClassMapFieldCallback)

-- | /No description available in the introspection data./
type WidgetClassMapFieldCallback =
    Gtk.Widget.Widget
    -- ^ /@widget@/: a t'GI.Gtk.Objects.Widget.Widget'
    -> IO ()

-- | A convenience synonym for @`Nothing` :: `Maybe` `WidgetClassMapFieldCallback`@.
noWidgetClassMapFieldCallback :: Maybe WidgetClassMapFieldCallback
noWidgetClassMapFieldCallback = Nothing

-- | Wrap the callback into a `GClosure`.
genClosure_WidgetClassMapFieldCallback :: MonadIO m => WidgetClassMapFieldCallback -> m (GClosure C_WidgetClassMapFieldCallback)
genClosure_WidgetClassMapFieldCallback cb = liftIO $ do
    let cb' = wrap_WidgetClassMapFieldCallback Nothing cb
    mk_WidgetClassMapFieldCallback cb' >>= B.GClosure.newGClosure


-- | Wrap a `WidgetClassMapFieldCallback` into a `C_WidgetClassMapFieldCallback`.
wrap_WidgetClassMapFieldCallback :: 
    Maybe (Ptr (FunPtr C_WidgetClassMapFieldCallback)) ->
    WidgetClassMapFieldCallback ->
    C_WidgetClassMapFieldCallback
wrap_WidgetClassMapFieldCallback gi'funptrptr gi'cb widget = do
    widget' <- (newObject Gtk.Widget.Widget) widget
    gi'cb  widget'
    maybeReleaseFunPtr gi'funptrptr


-- callback WidgetClassMapEventFieldCallback
{- Callable
  { returnType = Just (TBasicType TBoolean)
  , returnMayBeNull = False
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , args =
      [ Arg
          { argCName = "widget"
          , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "event"
          , argType =
              TInterface Name { namespace = "Gdk" , name = "EventAny" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_WidgetClassMapEventFieldCallback =
    Ptr Gtk.Widget.Widget ->
    Ptr Gdk.EventAny.EventAny ->
    IO CInt

-- Args: [ Arg
--           { argCName = "widget"
--           , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "event"
--           , argType =
--               TInterface Name { namespace = "Gdk" , name = "EventAny" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Just (TBasicType TBoolean)
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_WidgetClassMapEventFieldCallback :: FunPtr C_WidgetClassMapEventFieldCallback -> C_WidgetClassMapEventFieldCallback

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_WidgetClassMapEventFieldCallback ::
    (B.CallStack.HasCallStack, MonadIO m, Gtk.Widget.IsWidget a) =>
    FunPtr C_WidgetClassMapEventFieldCallback
    -> a
    -> Gdk.EventAny.EventAny
    -> m Bool
dynamic_WidgetClassMapEventFieldCallback __funPtr widget event = liftIO $ do
    widget' <- unsafeManagedPtrCastPtr widget
    event' <- unsafeManagedPtrGetPtr event
    result <- (__dynamic_C_WidgetClassMapEventFieldCallback __funPtr) widget' event'
    let result' = (/= 0) result
    touchManagedPtr widget
    touchManagedPtr event
    return result'

-- | Generate a function pointer callable from C code, from a `C_WidgetClassMapEventFieldCallback`.
foreign import ccall "wrapper"
    mk_WidgetClassMapEventFieldCallback :: C_WidgetClassMapEventFieldCallback -> IO (FunPtr C_WidgetClassMapEventFieldCallback)

-- | /No description available in the introspection data./
type WidgetClassMapEventFieldCallback =
    Gtk.Widget.Widget
    -> Gdk.EventAny.EventAny
    -> IO Bool

-- | A convenience synonym for @`Nothing` :: `Maybe` `WidgetClassMapEventFieldCallback`@.
noWidgetClassMapEventFieldCallback :: Maybe WidgetClassMapEventFieldCallback
noWidgetClassMapEventFieldCallback = Nothing

-- | Wrap the callback into a `GClosure`.
genClosure_WidgetClassMapEventFieldCallback :: MonadIO m => WidgetClassMapEventFieldCallback -> m (GClosure C_WidgetClassMapEventFieldCallback)
genClosure_WidgetClassMapEventFieldCallback cb = liftIO $ do
    let cb' = wrap_WidgetClassMapEventFieldCallback Nothing cb
    mk_WidgetClassMapEventFieldCallback cb' >>= B.GClosure.newGClosure


-- | Wrap a `WidgetClassMapEventFieldCallback` into a `C_WidgetClassMapEventFieldCallback`.
wrap_WidgetClassMapEventFieldCallback :: 
    Maybe (Ptr (FunPtr C_WidgetClassMapEventFieldCallback)) ->
    WidgetClassMapEventFieldCallback ->
    C_WidgetClassMapEventFieldCallback
wrap_WidgetClassMapEventFieldCallback gi'funptrptr gi'cb widget event = do
    widget' <- (newObject Gtk.Widget.Widget) widget
    event' <- (newPtr Gdk.EventAny.EventAny) event
    result <- gi'cb  widget' event'
    maybeReleaseFunPtr gi'funptrptr
    let result' = (fromIntegral . fromEnum) result
    return result'


-- callback WidgetClassLeaveNotifyEventFieldCallback
{- Callable
  { returnType = Just (TBasicType TBoolean)
  , returnMayBeNull = False
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , args =
      [ Arg
          { argCName = "widget"
          , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "event"
          , argType =
              TInterface Name { namespace = "Gdk" , name = "EventCrossing" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_WidgetClassLeaveNotifyEventFieldCallback =
    Ptr Gtk.Widget.Widget ->
    Ptr Gdk.EventCrossing.EventCrossing ->
    IO CInt

-- Args: [ Arg
--           { argCName = "widget"
--           , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "event"
--           , argType =
--               TInterface Name { namespace = "Gdk" , name = "EventCrossing" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Just (TBasicType TBoolean)
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_WidgetClassLeaveNotifyEventFieldCallback :: FunPtr C_WidgetClassLeaveNotifyEventFieldCallback -> C_WidgetClassLeaveNotifyEventFieldCallback

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_WidgetClassLeaveNotifyEventFieldCallback ::
    (B.CallStack.HasCallStack, MonadIO m, Gtk.Widget.IsWidget a) =>
    FunPtr C_WidgetClassLeaveNotifyEventFieldCallback
    -> a
    -> Gdk.EventCrossing.EventCrossing
    -> m Bool
dynamic_WidgetClassLeaveNotifyEventFieldCallback __funPtr widget event = liftIO $ do
    widget' <- unsafeManagedPtrCastPtr widget
    event' <- unsafeManagedPtrGetPtr event
    result <- (__dynamic_C_WidgetClassLeaveNotifyEventFieldCallback __funPtr) widget' event'
    let result' = (/= 0) result
    touchManagedPtr widget
    touchManagedPtr event
    return result'

-- | Generate a function pointer callable from C code, from a `C_WidgetClassLeaveNotifyEventFieldCallback`.
foreign import ccall "wrapper"
    mk_WidgetClassLeaveNotifyEventFieldCallback :: C_WidgetClassLeaveNotifyEventFieldCallback -> IO (FunPtr C_WidgetClassLeaveNotifyEventFieldCallback)

-- | /No description available in the introspection data./
type WidgetClassLeaveNotifyEventFieldCallback =
    Gtk.Widget.Widget
    -> Gdk.EventCrossing.EventCrossing
    -> IO Bool

-- | A convenience synonym for @`Nothing` :: `Maybe` `WidgetClassLeaveNotifyEventFieldCallback`@.
noWidgetClassLeaveNotifyEventFieldCallback :: Maybe WidgetClassLeaveNotifyEventFieldCallback
noWidgetClassLeaveNotifyEventFieldCallback = Nothing

-- | Wrap the callback into a `GClosure`.
genClosure_WidgetClassLeaveNotifyEventFieldCallback :: MonadIO m => WidgetClassLeaveNotifyEventFieldCallback -> m (GClosure C_WidgetClassLeaveNotifyEventFieldCallback)
genClosure_WidgetClassLeaveNotifyEventFieldCallback cb = liftIO $ do
    let cb' = wrap_WidgetClassLeaveNotifyEventFieldCallback Nothing cb
    mk_WidgetClassLeaveNotifyEventFieldCallback cb' >>= B.GClosure.newGClosure


-- | Wrap a `WidgetClassLeaveNotifyEventFieldCallback` into a `C_WidgetClassLeaveNotifyEventFieldCallback`.
wrap_WidgetClassLeaveNotifyEventFieldCallback :: 
    Maybe (Ptr (FunPtr C_WidgetClassLeaveNotifyEventFieldCallback)) ->
    WidgetClassLeaveNotifyEventFieldCallback ->
    C_WidgetClassLeaveNotifyEventFieldCallback
wrap_WidgetClassLeaveNotifyEventFieldCallback gi'funptrptr gi'cb widget event = do
    widget' <- (newObject Gtk.Widget.Widget) widget
    event' <- (newPtr Gdk.EventCrossing.EventCrossing) event
    result <- gi'cb  widget' event'
    maybeReleaseFunPtr gi'funptrptr
    let result' = (fromIntegral . fromEnum) result
    return result'


-- callback WidgetClassKeynavFailedFieldCallback
{- Callable
  { returnType = Just (TBasicType TBoolean)
  , returnMayBeNull = False
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation
        { rawDocText =
            Just
              "%TRUE if stopping keyboard navigation is fine, %FALSE\n              if the emitting widget should try to handle the keyboard\n              navigation attempt in its parent container(s)."
        , sinceVersion = Nothing
        }
  , args =
      [ Arg
          { argCName = "widget"
          , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText = Just "a #GtkWidget" , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "direction"
          , argType =
              TInterface Name { namespace = "Gtk" , name = "DirectionType" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText = Just "direction of focus movement"
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_WidgetClassKeynavFailedFieldCallback =
    Ptr Gtk.Widget.Widget ->
    CUInt ->
    IO CInt

-- Args: [ Arg
--           { argCName = "widget"
--           , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "a #GtkWidget" , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "direction"
--           , argType =
--               TInterface Name { namespace = "Gtk" , name = "DirectionType" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "direction of focus movement"
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Just (TBasicType TBoolean)
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_WidgetClassKeynavFailedFieldCallback :: FunPtr C_WidgetClassKeynavFailedFieldCallback -> C_WidgetClassKeynavFailedFieldCallback

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_WidgetClassKeynavFailedFieldCallback ::
    (B.CallStack.HasCallStack, MonadIO m, Gtk.Widget.IsWidget a) =>
    FunPtr C_WidgetClassKeynavFailedFieldCallback
    -> a
    -- ^ /@widget@/: a t'GI.Gtk.Objects.Widget.Widget'
    -> Gtk.Enums.DirectionType
    -- ^ /@direction@/: direction of focus movement
    -> m Bool
    -- ^ __Returns:__ 'P.True' if stopping keyboard navigation is fine, 'P.False'
    --               if the emitting widget should try to handle the keyboard
    --               navigation attempt in its parent container(s).
dynamic_WidgetClassKeynavFailedFieldCallback __funPtr widget direction = liftIO $ do
    widget' <- unsafeManagedPtrCastPtr widget
    let direction' = (fromIntegral . fromEnum) direction
    result <- (__dynamic_C_WidgetClassKeynavFailedFieldCallback __funPtr) widget' direction'
    let result' = (/= 0) result
    touchManagedPtr widget
    return result'

-- | Generate a function pointer callable from C code, from a `C_WidgetClassKeynavFailedFieldCallback`.
foreign import ccall "wrapper"
    mk_WidgetClassKeynavFailedFieldCallback :: C_WidgetClassKeynavFailedFieldCallback -> IO (FunPtr C_WidgetClassKeynavFailedFieldCallback)

-- | /No description available in the introspection data./
type WidgetClassKeynavFailedFieldCallback =
    Gtk.Widget.Widget
    -- ^ /@widget@/: a t'GI.Gtk.Objects.Widget.Widget'
    -> Gtk.Enums.DirectionType
    -- ^ /@direction@/: direction of focus movement
    -> IO Bool
    -- ^ __Returns:__ 'P.True' if stopping keyboard navigation is fine, 'P.False'
    --               if the emitting widget should try to handle the keyboard
    --               navigation attempt in its parent container(s).

-- | A convenience synonym for @`Nothing` :: `Maybe` `WidgetClassKeynavFailedFieldCallback`@.
noWidgetClassKeynavFailedFieldCallback :: Maybe WidgetClassKeynavFailedFieldCallback
noWidgetClassKeynavFailedFieldCallback = Nothing

-- | Wrap the callback into a `GClosure`.
genClosure_WidgetClassKeynavFailedFieldCallback :: MonadIO m => WidgetClassKeynavFailedFieldCallback -> m (GClosure C_WidgetClassKeynavFailedFieldCallback)
genClosure_WidgetClassKeynavFailedFieldCallback cb = liftIO $ do
    let cb' = wrap_WidgetClassKeynavFailedFieldCallback Nothing cb
    mk_WidgetClassKeynavFailedFieldCallback cb' >>= B.GClosure.newGClosure


-- | Wrap a `WidgetClassKeynavFailedFieldCallback` into a `C_WidgetClassKeynavFailedFieldCallback`.
wrap_WidgetClassKeynavFailedFieldCallback :: 
    Maybe (Ptr (FunPtr C_WidgetClassKeynavFailedFieldCallback)) ->
    WidgetClassKeynavFailedFieldCallback ->
    C_WidgetClassKeynavFailedFieldCallback
wrap_WidgetClassKeynavFailedFieldCallback gi'funptrptr gi'cb widget direction = do
    widget' <- (newObject Gtk.Widget.Widget) widget
    let direction' = (toEnum . fromIntegral) direction
    result <- gi'cb  widget' direction'
    maybeReleaseFunPtr gi'funptrptr
    let result' = (fromIntegral . fromEnum) result
    return result'


-- callback WidgetClassKeyReleaseEventFieldCallback
{- Callable
  { returnType = Just (TBasicType TBoolean)
  , returnMayBeNull = False
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , args =
      [ Arg
          { argCName = "widget"
          , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "event"
          , argType =
              TInterface Name { namespace = "Gdk" , name = "EventKey" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_WidgetClassKeyReleaseEventFieldCallback =
    Ptr Gtk.Widget.Widget ->
    Ptr Gdk.EventKey.EventKey ->
    IO CInt

-- Args: [ Arg
--           { argCName = "widget"
--           , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "event"
--           , argType =
--               TInterface Name { namespace = "Gdk" , name = "EventKey" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Just (TBasicType TBoolean)
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_WidgetClassKeyReleaseEventFieldCallback :: FunPtr C_WidgetClassKeyReleaseEventFieldCallback -> C_WidgetClassKeyReleaseEventFieldCallback

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_WidgetClassKeyReleaseEventFieldCallback ::
    (B.CallStack.HasCallStack, MonadIO m, Gtk.Widget.IsWidget a) =>
    FunPtr C_WidgetClassKeyReleaseEventFieldCallback
    -> a
    -> Gdk.EventKey.EventKey
    -> m Bool
dynamic_WidgetClassKeyReleaseEventFieldCallback __funPtr widget event = liftIO $ do
    widget' <- unsafeManagedPtrCastPtr widget
    event' <- unsafeManagedPtrGetPtr event
    result <- (__dynamic_C_WidgetClassKeyReleaseEventFieldCallback __funPtr) widget' event'
    let result' = (/= 0) result
    touchManagedPtr widget
    touchManagedPtr event
    return result'

-- | Generate a function pointer callable from C code, from a `C_WidgetClassKeyReleaseEventFieldCallback`.
foreign import ccall "wrapper"
    mk_WidgetClassKeyReleaseEventFieldCallback :: C_WidgetClassKeyReleaseEventFieldCallback -> IO (FunPtr C_WidgetClassKeyReleaseEventFieldCallback)

-- | /No description available in the introspection data./
type WidgetClassKeyReleaseEventFieldCallback =
    Gtk.Widget.Widget
    -> Gdk.EventKey.EventKey
    -> IO Bool

-- | A convenience synonym for @`Nothing` :: `Maybe` `WidgetClassKeyReleaseEventFieldCallback`@.
noWidgetClassKeyReleaseEventFieldCallback :: Maybe WidgetClassKeyReleaseEventFieldCallback
noWidgetClassKeyReleaseEventFieldCallback = Nothing

-- | Wrap the callback into a `GClosure`.
genClosure_WidgetClassKeyReleaseEventFieldCallback :: MonadIO m => WidgetClassKeyReleaseEventFieldCallback -> m (GClosure C_WidgetClassKeyReleaseEventFieldCallback)
genClosure_WidgetClassKeyReleaseEventFieldCallback cb = liftIO $ do
    let cb' = wrap_WidgetClassKeyReleaseEventFieldCallback Nothing cb
    mk_WidgetClassKeyReleaseEventFieldCallback cb' >>= B.GClosure.newGClosure


-- | Wrap a `WidgetClassKeyReleaseEventFieldCallback` into a `C_WidgetClassKeyReleaseEventFieldCallback`.
wrap_WidgetClassKeyReleaseEventFieldCallback :: 
    Maybe (Ptr (FunPtr C_WidgetClassKeyReleaseEventFieldCallback)) ->
    WidgetClassKeyReleaseEventFieldCallback ->
    C_WidgetClassKeyReleaseEventFieldCallback
wrap_WidgetClassKeyReleaseEventFieldCallback gi'funptrptr gi'cb widget event = do
    widget' <- (newObject Gtk.Widget.Widget) widget
    event' <- (newPtr Gdk.EventKey.EventKey) event
    result <- gi'cb  widget' event'
    maybeReleaseFunPtr gi'funptrptr
    let result' = (fromIntegral . fromEnum) result
    return result'


-- callback WidgetClassKeyPressEventFieldCallback
{- Callable
  { returnType = Just (TBasicType TBoolean)
  , returnMayBeNull = False
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , args =
      [ Arg
          { argCName = "widget"
          , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "event"
          , argType =
              TInterface Name { namespace = "Gdk" , name = "EventKey" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_WidgetClassKeyPressEventFieldCallback =
    Ptr Gtk.Widget.Widget ->
    Ptr Gdk.EventKey.EventKey ->
    IO CInt

-- Args: [ Arg
--           { argCName = "widget"
--           , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "event"
--           , argType =
--               TInterface Name { namespace = "Gdk" , name = "EventKey" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Just (TBasicType TBoolean)
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_WidgetClassKeyPressEventFieldCallback :: FunPtr C_WidgetClassKeyPressEventFieldCallback -> C_WidgetClassKeyPressEventFieldCallback

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_WidgetClassKeyPressEventFieldCallback ::
    (B.CallStack.HasCallStack, MonadIO m, Gtk.Widget.IsWidget a) =>
    FunPtr C_WidgetClassKeyPressEventFieldCallback
    -> a
    -> Gdk.EventKey.EventKey
    -> m Bool
dynamic_WidgetClassKeyPressEventFieldCallback __funPtr widget event = liftIO $ do
    widget' <- unsafeManagedPtrCastPtr widget
    event' <- unsafeManagedPtrGetPtr event
    result <- (__dynamic_C_WidgetClassKeyPressEventFieldCallback __funPtr) widget' event'
    let result' = (/= 0) result
    touchManagedPtr widget
    touchManagedPtr event
    return result'

-- | Generate a function pointer callable from C code, from a `C_WidgetClassKeyPressEventFieldCallback`.
foreign import ccall "wrapper"
    mk_WidgetClassKeyPressEventFieldCallback :: C_WidgetClassKeyPressEventFieldCallback -> IO (FunPtr C_WidgetClassKeyPressEventFieldCallback)

-- | /No description available in the introspection data./
type WidgetClassKeyPressEventFieldCallback =
    Gtk.Widget.Widget
    -> Gdk.EventKey.EventKey
    -> IO Bool

-- | A convenience synonym for @`Nothing` :: `Maybe` `WidgetClassKeyPressEventFieldCallback`@.
noWidgetClassKeyPressEventFieldCallback :: Maybe WidgetClassKeyPressEventFieldCallback
noWidgetClassKeyPressEventFieldCallback = Nothing

-- | Wrap the callback into a `GClosure`.
genClosure_WidgetClassKeyPressEventFieldCallback :: MonadIO m => WidgetClassKeyPressEventFieldCallback -> m (GClosure C_WidgetClassKeyPressEventFieldCallback)
genClosure_WidgetClassKeyPressEventFieldCallback cb = liftIO $ do
    let cb' = wrap_WidgetClassKeyPressEventFieldCallback Nothing cb
    mk_WidgetClassKeyPressEventFieldCallback cb' >>= B.GClosure.newGClosure


-- | Wrap a `WidgetClassKeyPressEventFieldCallback` into a `C_WidgetClassKeyPressEventFieldCallback`.
wrap_WidgetClassKeyPressEventFieldCallback :: 
    Maybe (Ptr (FunPtr C_WidgetClassKeyPressEventFieldCallback)) ->
    WidgetClassKeyPressEventFieldCallback ->
    C_WidgetClassKeyPressEventFieldCallback
wrap_WidgetClassKeyPressEventFieldCallback gi'funptrptr gi'cb widget event = do
    widget' <- (newObject Gtk.Widget.Widget) widget
    event' <- (newPtr Gdk.EventKey.EventKey) event
    result <- gi'cb  widget' event'
    maybeReleaseFunPtr gi'funptrptr
    let result' = (fromIntegral . fromEnum) result
    return result'


-- callback WidgetClassHierarchyChangedFieldCallback
{- Callable
  { returnType = Nothing
  , returnMayBeNull = False
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , args =
      [ Arg
          { argCName = "widget"
          , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "previous_toplevel"
          , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_WidgetClassHierarchyChangedFieldCallback =
    Ptr Gtk.Widget.Widget ->
    Ptr Gtk.Widget.Widget ->
    IO ()

-- Args: [ Arg
--           { argCName = "widget"
--           , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "previous_toplevel"
--           , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Nothing
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_WidgetClassHierarchyChangedFieldCallback :: FunPtr C_WidgetClassHierarchyChangedFieldCallback -> C_WidgetClassHierarchyChangedFieldCallback

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_WidgetClassHierarchyChangedFieldCallback ::
    (B.CallStack.HasCallStack, MonadIO m, Gtk.Widget.IsWidget a, Gtk.Widget.IsWidget b) =>
    FunPtr C_WidgetClassHierarchyChangedFieldCallback
    -> a
    -> b
    -> m ()
dynamic_WidgetClassHierarchyChangedFieldCallback __funPtr widget previousToplevel = liftIO $ do
    widget' <- unsafeManagedPtrCastPtr widget
    previousToplevel' <- unsafeManagedPtrCastPtr previousToplevel
    (__dynamic_C_WidgetClassHierarchyChangedFieldCallback __funPtr) widget' previousToplevel'
    touchManagedPtr widget
    touchManagedPtr previousToplevel
    return ()

-- | Generate a function pointer callable from C code, from a `C_WidgetClassHierarchyChangedFieldCallback`.
foreign import ccall "wrapper"
    mk_WidgetClassHierarchyChangedFieldCallback :: C_WidgetClassHierarchyChangedFieldCallback -> IO (FunPtr C_WidgetClassHierarchyChangedFieldCallback)

-- | /No description available in the introspection data./
type WidgetClassHierarchyChangedFieldCallback =
    Gtk.Widget.Widget
    -> Gtk.Widget.Widget
    -> IO ()

-- | A convenience synonym for @`Nothing` :: `Maybe` `WidgetClassHierarchyChangedFieldCallback`@.
noWidgetClassHierarchyChangedFieldCallback :: Maybe WidgetClassHierarchyChangedFieldCallback
noWidgetClassHierarchyChangedFieldCallback = Nothing

-- | Wrap the callback into a `GClosure`.
genClosure_WidgetClassHierarchyChangedFieldCallback :: MonadIO m => WidgetClassHierarchyChangedFieldCallback -> m (GClosure C_WidgetClassHierarchyChangedFieldCallback)
genClosure_WidgetClassHierarchyChangedFieldCallback cb = liftIO $ do
    let cb' = wrap_WidgetClassHierarchyChangedFieldCallback Nothing cb
    mk_WidgetClassHierarchyChangedFieldCallback cb' >>= B.GClosure.newGClosure


-- | Wrap a `WidgetClassHierarchyChangedFieldCallback` into a `C_WidgetClassHierarchyChangedFieldCallback`.
wrap_WidgetClassHierarchyChangedFieldCallback :: 
    Maybe (Ptr (FunPtr C_WidgetClassHierarchyChangedFieldCallback)) ->
    WidgetClassHierarchyChangedFieldCallback ->
    C_WidgetClassHierarchyChangedFieldCallback
wrap_WidgetClassHierarchyChangedFieldCallback gi'funptrptr gi'cb widget previousToplevel = do
    widget' <- (newObject Gtk.Widget.Widget) widget
    previousToplevel' <- (newObject Gtk.Widget.Widget) previousToplevel
    gi'cb  widget' previousToplevel'
    maybeReleaseFunPtr gi'funptrptr


-- callback WidgetClassHideFieldCallback
{- Callable
  { returnType = Nothing
  , returnMayBeNull = False
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , args =
      [ Arg
          { argCName = "widget"
          , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText = Just "a #GtkWidget" , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_WidgetClassHideFieldCallback =
    Ptr Gtk.Widget.Widget ->
    IO ()

-- Args: [ Arg
--           { argCName = "widget"
--           , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "a #GtkWidget" , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Nothing
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_WidgetClassHideFieldCallback :: FunPtr C_WidgetClassHideFieldCallback -> C_WidgetClassHideFieldCallback

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_WidgetClassHideFieldCallback ::
    (B.CallStack.HasCallStack, MonadIO m, Gtk.Widget.IsWidget a) =>
    FunPtr C_WidgetClassHideFieldCallback
    -> a
    -- ^ /@widget@/: a t'GI.Gtk.Objects.Widget.Widget'
    -> m ()
dynamic_WidgetClassHideFieldCallback __funPtr widget = liftIO $ do
    widget' <- unsafeManagedPtrCastPtr widget
    (__dynamic_C_WidgetClassHideFieldCallback __funPtr) widget'
    touchManagedPtr widget
    return ()

-- | Generate a function pointer callable from C code, from a `C_WidgetClassHideFieldCallback`.
foreign import ccall "wrapper"
    mk_WidgetClassHideFieldCallback :: C_WidgetClassHideFieldCallback -> IO (FunPtr C_WidgetClassHideFieldCallback)

-- | /No description available in the introspection data./
type WidgetClassHideFieldCallback =
    Gtk.Widget.Widget
    -- ^ /@widget@/: a t'GI.Gtk.Objects.Widget.Widget'
    -> IO ()

-- | A convenience synonym for @`Nothing` :: `Maybe` `WidgetClassHideFieldCallback`@.
noWidgetClassHideFieldCallback :: Maybe WidgetClassHideFieldCallback
noWidgetClassHideFieldCallback = Nothing

-- | Wrap the callback into a `GClosure`.
genClosure_WidgetClassHideFieldCallback :: MonadIO m => WidgetClassHideFieldCallback -> m (GClosure C_WidgetClassHideFieldCallback)
genClosure_WidgetClassHideFieldCallback cb = liftIO $ do
    let cb' = wrap_WidgetClassHideFieldCallback Nothing cb
    mk_WidgetClassHideFieldCallback cb' >>= B.GClosure.newGClosure


-- | Wrap a `WidgetClassHideFieldCallback` into a `C_WidgetClassHideFieldCallback`.
wrap_WidgetClassHideFieldCallback :: 
    Maybe (Ptr (FunPtr C_WidgetClassHideFieldCallback)) ->
    WidgetClassHideFieldCallback ->
    C_WidgetClassHideFieldCallback
wrap_WidgetClassHideFieldCallback gi'funptrptr gi'cb widget = do
    widget' <- (newObject Gtk.Widget.Widget) widget
    gi'cb  widget'
    maybeReleaseFunPtr gi'funptrptr


-- callback WidgetClassGrabNotifyFieldCallback
{- Callable
  { returnType = Nothing
  , returnMayBeNull = False
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , args =
      [ Arg
          { argCName = "widget"
          , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "was_grabbed"
          , argType = TBasicType TBoolean
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_WidgetClassGrabNotifyFieldCallback =
    Ptr Gtk.Widget.Widget ->
    CInt ->
    IO ()

-- Args: [ Arg
--           { argCName = "widget"
--           , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "was_grabbed"
--           , argType = TBasicType TBoolean
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Nothing
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_WidgetClassGrabNotifyFieldCallback :: FunPtr C_WidgetClassGrabNotifyFieldCallback -> C_WidgetClassGrabNotifyFieldCallback

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_WidgetClassGrabNotifyFieldCallback ::
    (B.CallStack.HasCallStack, MonadIO m, Gtk.Widget.IsWidget a) =>
    FunPtr C_WidgetClassGrabNotifyFieldCallback
    -> a
    -> Bool
    -> m ()
dynamic_WidgetClassGrabNotifyFieldCallback __funPtr widget wasGrabbed = liftIO $ do
    widget' <- unsafeManagedPtrCastPtr widget
    let wasGrabbed' = (fromIntegral . fromEnum) wasGrabbed
    (__dynamic_C_WidgetClassGrabNotifyFieldCallback __funPtr) widget' wasGrabbed'
    touchManagedPtr widget
    return ()

-- | Generate a function pointer callable from C code, from a `C_WidgetClassGrabNotifyFieldCallback`.
foreign import ccall "wrapper"
    mk_WidgetClassGrabNotifyFieldCallback :: C_WidgetClassGrabNotifyFieldCallback -> IO (FunPtr C_WidgetClassGrabNotifyFieldCallback)

-- | /No description available in the introspection data./
type WidgetClassGrabNotifyFieldCallback =
    Gtk.Widget.Widget
    -> Bool
    -> IO ()

-- | A convenience synonym for @`Nothing` :: `Maybe` `WidgetClassGrabNotifyFieldCallback`@.
noWidgetClassGrabNotifyFieldCallback :: Maybe WidgetClassGrabNotifyFieldCallback
noWidgetClassGrabNotifyFieldCallback = Nothing

-- | Wrap the callback into a `GClosure`.
genClosure_WidgetClassGrabNotifyFieldCallback :: MonadIO m => WidgetClassGrabNotifyFieldCallback -> m (GClosure C_WidgetClassGrabNotifyFieldCallback)
genClosure_WidgetClassGrabNotifyFieldCallback cb = liftIO $ do
    let cb' = wrap_WidgetClassGrabNotifyFieldCallback Nothing cb
    mk_WidgetClassGrabNotifyFieldCallback cb' >>= B.GClosure.newGClosure


-- | Wrap a `WidgetClassGrabNotifyFieldCallback` into a `C_WidgetClassGrabNotifyFieldCallback`.
wrap_WidgetClassGrabNotifyFieldCallback :: 
    Maybe (Ptr (FunPtr C_WidgetClassGrabNotifyFieldCallback)) ->
    WidgetClassGrabNotifyFieldCallback ->
    C_WidgetClassGrabNotifyFieldCallback
wrap_WidgetClassGrabNotifyFieldCallback gi'funptrptr gi'cb widget wasGrabbed = do
    widget' <- (newObject Gtk.Widget.Widget) widget
    let wasGrabbed' = (/= 0) wasGrabbed
    gi'cb  widget' wasGrabbed'
    maybeReleaseFunPtr gi'funptrptr


-- callback WidgetClassGrabFocusFieldCallback
{- Callable
  { returnType = Nothing
  , returnMayBeNull = False
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , args =
      [ Arg
          { argCName = "widget"
          , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText = Just "a #GtkWidget" , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_WidgetClassGrabFocusFieldCallback =
    Ptr Gtk.Widget.Widget ->
    IO ()

-- Args: [ Arg
--           { argCName = "widget"
--           , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "a #GtkWidget" , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Nothing
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_WidgetClassGrabFocusFieldCallback :: FunPtr C_WidgetClassGrabFocusFieldCallback -> C_WidgetClassGrabFocusFieldCallback

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_WidgetClassGrabFocusFieldCallback ::
    (B.CallStack.HasCallStack, MonadIO m, Gtk.Widget.IsWidget a) =>
    FunPtr C_WidgetClassGrabFocusFieldCallback
    -> a
    -- ^ /@widget@/: a t'GI.Gtk.Objects.Widget.Widget'
    -> m ()
dynamic_WidgetClassGrabFocusFieldCallback __funPtr widget = liftIO $ do
    widget' <- unsafeManagedPtrCastPtr widget
    (__dynamic_C_WidgetClassGrabFocusFieldCallback __funPtr) widget'
    touchManagedPtr widget
    return ()

-- | Generate a function pointer callable from C code, from a `C_WidgetClassGrabFocusFieldCallback`.
foreign import ccall "wrapper"
    mk_WidgetClassGrabFocusFieldCallback :: C_WidgetClassGrabFocusFieldCallback -> IO (FunPtr C_WidgetClassGrabFocusFieldCallback)

-- | /No description available in the introspection data./
type WidgetClassGrabFocusFieldCallback =
    Gtk.Widget.Widget
    -- ^ /@widget@/: a t'GI.Gtk.Objects.Widget.Widget'
    -> IO ()

-- | A convenience synonym for @`Nothing` :: `Maybe` `WidgetClassGrabFocusFieldCallback`@.
noWidgetClassGrabFocusFieldCallback :: Maybe WidgetClassGrabFocusFieldCallback
noWidgetClassGrabFocusFieldCallback = Nothing

-- | Wrap the callback into a `GClosure`.
genClosure_WidgetClassGrabFocusFieldCallback :: MonadIO m => WidgetClassGrabFocusFieldCallback -> m (GClosure C_WidgetClassGrabFocusFieldCallback)
genClosure_WidgetClassGrabFocusFieldCallback cb = liftIO $ do
    let cb' = wrap_WidgetClassGrabFocusFieldCallback Nothing cb
    mk_WidgetClassGrabFocusFieldCallback cb' >>= B.GClosure.newGClosure


-- | Wrap a `WidgetClassGrabFocusFieldCallback` into a `C_WidgetClassGrabFocusFieldCallback`.
wrap_WidgetClassGrabFocusFieldCallback :: 
    Maybe (Ptr (FunPtr C_WidgetClassGrabFocusFieldCallback)) ->
    WidgetClassGrabFocusFieldCallback ->
    C_WidgetClassGrabFocusFieldCallback
wrap_WidgetClassGrabFocusFieldCallback gi'funptrptr gi'cb widget = do
    widget' <- (newObject Gtk.Widget.Widget) widget
    gi'cb  widget'
    maybeReleaseFunPtr gi'funptrptr


-- callback WidgetClassGrabBrokenEventFieldCallback
{- Callable
  { returnType = Just (TBasicType TBoolean)
  , returnMayBeNull = False
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , args =
      [ Arg
          { argCName = "widget"
          , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "event"
          , argType =
              TInterface Name { namespace = "Gdk" , name = "EventGrabBroken" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_WidgetClassGrabBrokenEventFieldCallback =
    Ptr Gtk.Widget.Widget ->
    Ptr Gdk.EventGrabBroken.EventGrabBroken ->
    IO CInt

-- Args: [ Arg
--           { argCName = "widget"
--           , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "event"
--           , argType =
--               TInterface Name { namespace = "Gdk" , name = "EventGrabBroken" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Just (TBasicType TBoolean)
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_WidgetClassGrabBrokenEventFieldCallback :: FunPtr C_WidgetClassGrabBrokenEventFieldCallback -> C_WidgetClassGrabBrokenEventFieldCallback

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_WidgetClassGrabBrokenEventFieldCallback ::
    (B.CallStack.HasCallStack, MonadIO m, Gtk.Widget.IsWidget a) =>
    FunPtr C_WidgetClassGrabBrokenEventFieldCallback
    -> a
    -> Gdk.EventGrabBroken.EventGrabBroken
    -> m Bool
dynamic_WidgetClassGrabBrokenEventFieldCallback __funPtr widget event = liftIO $ do
    widget' <- unsafeManagedPtrCastPtr widget
    event' <- unsafeManagedPtrGetPtr event
    result <- (__dynamic_C_WidgetClassGrabBrokenEventFieldCallback __funPtr) widget' event'
    let result' = (/= 0) result
    touchManagedPtr widget
    touchManagedPtr event
    return result'

-- | Generate a function pointer callable from C code, from a `C_WidgetClassGrabBrokenEventFieldCallback`.
foreign import ccall "wrapper"
    mk_WidgetClassGrabBrokenEventFieldCallback :: C_WidgetClassGrabBrokenEventFieldCallback -> IO (FunPtr C_WidgetClassGrabBrokenEventFieldCallback)

-- | /No description available in the introspection data./
type WidgetClassGrabBrokenEventFieldCallback =
    Gtk.Widget.Widget
    -> Gdk.EventGrabBroken.EventGrabBroken
    -> IO Bool

-- | A convenience synonym for @`Nothing` :: `Maybe` `WidgetClassGrabBrokenEventFieldCallback`@.
noWidgetClassGrabBrokenEventFieldCallback :: Maybe WidgetClassGrabBrokenEventFieldCallback
noWidgetClassGrabBrokenEventFieldCallback = Nothing

-- | Wrap the callback into a `GClosure`.
genClosure_WidgetClassGrabBrokenEventFieldCallback :: MonadIO m => WidgetClassGrabBrokenEventFieldCallback -> m (GClosure C_WidgetClassGrabBrokenEventFieldCallback)
genClosure_WidgetClassGrabBrokenEventFieldCallback cb = liftIO $ do
    let cb' = wrap_WidgetClassGrabBrokenEventFieldCallback Nothing cb
    mk_WidgetClassGrabBrokenEventFieldCallback cb' >>= B.GClosure.newGClosure


-- | Wrap a `WidgetClassGrabBrokenEventFieldCallback` into a `C_WidgetClassGrabBrokenEventFieldCallback`.
wrap_WidgetClassGrabBrokenEventFieldCallback :: 
    Maybe (Ptr (FunPtr C_WidgetClassGrabBrokenEventFieldCallback)) ->
    WidgetClassGrabBrokenEventFieldCallback ->
    C_WidgetClassGrabBrokenEventFieldCallback
wrap_WidgetClassGrabBrokenEventFieldCallback gi'funptrptr gi'cb widget event = do
    widget' <- (newObject Gtk.Widget.Widget) widget
    event' <- (newPtr Gdk.EventGrabBroken.EventGrabBroken) event
    result <- gi'cb  widget' event'
    maybeReleaseFunPtr gi'funptrptr
    let result' = (fromIntegral . fromEnum) result
    return result'


-- callback WidgetClassGetRequestModeFieldCallback
{- Callable
  { returnType =
      Just
        (TInterface Name { namespace = "Gtk" , name = "SizeRequestMode" })
  , returnMayBeNull = False
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation
        { rawDocText = Just "The #GtkSizeRequestMode preferred by @widget."
        , sinceVersion = Nothing
        }
  , args =
      [ Arg
          { argCName = "widget"
          , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText = Just "a #GtkWidget instance"
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_WidgetClassGetRequestModeFieldCallback =
    Ptr Gtk.Widget.Widget ->
    IO CUInt

-- Args: [ Arg
--           { argCName = "widget"
--           , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "a #GtkWidget instance"
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Just
--               (TInterface Name { namespace = "Gtk" , name = "SizeRequestMode" })
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_WidgetClassGetRequestModeFieldCallback :: FunPtr C_WidgetClassGetRequestModeFieldCallback -> C_WidgetClassGetRequestModeFieldCallback

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_WidgetClassGetRequestModeFieldCallback ::
    (B.CallStack.HasCallStack, MonadIO m, Gtk.Widget.IsWidget a) =>
    FunPtr C_WidgetClassGetRequestModeFieldCallback
    -> a
    -- ^ /@widget@/: a t'GI.Gtk.Objects.Widget.Widget' instance
    -> m Gtk.Enums.SizeRequestMode
    -- ^ __Returns:__ The t'GI.Gtk.Enums.SizeRequestMode' preferred by /@widget@/.
dynamic_WidgetClassGetRequestModeFieldCallback __funPtr widget = liftIO $ do
    widget' <- unsafeManagedPtrCastPtr widget
    result <- (__dynamic_C_WidgetClassGetRequestModeFieldCallback __funPtr) widget'
    let result' = (toEnum . fromIntegral) result
    touchManagedPtr widget
    return result'

-- | Generate a function pointer callable from C code, from a `C_WidgetClassGetRequestModeFieldCallback`.
foreign import ccall "wrapper"
    mk_WidgetClassGetRequestModeFieldCallback :: C_WidgetClassGetRequestModeFieldCallback -> IO (FunPtr C_WidgetClassGetRequestModeFieldCallback)

-- | /No description available in the introspection data./
type WidgetClassGetRequestModeFieldCallback =
    Gtk.Widget.Widget
    -- ^ /@widget@/: a t'GI.Gtk.Objects.Widget.Widget' instance
    -> IO Gtk.Enums.SizeRequestMode
    -- ^ __Returns:__ The t'GI.Gtk.Enums.SizeRequestMode' preferred by /@widget@/.

-- | A convenience synonym for @`Nothing` :: `Maybe` `WidgetClassGetRequestModeFieldCallback`@.
noWidgetClassGetRequestModeFieldCallback :: Maybe WidgetClassGetRequestModeFieldCallback
noWidgetClassGetRequestModeFieldCallback = Nothing

-- | Wrap the callback into a `GClosure`.
genClosure_WidgetClassGetRequestModeFieldCallback :: MonadIO m => WidgetClassGetRequestModeFieldCallback -> m (GClosure C_WidgetClassGetRequestModeFieldCallback)
genClosure_WidgetClassGetRequestModeFieldCallback cb = liftIO $ do
    let cb' = wrap_WidgetClassGetRequestModeFieldCallback Nothing cb
    mk_WidgetClassGetRequestModeFieldCallback cb' >>= B.GClosure.newGClosure


-- | Wrap a `WidgetClassGetRequestModeFieldCallback` into a `C_WidgetClassGetRequestModeFieldCallback`.
wrap_WidgetClassGetRequestModeFieldCallback :: 
    Maybe (Ptr (FunPtr C_WidgetClassGetRequestModeFieldCallback)) ->
    WidgetClassGetRequestModeFieldCallback ->
    C_WidgetClassGetRequestModeFieldCallback
wrap_WidgetClassGetRequestModeFieldCallback gi'funptrptr gi'cb widget = do
    widget' <- (newObject Gtk.Widget.Widget) widget
    result <- gi'cb  widget'
    maybeReleaseFunPtr gi'funptrptr
    let result' = (fromIntegral . fromEnum) result
    return result'


-- callback WidgetClassGetPreferredWidthForHeightFieldCallback
{- Callable
  { returnType = Nothing
  , returnMayBeNull = False
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , args =
      [ Arg
          { argCName = "widget"
          , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText = Just "a #GtkWidget instance"
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "height"
          , argType = TBasicType TInt
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText = Just "the height which is available for allocation"
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "minimum_width"
          , argType = TBasicType TInt
          , direction = DirectionOut
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText =
                    Just "location for storing the minimum width, or %NULL"
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferEverything
          }
      , Arg
          { argCName = "natural_width"
          , argType = TBasicType TInt
          , direction = DirectionOut
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText =
                    Just "location for storing the natural width, or %NULL"
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferEverything
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_WidgetClassGetPreferredWidthForHeightFieldCallback =
    Ptr Gtk.Widget.Widget ->
    Int32 ->
    Ptr Int32 ->
    Ptr Int32 ->
    IO ()

-- Args: [ Arg
--           { argCName = "widget"
--           , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "a #GtkWidget instance"
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "height"
--           , argType = TBasicType TInt
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "the height which is available for allocation"
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "minimum_width"
--           , argType = TBasicType TInt
--           , direction = DirectionOut
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText =
--                     Just "location for storing the minimum width, or %NULL"
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferEverything
--           }
--       , Arg
--           { argCName = "natural_width"
--           , argType = TBasicType TInt
--           , direction = DirectionOut
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText =
--                     Just "location for storing the natural width, or %NULL"
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferEverything
--           }
--       ]
-- Lengths: []
-- returnType: Nothing
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_WidgetClassGetPreferredWidthForHeightFieldCallback :: FunPtr C_WidgetClassGetPreferredWidthForHeightFieldCallback -> C_WidgetClassGetPreferredWidthForHeightFieldCallback

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_WidgetClassGetPreferredWidthForHeightFieldCallback ::
    (B.CallStack.HasCallStack, MonadIO m, Gtk.Widget.IsWidget a) =>
    FunPtr C_WidgetClassGetPreferredWidthForHeightFieldCallback
    -> a
    -- ^ /@widget@/: a t'GI.Gtk.Objects.Widget.Widget' instance
    -> Int32
    -- ^ /@height@/: the height which is available for allocation
    -> m ((Int32, Int32))
dynamic_WidgetClassGetPreferredWidthForHeightFieldCallback __funPtr widget height = liftIO $ do
    widget' <- unsafeManagedPtrCastPtr widget
    minimumWidth <- allocMem :: IO (Ptr Int32)
    naturalWidth <- allocMem :: IO (Ptr Int32)
    (__dynamic_C_WidgetClassGetPreferredWidthForHeightFieldCallback __funPtr) widget' height minimumWidth naturalWidth
    minimumWidth' <- peek minimumWidth
    naturalWidth' <- peek naturalWidth
    touchManagedPtr widget
    freeMem minimumWidth
    freeMem naturalWidth
    return (minimumWidth', naturalWidth')

-- | Generate a function pointer callable from C code, from a `C_WidgetClassGetPreferredWidthForHeightFieldCallback`.
foreign import ccall "wrapper"
    mk_WidgetClassGetPreferredWidthForHeightFieldCallback :: C_WidgetClassGetPreferredWidthForHeightFieldCallback -> IO (FunPtr C_WidgetClassGetPreferredWidthForHeightFieldCallback)

-- | /No description available in the introspection data./
type WidgetClassGetPreferredWidthForHeightFieldCallback =
    Gtk.Widget.Widget
    -- ^ /@widget@/: a t'GI.Gtk.Objects.Widget.Widget' instance
    -> Int32
    -- ^ /@height@/: the height which is available for allocation
    -> IO ((Int32, Int32))

-- | A convenience synonym for @`Nothing` :: `Maybe` `WidgetClassGetPreferredWidthForHeightFieldCallback`@.
noWidgetClassGetPreferredWidthForHeightFieldCallback :: Maybe WidgetClassGetPreferredWidthForHeightFieldCallback
noWidgetClassGetPreferredWidthForHeightFieldCallback = Nothing

-- | Wrap the callback into a `GClosure`.
genClosure_WidgetClassGetPreferredWidthForHeightFieldCallback :: MonadIO m => WidgetClassGetPreferredWidthForHeightFieldCallback -> m (GClosure C_WidgetClassGetPreferredWidthForHeightFieldCallback)
genClosure_WidgetClassGetPreferredWidthForHeightFieldCallback cb = liftIO $ do
    let cb' = wrap_WidgetClassGetPreferredWidthForHeightFieldCallback Nothing cb
    mk_WidgetClassGetPreferredWidthForHeightFieldCallback cb' >>= B.GClosure.newGClosure


-- | Wrap a `WidgetClassGetPreferredWidthForHeightFieldCallback` into a `C_WidgetClassGetPreferredWidthForHeightFieldCallback`.
wrap_WidgetClassGetPreferredWidthForHeightFieldCallback :: 
    Maybe (Ptr (FunPtr C_WidgetClassGetPreferredWidthForHeightFieldCallback)) ->
    WidgetClassGetPreferredWidthForHeightFieldCallback ->
    C_WidgetClassGetPreferredWidthForHeightFieldCallback
wrap_WidgetClassGetPreferredWidthForHeightFieldCallback gi'funptrptr gi'cb widget height minimumWidth naturalWidth = do
    widget' <- (newObject Gtk.Widget.Widget) widget
    (outminimumWidth, outnaturalWidth) <- gi'cb  widget' height
    poke minimumWidth outminimumWidth
    poke naturalWidth outnaturalWidth
    maybeReleaseFunPtr gi'funptrptr


-- callback WidgetClassGetPreferredWidthFieldCallback
{- Callable
  { returnType = Nothing
  , returnMayBeNull = False
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , args =
      [ Arg
          { argCName = "widget"
          , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText = Just "a #GtkWidget instance"
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "minimum_width"
          , argType = TBasicType TInt
          , direction = DirectionOut
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText = Just "location to store the minimum width, or %NULL"
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferEverything
          }
      , Arg
          { argCName = "natural_width"
          , argType = TBasicType TInt
          , direction = DirectionOut
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText = Just "location to store the natural width, or %NULL"
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferEverything
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_WidgetClassGetPreferredWidthFieldCallback =
    Ptr Gtk.Widget.Widget ->
    Ptr Int32 ->
    Ptr Int32 ->
    IO ()

-- Args: [ Arg
--           { argCName = "widget"
--           , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "a #GtkWidget instance"
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "minimum_width"
--           , argType = TBasicType TInt
--           , direction = DirectionOut
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "location to store the minimum width, or %NULL"
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferEverything
--           }
--       , Arg
--           { argCName = "natural_width"
--           , argType = TBasicType TInt
--           , direction = DirectionOut
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "location to store the natural width, or %NULL"
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferEverything
--           }
--       ]
-- Lengths: []
-- returnType: Nothing
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_WidgetClassGetPreferredWidthFieldCallback :: FunPtr C_WidgetClassGetPreferredWidthFieldCallback -> C_WidgetClassGetPreferredWidthFieldCallback

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_WidgetClassGetPreferredWidthFieldCallback ::
    (B.CallStack.HasCallStack, MonadIO m, Gtk.Widget.IsWidget a) =>
    FunPtr C_WidgetClassGetPreferredWidthFieldCallback
    -> a
    -- ^ /@widget@/: a t'GI.Gtk.Objects.Widget.Widget' instance
    -> m ((Int32, Int32))
dynamic_WidgetClassGetPreferredWidthFieldCallback __funPtr widget = liftIO $ do
    widget' <- unsafeManagedPtrCastPtr widget
    minimumWidth <- allocMem :: IO (Ptr Int32)
    naturalWidth <- allocMem :: IO (Ptr Int32)
    (__dynamic_C_WidgetClassGetPreferredWidthFieldCallback __funPtr) widget' minimumWidth naturalWidth
    minimumWidth' <- peek minimumWidth
    naturalWidth' <- peek naturalWidth
    touchManagedPtr widget
    freeMem minimumWidth
    freeMem naturalWidth
    return (minimumWidth', naturalWidth')

-- | Generate a function pointer callable from C code, from a `C_WidgetClassGetPreferredWidthFieldCallback`.
foreign import ccall "wrapper"
    mk_WidgetClassGetPreferredWidthFieldCallback :: C_WidgetClassGetPreferredWidthFieldCallback -> IO (FunPtr C_WidgetClassGetPreferredWidthFieldCallback)

-- | /No description available in the introspection data./
type WidgetClassGetPreferredWidthFieldCallback =
    Gtk.Widget.Widget
    -- ^ /@widget@/: a t'GI.Gtk.Objects.Widget.Widget' instance
    -> IO ((Int32, Int32))

-- | A convenience synonym for @`Nothing` :: `Maybe` `WidgetClassGetPreferredWidthFieldCallback`@.
noWidgetClassGetPreferredWidthFieldCallback :: Maybe WidgetClassGetPreferredWidthFieldCallback
noWidgetClassGetPreferredWidthFieldCallback = Nothing

-- | Wrap the callback into a `GClosure`.
genClosure_WidgetClassGetPreferredWidthFieldCallback :: MonadIO m => WidgetClassGetPreferredWidthFieldCallback -> m (GClosure C_WidgetClassGetPreferredWidthFieldCallback)
genClosure_WidgetClassGetPreferredWidthFieldCallback cb = liftIO $ do
    let cb' = wrap_WidgetClassGetPreferredWidthFieldCallback Nothing cb
    mk_WidgetClassGetPreferredWidthFieldCallback cb' >>= B.GClosure.newGClosure


-- | Wrap a `WidgetClassGetPreferredWidthFieldCallback` into a `C_WidgetClassGetPreferredWidthFieldCallback`.
wrap_WidgetClassGetPreferredWidthFieldCallback :: 
    Maybe (Ptr (FunPtr C_WidgetClassGetPreferredWidthFieldCallback)) ->
    WidgetClassGetPreferredWidthFieldCallback ->
    C_WidgetClassGetPreferredWidthFieldCallback
wrap_WidgetClassGetPreferredWidthFieldCallback gi'funptrptr gi'cb widget minimumWidth naturalWidth = do
    widget' <- (newObject Gtk.Widget.Widget) widget
    (outminimumWidth, outnaturalWidth) <- gi'cb  widget'
    poke minimumWidth outminimumWidth
    poke naturalWidth outnaturalWidth
    maybeReleaseFunPtr gi'funptrptr


-- callback WidgetClassGetPreferredHeightForWidthFieldCallback
{- Callable
  { returnType = Nothing
  , returnMayBeNull = False
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , args =
      [ Arg
          { argCName = "widget"
          , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText = Just "a #GtkWidget instance"
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "width"
          , argType = TBasicType TInt
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText = Just "the width which is available for allocation"
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "minimum_height"
          , argType = TBasicType TInt
          , direction = DirectionOut
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText =
                    Just "location for storing the minimum height, or %NULL"
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferEverything
          }
      , Arg
          { argCName = "natural_height"
          , argType = TBasicType TInt
          , direction = DirectionOut
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText =
                    Just "location for storing the natural height, or %NULL"
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferEverything
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_WidgetClassGetPreferredHeightForWidthFieldCallback =
    Ptr Gtk.Widget.Widget ->
    Int32 ->
    Ptr Int32 ->
    Ptr Int32 ->
    IO ()

-- Args: [ Arg
--           { argCName = "widget"
--           , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "a #GtkWidget instance"
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "width"
--           , argType = TBasicType TInt
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "the width which is available for allocation"
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "minimum_height"
--           , argType = TBasicType TInt
--           , direction = DirectionOut
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText =
--                     Just "location for storing the minimum height, or %NULL"
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferEverything
--           }
--       , Arg
--           { argCName = "natural_height"
--           , argType = TBasicType TInt
--           , direction = DirectionOut
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText =
--                     Just "location for storing the natural height, or %NULL"
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferEverything
--           }
--       ]
-- Lengths: []
-- returnType: Nothing
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_WidgetClassGetPreferredHeightForWidthFieldCallback :: FunPtr C_WidgetClassGetPreferredHeightForWidthFieldCallback -> C_WidgetClassGetPreferredHeightForWidthFieldCallback

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_WidgetClassGetPreferredHeightForWidthFieldCallback ::
    (B.CallStack.HasCallStack, MonadIO m, Gtk.Widget.IsWidget a) =>
    FunPtr C_WidgetClassGetPreferredHeightForWidthFieldCallback
    -> a
    -- ^ /@widget@/: a t'GI.Gtk.Objects.Widget.Widget' instance
    -> Int32
    -- ^ /@width@/: the width which is available for allocation
    -> m ((Int32, Int32))
dynamic_WidgetClassGetPreferredHeightForWidthFieldCallback __funPtr widget width = liftIO $ do
    widget' <- unsafeManagedPtrCastPtr widget
    minimumHeight <- allocMem :: IO (Ptr Int32)
    naturalHeight <- allocMem :: IO (Ptr Int32)
    (__dynamic_C_WidgetClassGetPreferredHeightForWidthFieldCallback __funPtr) widget' width minimumHeight naturalHeight
    minimumHeight' <- peek minimumHeight
    naturalHeight' <- peek naturalHeight
    touchManagedPtr widget
    freeMem minimumHeight
    freeMem naturalHeight
    return (minimumHeight', naturalHeight')

-- | Generate a function pointer callable from C code, from a `C_WidgetClassGetPreferredHeightForWidthFieldCallback`.
foreign import ccall "wrapper"
    mk_WidgetClassGetPreferredHeightForWidthFieldCallback :: C_WidgetClassGetPreferredHeightForWidthFieldCallback -> IO (FunPtr C_WidgetClassGetPreferredHeightForWidthFieldCallback)

-- | /No description available in the introspection data./
type WidgetClassGetPreferredHeightForWidthFieldCallback =
    Gtk.Widget.Widget
    -- ^ /@widget@/: a t'GI.Gtk.Objects.Widget.Widget' instance
    -> Int32
    -- ^ /@width@/: the width which is available for allocation
    -> IO ((Int32, Int32))

-- | A convenience synonym for @`Nothing` :: `Maybe` `WidgetClassGetPreferredHeightForWidthFieldCallback`@.
noWidgetClassGetPreferredHeightForWidthFieldCallback :: Maybe WidgetClassGetPreferredHeightForWidthFieldCallback
noWidgetClassGetPreferredHeightForWidthFieldCallback = Nothing

-- | Wrap the callback into a `GClosure`.
genClosure_WidgetClassGetPreferredHeightForWidthFieldCallback :: MonadIO m => WidgetClassGetPreferredHeightForWidthFieldCallback -> m (GClosure C_WidgetClassGetPreferredHeightForWidthFieldCallback)
genClosure_WidgetClassGetPreferredHeightForWidthFieldCallback cb = liftIO $ do
    let cb' = wrap_WidgetClassGetPreferredHeightForWidthFieldCallback Nothing cb
    mk_WidgetClassGetPreferredHeightForWidthFieldCallback cb' >>= B.GClosure.newGClosure


-- | Wrap a `WidgetClassGetPreferredHeightForWidthFieldCallback` into a `C_WidgetClassGetPreferredHeightForWidthFieldCallback`.
wrap_WidgetClassGetPreferredHeightForWidthFieldCallback :: 
    Maybe (Ptr (FunPtr C_WidgetClassGetPreferredHeightForWidthFieldCallback)) ->
    WidgetClassGetPreferredHeightForWidthFieldCallback ->
    C_WidgetClassGetPreferredHeightForWidthFieldCallback
wrap_WidgetClassGetPreferredHeightForWidthFieldCallback gi'funptrptr gi'cb widget width minimumHeight naturalHeight = do
    widget' <- (newObject Gtk.Widget.Widget) widget
    (outminimumHeight, outnaturalHeight) <- gi'cb  widget' width
    poke minimumHeight outminimumHeight
    poke naturalHeight outnaturalHeight
    maybeReleaseFunPtr gi'funptrptr


-- callback WidgetClassGetPreferredHeightFieldCallback
{- Callable
  { returnType = Nothing
  , returnMayBeNull = False
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , args =
      [ Arg
          { argCName = "widget"
          , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText = Just "a #GtkWidget instance"
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "minimum_height"
          , argType = TBasicType TInt
          , direction = DirectionOut
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText =
                    Just "location to store the minimum height, or %NULL"
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferEverything
          }
      , Arg
          { argCName = "natural_height"
          , argType = TBasicType TInt
          , direction = DirectionOut
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText =
                    Just "location to store the natural height, or %NULL"
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferEverything
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_WidgetClassGetPreferredHeightFieldCallback =
    Ptr Gtk.Widget.Widget ->
    Ptr Int32 ->
    Ptr Int32 ->
    IO ()

-- Args: [ Arg
--           { argCName = "widget"
--           , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "a #GtkWidget instance"
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "minimum_height"
--           , argType = TBasicType TInt
--           , direction = DirectionOut
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText =
--                     Just "location to store the minimum height, or %NULL"
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferEverything
--           }
--       , Arg
--           { argCName = "natural_height"
--           , argType = TBasicType TInt
--           , direction = DirectionOut
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText =
--                     Just "location to store the natural height, or %NULL"
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferEverything
--           }
--       ]
-- Lengths: []
-- returnType: Nothing
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_WidgetClassGetPreferredHeightFieldCallback :: FunPtr C_WidgetClassGetPreferredHeightFieldCallback -> C_WidgetClassGetPreferredHeightFieldCallback

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_WidgetClassGetPreferredHeightFieldCallback ::
    (B.CallStack.HasCallStack, MonadIO m, Gtk.Widget.IsWidget a) =>
    FunPtr C_WidgetClassGetPreferredHeightFieldCallback
    -> a
    -- ^ /@widget@/: a t'GI.Gtk.Objects.Widget.Widget' instance
    -> m ((Int32, Int32))
dynamic_WidgetClassGetPreferredHeightFieldCallback __funPtr widget = liftIO $ do
    widget' <- unsafeManagedPtrCastPtr widget
    minimumHeight <- allocMem :: IO (Ptr Int32)
    naturalHeight <- allocMem :: IO (Ptr Int32)
    (__dynamic_C_WidgetClassGetPreferredHeightFieldCallback __funPtr) widget' minimumHeight naturalHeight
    minimumHeight' <- peek minimumHeight
    naturalHeight' <- peek naturalHeight
    touchManagedPtr widget
    freeMem minimumHeight
    freeMem naturalHeight
    return (minimumHeight', naturalHeight')

-- | Generate a function pointer callable from C code, from a `C_WidgetClassGetPreferredHeightFieldCallback`.
foreign import ccall "wrapper"
    mk_WidgetClassGetPreferredHeightFieldCallback :: C_WidgetClassGetPreferredHeightFieldCallback -> IO (FunPtr C_WidgetClassGetPreferredHeightFieldCallback)

-- | /No description available in the introspection data./
type WidgetClassGetPreferredHeightFieldCallback =
    Gtk.Widget.Widget
    -- ^ /@widget@/: a t'GI.Gtk.Objects.Widget.Widget' instance
    -> IO ((Int32, Int32))

-- | A convenience synonym for @`Nothing` :: `Maybe` `WidgetClassGetPreferredHeightFieldCallback`@.
noWidgetClassGetPreferredHeightFieldCallback :: Maybe WidgetClassGetPreferredHeightFieldCallback
noWidgetClassGetPreferredHeightFieldCallback = Nothing

-- | Wrap the callback into a `GClosure`.
genClosure_WidgetClassGetPreferredHeightFieldCallback :: MonadIO m => WidgetClassGetPreferredHeightFieldCallback -> m (GClosure C_WidgetClassGetPreferredHeightFieldCallback)
genClosure_WidgetClassGetPreferredHeightFieldCallback cb = liftIO $ do
    let cb' = wrap_WidgetClassGetPreferredHeightFieldCallback Nothing cb
    mk_WidgetClassGetPreferredHeightFieldCallback cb' >>= B.GClosure.newGClosure


-- | Wrap a `WidgetClassGetPreferredHeightFieldCallback` into a `C_WidgetClassGetPreferredHeightFieldCallback`.
wrap_WidgetClassGetPreferredHeightFieldCallback :: 
    Maybe (Ptr (FunPtr C_WidgetClassGetPreferredHeightFieldCallback)) ->
    WidgetClassGetPreferredHeightFieldCallback ->
    C_WidgetClassGetPreferredHeightFieldCallback
wrap_WidgetClassGetPreferredHeightFieldCallback gi'funptrptr gi'cb widget minimumHeight naturalHeight = do
    widget' <- (newObject Gtk.Widget.Widget) widget
    (outminimumHeight, outnaturalHeight) <- gi'cb  widget'
    poke minimumHeight outminimumHeight
    poke naturalHeight outnaturalHeight
    maybeReleaseFunPtr gi'funptrptr


-- callback WidgetClassGetPreferredHeightAndBaselineForWidthFieldCallback
{- Callable
  { returnType = Nothing
  , returnMayBeNull = False
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , args =
      [ Arg
          { argCName = "widget"
          , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText = Just "a #GtkWidget instance"
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "width"
          , argType = TBasicType TInt
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText =
                    Just "the width which is available for allocation, or -1 if none"
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "minimum_height"
          , argType = TBasicType TInt
          , direction = DirectionOut
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText =
                    Just "location for storing the minimum height, or %NULL"
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferEverything
          }
      , Arg
          { argCName = "natural_height"
          , argType = TBasicType TInt
          , direction = DirectionOut
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText =
                    Just "location for storing the natural height, or %NULL"
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferEverything
          }
      , Arg
          { argCName = "minimum_baseline"
          , argType = TBasicType TInt
          , direction = DirectionOut
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText =
                    Just
                      "location for storing the baseline for the minimum height, or %NULL"
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferEverything
          }
      , Arg
          { argCName = "natural_baseline"
          , argType = TBasicType TInt
          , direction = DirectionOut
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText =
                    Just
                      "location for storing the baseline for the natural height, or %NULL"
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferEverything
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_WidgetClassGetPreferredHeightAndBaselineForWidthFieldCallback =
    Ptr Gtk.Widget.Widget ->
    Int32 ->
    Ptr Int32 ->
    Ptr Int32 ->
    Ptr Int32 ->
    Ptr Int32 ->
    IO ()

-- Args: [ Arg
--           { argCName = "widget"
--           , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "a #GtkWidget instance"
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "width"
--           , argType = TBasicType TInt
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText =
--                     Just "the width which is available for allocation, or -1 if none"
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "minimum_height"
--           , argType = TBasicType TInt
--           , direction = DirectionOut
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText =
--                     Just "location for storing the minimum height, or %NULL"
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferEverything
--           }
--       , Arg
--           { argCName = "natural_height"
--           , argType = TBasicType TInt
--           , direction = DirectionOut
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText =
--                     Just "location for storing the natural height, or %NULL"
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferEverything
--           }
--       , Arg
--           { argCName = "minimum_baseline"
--           , argType = TBasicType TInt
--           , direction = DirectionOut
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText =
--                     Just
--                       "location for storing the baseline for the minimum height, or %NULL"
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferEverything
--           }
--       , Arg
--           { argCName = "natural_baseline"
--           , argType = TBasicType TInt
--           , direction = DirectionOut
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText =
--                     Just
--                       "location for storing the baseline for the natural height, or %NULL"
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferEverything
--           }
--       ]
-- Lengths: []
-- returnType: Nothing
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_WidgetClassGetPreferredHeightAndBaselineForWidthFieldCallback :: FunPtr C_WidgetClassGetPreferredHeightAndBaselineForWidthFieldCallback -> C_WidgetClassGetPreferredHeightAndBaselineForWidthFieldCallback

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_WidgetClassGetPreferredHeightAndBaselineForWidthFieldCallback ::
    (B.CallStack.HasCallStack, MonadIO m, Gtk.Widget.IsWidget a) =>
    FunPtr C_WidgetClassGetPreferredHeightAndBaselineForWidthFieldCallback
    -> a
    -- ^ /@widget@/: a t'GI.Gtk.Objects.Widget.Widget' instance
    -> Int32
    -- ^ /@width@/: the width which is available for allocation, or -1 if none
    -> m ((Int32, Int32, Int32, Int32))
dynamic_WidgetClassGetPreferredHeightAndBaselineForWidthFieldCallback __funPtr widget width = liftIO $ do
    widget' <- unsafeManagedPtrCastPtr widget
    minimumHeight <- allocMem :: IO (Ptr Int32)
    naturalHeight <- allocMem :: IO (Ptr Int32)
    minimumBaseline <- allocMem :: IO (Ptr Int32)
    naturalBaseline <- allocMem :: IO (Ptr Int32)
    (__dynamic_C_WidgetClassGetPreferredHeightAndBaselineForWidthFieldCallback __funPtr) widget' width minimumHeight naturalHeight minimumBaseline naturalBaseline
    minimumHeight' <- peek minimumHeight
    naturalHeight' <- peek naturalHeight
    minimumBaseline' <- peek minimumBaseline
    naturalBaseline' <- peek naturalBaseline
    touchManagedPtr widget
    freeMem minimumHeight
    freeMem naturalHeight
    freeMem minimumBaseline
    freeMem naturalBaseline
    return (minimumHeight', naturalHeight', minimumBaseline', naturalBaseline')

-- | Generate a function pointer callable from C code, from a `C_WidgetClassGetPreferredHeightAndBaselineForWidthFieldCallback`.
foreign import ccall "wrapper"
    mk_WidgetClassGetPreferredHeightAndBaselineForWidthFieldCallback :: C_WidgetClassGetPreferredHeightAndBaselineForWidthFieldCallback -> IO (FunPtr C_WidgetClassGetPreferredHeightAndBaselineForWidthFieldCallback)

-- | /No description available in the introspection data./
type WidgetClassGetPreferredHeightAndBaselineForWidthFieldCallback =
    Gtk.Widget.Widget
    -- ^ /@widget@/: a t'GI.Gtk.Objects.Widget.Widget' instance
    -> Int32
    -- ^ /@width@/: the width which is available for allocation, or -1 if none
    -> IO ((Int32, Int32, Int32, Int32))

-- | A convenience synonym for @`Nothing` :: `Maybe` `WidgetClassGetPreferredHeightAndBaselineForWidthFieldCallback`@.
noWidgetClassGetPreferredHeightAndBaselineForWidthFieldCallback :: Maybe WidgetClassGetPreferredHeightAndBaselineForWidthFieldCallback
noWidgetClassGetPreferredHeightAndBaselineForWidthFieldCallback = Nothing

-- | Wrap the callback into a `GClosure`.
genClosure_WidgetClassGetPreferredHeightAndBaselineForWidthFieldCallback :: MonadIO m => WidgetClassGetPreferredHeightAndBaselineForWidthFieldCallback -> m (GClosure C_WidgetClassGetPreferredHeightAndBaselineForWidthFieldCallback)
genClosure_WidgetClassGetPreferredHeightAndBaselineForWidthFieldCallback cb = liftIO $ do
    let cb' = wrap_WidgetClassGetPreferredHeightAndBaselineForWidthFieldCallback Nothing cb
    mk_WidgetClassGetPreferredHeightAndBaselineForWidthFieldCallback cb' >>= B.GClosure.newGClosure


-- | Wrap a `WidgetClassGetPreferredHeightAndBaselineForWidthFieldCallback` into a `C_WidgetClassGetPreferredHeightAndBaselineForWidthFieldCallback`.
wrap_WidgetClassGetPreferredHeightAndBaselineForWidthFieldCallback :: 
    Maybe (Ptr (FunPtr C_WidgetClassGetPreferredHeightAndBaselineForWidthFieldCallback)) ->
    WidgetClassGetPreferredHeightAndBaselineForWidthFieldCallback ->
    C_WidgetClassGetPreferredHeightAndBaselineForWidthFieldCallback
wrap_WidgetClassGetPreferredHeightAndBaselineForWidthFieldCallback gi'funptrptr gi'cb widget width minimumHeight naturalHeight minimumBaseline naturalBaseline = do
    widget' <- (newObject Gtk.Widget.Widget) widget
    (outminimumHeight, outnaturalHeight, outminimumBaseline, outnaturalBaseline) <- gi'cb  widget' width
    poke minimumHeight outminimumHeight
    poke naturalHeight outnaturalHeight
    poke minimumBaseline outminimumBaseline
    poke naturalBaseline outnaturalBaseline
    maybeReleaseFunPtr gi'funptrptr


-- callback WidgetClassGetAccessibleFieldCallback
{- Callable
  { returnType =
      Just (TInterface Name { namespace = "Atk" , name = "Object" })
  , returnMayBeNull = False
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation
        { rawDocText = Just "the #AtkObject associated with @widget"
        , sinceVersion = Nothing
        }
  , args =
      [ Arg
          { argCName = "widget"
          , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText = Just "a #GtkWidget" , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_WidgetClassGetAccessibleFieldCallback =
    Ptr Gtk.Widget.Widget ->
    IO (Ptr Atk.Object.Object)

-- Args: [ Arg
--           { argCName = "widget"
--           , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "a #GtkWidget" , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Just (TInterface Name { namespace = "Atk" , name = "Object" })
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_WidgetClassGetAccessibleFieldCallback :: FunPtr C_WidgetClassGetAccessibleFieldCallback -> C_WidgetClassGetAccessibleFieldCallback

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_WidgetClassGetAccessibleFieldCallback ::
    (B.CallStack.HasCallStack, MonadIO m, Gtk.Widget.IsWidget a) =>
    FunPtr C_WidgetClassGetAccessibleFieldCallback
    -> a
    -- ^ /@widget@/: a t'GI.Gtk.Objects.Widget.Widget'
    -> m Atk.Object.Object
    -- ^ __Returns:__ the t'GI.Atk.Objects.Object.Object' associated with /@widget@/
dynamic_WidgetClassGetAccessibleFieldCallback __funPtr widget = liftIO $ do
    widget' <- unsafeManagedPtrCastPtr widget
    result <- (__dynamic_C_WidgetClassGetAccessibleFieldCallback __funPtr) widget'
    checkUnexpectedReturnNULL "widgetClassGetAccessibleFieldCallback" result
    result' <- (newObject Atk.Object.Object) result
    touchManagedPtr widget
    return result'

-- | Generate a function pointer callable from C code, from a `C_WidgetClassGetAccessibleFieldCallback`.
foreign import ccall "wrapper"
    mk_WidgetClassGetAccessibleFieldCallback :: C_WidgetClassGetAccessibleFieldCallback -> IO (FunPtr C_WidgetClassGetAccessibleFieldCallback)

-- | /No description available in the introspection data./
type WidgetClassGetAccessibleFieldCallback =
    Gtk.Widget.Widget
    -- ^ /@widget@/: a t'GI.Gtk.Objects.Widget.Widget'
    -> IO Atk.Object.Object
    -- ^ __Returns:__ the t'GI.Atk.Objects.Object.Object' associated with /@widget@/

-- | A convenience synonym for @`Nothing` :: `Maybe` `WidgetClassGetAccessibleFieldCallback`@.
noWidgetClassGetAccessibleFieldCallback :: Maybe WidgetClassGetAccessibleFieldCallback
noWidgetClassGetAccessibleFieldCallback = Nothing

-- | Wrap the callback into a `GClosure`.
genClosure_WidgetClassGetAccessibleFieldCallback :: MonadIO m => WidgetClassGetAccessibleFieldCallback -> m (GClosure C_WidgetClassGetAccessibleFieldCallback)
genClosure_WidgetClassGetAccessibleFieldCallback cb = liftIO $ do
    let cb' = wrap_WidgetClassGetAccessibleFieldCallback Nothing cb
    mk_WidgetClassGetAccessibleFieldCallback cb' >>= B.GClosure.newGClosure


-- | Wrap a `WidgetClassGetAccessibleFieldCallback` into a `C_WidgetClassGetAccessibleFieldCallback`.
wrap_WidgetClassGetAccessibleFieldCallback :: 
    Maybe (Ptr (FunPtr C_WidgetClassGetAccessibleFieldCallback)) ->
    WidgetClassGetAccessibleFieldCallback ->
    C_WidgetClassGetAccessibleFieldCallback
wrap_WidgetClassGetAccessibleFieldCallback gi'funptrptr gi'cb widget = do
    widget' <- (newObject Gtk.Widget.Widget) widget
    result <- gi'cb  widget'
    maybeReleaseFunPtr gi'funptrptr
    result' <- unsafeManagedPtrCastPtr result
    return result'


-- callback WidgetClassFocusOutEventFieldCallback
{- Callable
  { returnType = Just (TBasicType TBoolean)
  , returnMayBeNull = False
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , args =
      [ Arg
          { argCName = "widget"
          , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "event"
          , argType =
              TInterface Name { namespace = "Gdk" , name = "EventFocus" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_WidgetClassFocusOutEventFieldCallback =
    Ptr Gtk.Widget.Widget ->
    Ptr Gdk.EventFocus.EventFocus ->
    IO CInt

-- Args: [ Arg
--           { argCName = "widget"
--           , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "event"
--           , argType =
--               TInterface Name { namespace = "Gdk" , name = "EventFocus" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Just (TBasicType TBoolean)
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_WidgetClassFocusOutEventFieldCallback :: FunPtr C_WidgetClassFocusOutEventFieldCallback -> C_WidgetClassFocusOutEventFieldCallback

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_WidgetClassFocusOutEventFieldCallback ::
    (B.CallStack.HasCallStack, MonadIO m, Gtk.Widget.IsWidget a) =>
    FunPtr C_WidgetClassFocusOutEventFieldCallback
    -> a
    -> Gdk.EventFocus.EventFocus
    -> m Bool
dynamic_WidgetClassFocusOutEventFieldCallback __funPtr widget event = liftIO $ do
    widget' <- unsafeManagedPtrCastPtr widget
    event' <- unsafeManagedPtrGetPtr event
    result <- (__dynamic_C_WidgetClassFocusOutEventFieldCallback __funPtr) widget' event'
    let result' = (/= 0) result
    touchManagedPtr widget
    touchManagedPtr event
    return result'

-- | Generate a function pointer callable from C code, from a `C_WidgetClassFocusOutEventFieldCallback`.
foreign import ccall "wrapper"
    mk_WidgetClassFocusOutEventFieldCallback :: C_WidgetClassFocusOutEventFieldCallback -> IO (FunPtr C_WidgetClassFocusOutEventFieldCallback)

-- | /No description available in the introspection data./
type WidgetClassFocusOutEventFieldCallback =
    Gtk.Widget.Widget
    -> Gdk.EventFocus.EventFocus
    -> IO Bool

-- | A convenience synonym for @`Nothing` :: `Maybe` `WidgetClassFocusOutEventFieldCallback`@.
noWidgetClassFocusOutEventFieldCallback :: Maybe WidgetClassFocusOutEventFieldCallback
noWidgetClassFocusOutEventFieldCallback = Nothing

-- | Wrap the callback into a `GClosure`.
genClosure_WidgetClassFocusOutEventFieldCallback :: MonadIO m => WidgetClassFocusOutEventFieldCallback -> m (GClosure C_WidgetClassFocusOutEventFieldCallback)
genClosure_WidgetClassFocusOutEventFieldCallback cb = liftIO $ do
    let cb' = wrap_WidgetClassFocusOutEventFieldCallback Nothing cb
    mk_WidgetClassFocusOutEventFieldCallback cb' >>= B.GClosure.newGClosure


-- | Wrap a `WidgetClassFocusOutEventFieldCallback` into a `C_WidgetClassFocusOutEventFieldCallback`.
wrap_WidgetClassFocusOutEventFieldCallback :: 
    Maybe (Ptr (FunPtr C_WidgetClassFocusOutEventFieldCallback)) ->
    WidgetClassFocusOutEventFieldCallback ->
    C_WidgetClassFocusOutEventFieldCallback
wrap_WidgetClassFocusOutEventFieldCallback gi'funptrptr gi'cb widget event = do
    widget' <- (newObject Gtk.Widget.Widget) widget
    event' <- (newPtr Gdk.EventFocus.EventFocus) event
    result <- gi'cb  widget' event'
    maybeReleaseFunPtr gi'funptrptr
    let result' = (fromIntegral . fromEnum) result
    return result'


-- callback WidgetClassFocusInEventFieldCallback
{- Callable
  { returnType = Just (TBasicType TBoolean)
  , returnMayBeNull = False
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , args =
      [ Arg
          { argCName = "widget"
          , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "event"
          , argType =
              TInterface Name { namespace = "Gdk" , name = "EventFocus" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_WidgetClassFocusInEventFieldCallback =
    Ptr Gtk.Widget.Widget ->
    Ptr Gdk.EventFocus.EventFocus ->
    IO CInt

-- Args: [ Arg
--           { argCName = "widget"
--           , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "event"
--           , argType =
--               TInterface Name { namespace = "Gdk" , name = "EventFocus" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Just (TBasicType TBoolean)
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_WidgetClassFocusInEventFieldCallback :: FunPtr C_WidgetClassFocusInEventFieldCallback -> C_WidgetClassFocusInEventFieldCallback

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_WidgetClassFocusInEventFieldCallback ::
    (B.CallStack.HasCallStack, MonadIO m, Gtk.Widget.IsWidget a) =>
    FunPtr C_WidgetClassFocusInEventFieldCallback
    -> a
    -> Gdk.EventFocus.EventFocus
    -> m Bool
dynamic_WidgetClassFocusInEventFieldCallback __funPtr widget event = liftIO $ do
    widget' <- unsafeManagedPtrCastPtr widget
    event' <- unsafeManagedPtrGetPtr event
    result <- (__dynamic_C_WidgetClassFocusInEventFieldCallback __funPtr) widget' event'
    let result' = (/= 0) result
    touchManagedPtr widget
    touchManagedPtr event
    return result'

-- | Generate a function pointer callable from C code, from a `C_WidgetClassFocusInEventFieldCallback`.
foreign import ccall "wrapper"
    mk_WidgetClassFocusInEventFieldCallback :: C_WidgetClassFocusInEventFieldCallback -> IO (FunPtr C_WidgetClassFocusInEventFieldCallback)

-- | /No description available in the introspection data./
type WidgetClassFocusInEventFieldCallback =
    Gtk.Widget.Widget
    -> Gdk.EventFocus.EventFocus
    -> IO Bool

-- | A convenience synonym for @`Nothing` :: `Maybe` `WidgetClassFocusInEventFieldCallback`@.
noWidgetClassFocusInEventFieldCallback :: Maybe WidgetClassFocusInEventFieldCallback
noWidgetClassFocusInEventFieldCallback = Nothing

-- | Wrap the callback into a `GClosure`.
genClosure_WidgetClassFocusInEventFieldCallback :: MonadIO m => WidgetClassFocusInEventFieldCallback -> m (GClosure C_WidgetClassFocusInEventFieldCallback)
genClosure_WidgetClassFocusInEventFieldCallback cb = liftIO $ do
    let cb' = wrap_WidgetClassFocusInEventFieldCallback Nothing cb
    mk_WidgetClassFocusInEventFieldCallback cb' >>= B.GClosure.newGClosure


-- | Wrap a `WidgetClassFocusInEventFieldCallback` into a `C_WidgetClassFocusInEventFieldCallback`.
wrap_WidgetClassFocusInEventFieldCallback :: 
    Maybe (Ptr (FunPtr C_WidgetClassFocusInEventFieldCallback)) ->
    WidgetClassFocusInEventFieldCallback ->
    C_WidgetClassFocusInEventFieldCallback
wrap_WidgetClassFocusInEventFieldCallback gi'funptrptr gi'cb widget event = do
    widget' <- (newObject Gtk.Widget.Widget) widget
    event' <- (newPtr Gdk.EventFocus.EventFocus) event
    result <- gi'cb  widget' event'
    maybeReleaseFunPtr gi'funptrptr
    let result' = (fromIntegral . fromEnum) result
    return result'


-- callback WidgetClassFocusFieldCallback
{- Callable
  { returnType = Just (TBasicType TBoolean)
  , returnMayBeNull = False
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , args =
      [ Arg
          { argCName = "widget"
          , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "direction"
          , argType =
              TInterface Name { namespace = "Gtk" , name = "DirectionType" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_WidgetClassFocusFieldCallback =
    Ptr Gtk.Widget.Widget ->
    CUInt ->
    IO CInt

-- Args: [ Arg
--           { argCName = "widget"
--           , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "direction"
--           , argType =
--               TInterface Name { namespace = "Gtk" , name = "DirectionType" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Just (TBasicType TBoolean)
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_WidgetClassFocusFieldCallback :: FunPtr C_WidgetClassFocusFieldCallback -> C_WidgetClassFocusFieldCallback

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_WidgetClassFocusFieldCallback ::
    (B.CallStack.HasCallStack, MonadIO m, Gtk.Widget.IsWidget a) =>
    FunPtr C_WidgetClassFocusFieldCallback
    -> a
    -> Gtk.Enums.DirectionType
    -> m Bool
dynamic_WidgetClassFocusFieldCallback __funPtr widget direction = liftIO $ do
    widget' <- unsafeManagedPtrCastPtr widget
    let direction' = (fromIntegral . fromEnum) direction
    result <- (__dynamic_C_WidgetClassFocusFieldCallback __funPtr) widget' direction'
    let result' = (/= 0) result
    touchManagedPtr widget
    return result'

-- | Generate a function pointer callable from C code, from a `C_WidgetClassFocusFieldCallback`.
foreign import ccall "wrapper"
    mk_WidgetClassFocusFieldCallback :: C_WidgetClassFocusFieldCallback -> IO (FunPtr C_WidgetClassFocusFieldCallback)

-- | /No description available in the introspection data./
type WidgetClassFocusFieldCallback =
    Gtk.Widget.Widget
    -> Gtk.Enums.DirectionType
    -> IO Bool

-- | A convenience synonym for @`Nothing` :: `Maybe` `WidgetClassFocusFieldCallback`@.
noWidgetClassFocusFieldCallback :: Maybe WidgetClassFocusFieldCallback
noWidgetClassFocusFieldCallback = Nothing

-- | Wrap the callback into a `GClosure`.
genClosure_WidgetClassFocusFieldCallback :: MonadIO m => WidgetClassFocusFieldCallback -> m (GClosure C_WidgetClassFocusFieldCallback)
genClosure_WidgetClassFocusFieldCallback cb = liftIO $ do
    let cb' = wrap_WidgetClassFocusFieldCallback Nothing cb
    mk_WidgetClassFocusFieldCallback cb' >>= B.GClosure.newGClosure


-- | Wrap a `WidgetClassFocusFieldCallback` into a `C_WidgetClassFocusFieldCallback`.
wrap_WidgetClassFocusFieldCallback :: 
    Maybe (Ptr (FunPtr C_WidgetClassFocusFieldCallback)) ->
    WidgetClassFocusFieldCallback ->
    C_WidgetClassFocusFieldCallback
wrap_WidgetClassFocusFieldCallback gi'funptrptr gi'cb widget direction = do
    widget' <- (newObject Gtk.Widget.Widget) widget
    let direction' = (toEnum . fromIntegral) direction
    result <- gi'cb  widget' direction'
    maybeReleaseFunPtr gi'funptrptr
    let result' = (fromIntegral . fromEnum) result
    return result'


-- callback WidgetClassEventFieldCallback
{- Callable
  { returnType = Just (TBasicType TBoolean)
  , returnMayBeNull = False
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation
        { rawDocText =
            Just
              "return from the event signal emission (%TRUE if\n              the event was handled)"
        , sinceVersion = Nothing
        }
  , args =
      [ Arg
          { argCName = "widget"
          , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText = Just "a #GtkWidget" , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "event"
          , argType = TInterface Name { namespace = "Gdk" , name = "Event" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText = Just "a #GdkEvent" , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_WidgetClassEventFieldCallback =
    Ptr Gtk.Widget.Widget ->
    Ptr Gdk.Event.Event ->
    IO CInt

-- Args: [ Arg
--           { argCName = "widget"
--           , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "a #GtkWidget" , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "event"
--           , argType = TInterface Name { namespace = "Gdk" , name = "Event" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "a #GdkEvent" , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Just (TBasicType TBoolean)
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_WidgetClassEventFieldCallback :: FunPtr C_WidgetClassEventFieldCallback -> C_WidgetClassEventFieldCallback

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_WidgetClassEventFieldCallback ::
    (B.CallStack.HasCallStack, MonadIO m, Gtk.Widget.IsWidget a) =>
    FunPtr C_WidgetClassEventFieldCallback
    -> a
    -- ^ /@widget@/: a t'GI.Gtk.Objects.Widget.Widget'
    -> Gdk.Event.Event
    -- ^ /@event@/: a t'GI.Gdk.Unions.Event.Event'
    -> m Bool
    -- ^ __Returns:__ return from the event signal emission ('P.True' if
    --               the event was handled)
dynamic_WidgetClassEventFieldCallback __funPtr widget event = liftIO $ do
    widget' <- unsafeManagedPtrCastPtr widget
    event' <- unsafeManagedPtrGetPtr event
    result <- (__dynamic_C_WidgetClassEventFieldCallback __funPtr) widget' event'
    let result' = (/= 0) result
    touchManagedPtr widget
    touchManagedPtr event
    return result'

-- | Generate a function pointer callable from C code, from a `C_WidgetClassEventFieldCallback`.
foreign import ccall "wrapper"
    mk_WidgetClassEventFieldCallback :: C_WidgetClassEventFieldCallback -> IO (FunPtr C_WidgetClassEventFieldCallback)

-- | /No description available in the introspection data./
type WidgetClassEventFieldCallback =
    Gtk.Widget.Widget
    -- ^ /@widget@/: a t'GI.Gtk.Objects.Widget.Widget'
    -> Gdk.Event.Event
    -- ^ /@event@/: a t'GI.Gdk.Unions.Event.Event'
    -> IO Bool
    -- ^ __Returns:__ return from the event signal emission ('P.True' if
    --               the event was handled)

-- | A convenience synonym for @`Nothing` :: `Maybe` `WidgetClassEventFieldCallback`@.
noWidgetClassEventFieldCallback :: Maybe WidgetClassEventFieldCallback
noWidgetClassEventFieldCallback = Nothing

-- | Wrap the callback into a `GClosure`.
genClosure_WidgetClassEventFieldCallback :: MonadIO m => WidgetClassEventFieldCallback -> m (GClosure C_WidgetClassEventFieldCallback)
genClosure_WidgetClassEventFieldCallback cb = liftIO $ do
    let cb' = wrap_WidgetClassEventFieldCallback Nothing cb
    mk_WidgetClassEventFieldCallback cb' >>= B.GClosure.newGClosure


-- | Wrap a `WidgetClassEventFieldCallback` into a `C_WidgetClassEventFieldCallback`.
wrap_WidgetClassEventFieldCallback :: 
    Maybe (Ptr (FunPtr C_WidgetClassEventFieldCallback)) ->
    WidgetClassEventFieldCallback ->
    C_WidgetClassEventFieldCallback
wrap_WidgetClassEventFieldCallback gi'funptrptr gi'cb widget event = do
    widget' <- (newObject Gtk.Widget.Widget) widget
    B.ManagedPtr.withTransient  event $ \event' -> do
        result <- gi'cb  widget' event'
        maybeReleaseFunPtr gi'funptrptr
        let result' = (fromIntegral . fromEnum) result
        return result'


-- callback WidgetClassEnterNotifyEventFieldCallback
{- Callable
  { returnType = Just (TBasicType TBoolean)
  , returnMayBeNull = False
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , args =
      [ Arg
          { argCName = "widget"
          , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "event"
          , argType =
              TInterface Name { namespace = "Gdk" , name = "EventCrossing" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_WidgetClassEnterNotifyEventFieldCallback =
    Ptr Gtk.Widget.Widget ->
    Ptr Gdk.EventCrossing.EventCrossing ->
    IO CInt

-- Args: [ Arg
--           { argCName = "widget"
--           , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "event"
--           , argType =
--               TInterface Name { namespace = "Gdk" , name = "EventCrossing" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Just (TBasicType TBoolean)
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_WidgetClassEnterNotifyEventFieldCallback :: FunPtr C_WidgetClassEnterNotifyEventFieldCallback -> C_WidgetClassEnterNotifyEventFieldCallback

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_WidgetClassEnterNotifyEventFieldCallback ::
    (B.CallStack.HasCallStack, MonadIO m, Gtk.Widget.IsWidget a) =>
    FunPtr C_WidgetClassEnterNotifyEventFieldCallback
    -> a
    -> Gdk.EventCrossing.EventCrossing
    -> m Bool
dynamic_WidgetClassEnterNotifyEventFieldCallback __funPtr widget event = liftIO $ do
    widget' <- unsafeManagedPtrCastPtr widget
    event' <- unsafeManagedPtrGetPtr event
    result <- (__dynamic_C_WidgetClassEnterNotifyEventFieldCallback __funPtr) widget' event'
    let result' = (/= 0) result
    touchManagedPtr widget
    touchManagedPtr event
    return result'

-- | Generate a function pointer callable from C code, from a `C_WidgetClassEnterNotifyEventFieldCallback`.
foreign import ccall "wrapper"
    mk_WidgetClassEnterNotifyEventFieldCallback :: C_WidgetClassEnterNotifyEventFieldCallback -> IO (FunPtr C_WidgetClassEnterNotifyEventFieldCallback)

-- | /No description available in the introspection data./
type WidgetClassEnterNotifyEventFieldCallback =
    Gtk.Widget.Widget
    -> Gdk.EventCrossing.EventCrossing
    -> IO Bool

-- | A convenience synonym for @`Nothing` :: `Maybe` `WidgetClassEnterNotifyEventFieldCallback`@.
noWidgetClassEnterNotifyEventFieldCallback :: Maybe WidgetClassEnterNotifyEventFieldCallback
noWidgetClassEnterNotifyEventFieldCallback = Nothing

-- | Wrap the callback into a `GClosure`.
genClosure_WidgetClassEnterNotifyEventFieldCallback :: MonadIO m => WidgetClassEnterNotifyEventFieldCallback -> m (GClosure C_WidgetClassEnterNotifyEventFieldCallback)
genClosure_WidgetClassEnterNotifyEventFieldCallback cb = liftIO $ do
    let cb' = wrap_WidgetClassEnterNotifyEventFieldCallback Nothing cb
    mk_WidgetClassEnterNotifyEventFieldCallback cb' >>= B.GClosure.newGClosure


-- | Wrap a `WidgetClassEnterNotifyEventFieldCallback` into a `C_WidgetClassEnterNotifyEventFieldCallback`.
wrap_WidgetClassEnterNotifyEventFieldCallback :: 
    Maybe (Ptr (FunPtr C_WidgetClassEnterNotifyEventFieldCallback)) ->
    WidgetClassEnterNotifyEventFieldCallback ->
    C_WidgetClassEnterNotifyEventFieldCallback
wrap_WidgetClassEnterNotifyEventFieldCallback gi'funptrptr gi'cb widget event = do
    widget' <- (newObject Gtk.Widget.Widget) widget
    event' <- (newPtr Gdk.EventCrossing.EventCrossing) event
    result <- gi'cb  widget' event'
    maybeReleaseFunPtr gi'funptrptr
    let result' = (fromIntegral . fromEnum) result
    return result'


-- callback WidgetClassDrawFieldCallback
{- Callable
  { returnType = Just (TBasicType TBoolean)
  , returnMayBeNull = False
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , args =
      [ Arg
          { argCName = "widget"
          , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "cr"
          , argType =
              TInterface Name { namespace = "cairo" , name = "Context" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_WidgetClassDrawFieldCallback =
    Ptr Gtk.Widget.Widget ->
    Ptr Cairo.Context.Context ->
    IO CInt

-- Args: [ Arg
--           { argCName = "widget"
--           , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "cr"
--           , argType =
--               TInterface Name { namespace = "cairo" , name = "Context" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Just (TBasicType TBoolean)
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_WidgetClassDrawFieldCallback :: FunPtr C_WidgetClassDrawFieldCallback -> C_WidgetClassDrawFieldCallback

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_WidgetClassDrawFieldCallback ::
    (B.CallStack.HasCallStack, MonadIO m, Gtk.Widget.IsWidget a) =>
    FunPtr C_WidgetClassDrawFieldCallback
    -> a
    -> Cairo.Context.Context
    -> m Bool
dynamic_WidgetClassDrawFieldCallback __funPtr widget cr = liftIO $ do
    widget' <- unsafeManagedPtrCastPtr widget
    cr' <- unsafeManagedPtrGetPtr cr
    result <- (__dynamic_C_WidgetClassDrawFieldCallback __funPtr) widget' cr'
    let result' = (/= 0) result
    touchManagedPtr widget
    touchManagedPtr cr
    return result'

-- | Generate a function pointer callable from C code, from a `C_WidgetClassDrawFieldCallback`.
foreign import ccall "wrapper"
    mk_WidgetClassDrawFieldCallback :: C_WidgetClassDrawFieldCallback -> IO (FunPtr C_WidgetClassDrawFieldCallback)

-- | /No description available in the introspection data./
type WidgetClassDrawFieldCallback =
    Gtk.Widget.Widget
    -> Cairo.Context.Context
    -> IO Bool

-- | A convenience synonym for @`Nothing` :: `Maybe` `WidgetClassDrawFieldCallback`@.
noWidgetClassDrawFieldCallback :: Maybe WidgetClassDrawFieldCallback
noWidgetClassDrawFieldCallback = Nothing

-- | Wrap the callback into a `GClosure`.
genClosure_WidgetClassDrawFieldCallback :: MonadIO m => WidgetClassDrawFieldCallback -> m (GClosure C_WidgetClassDrawFieldCallback)
genClosure_WidgetClassDrawFieldCallback cb = liftIO $ do
    let cb' = wrap_WidgetClassDrawFieldCallback Nothing cb
    mk_WidgetClassDrawFieldCallback cb' >>= B.GClosure.newGClosure


-- | Wrap a `WidgetClassDrawFieldCallback` into a `C_WidgetClassDrawFieldCallback`.
wrap_WidgetClassDrawFieldCallback :: 
    Maybe (Ptr (FunPtr C_WidgetClassDrawFieldCallback)) ->
    WidgetClassDrawFieldCallback ->
    C_WidgetClassDrawFieldCallback
wrap_WidgetClassDrawFieldCallback gi'funptrptr gi'cb widget cr = do
    widget' <- (newObject Gtk.Widget.Widget) widget
    B.ManagedPtr.withTransient  cr $ \cr' -> do
        result <- gi'cb  widget' cr'
        maybeReleaseFunPtr gi'funptrptr
        let result' = (fromIntegral . fromEnum) result
        return result'


-- callback WidgetClassDragMotionFieldCallback
{- Callable
  { returnType = Just (TBasicType TBoolean)
  , returnMayBeNull = False
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , args =
      [ Arg
          { argCName = "widget"
          , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "context"
          , argType =
              TInterface Name { namespace = "Gdk" , name = "DragContext" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "x"
          , argType = TBasicType TInt
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "y"
          , argType = TBasicType TInt
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "time_"
          , argType = TBasicType TUInt
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_WidgetClassDragMotionFieldCallback =
    Ptr Gtk.Widget.Widget ->
    Ptr Gdk.DragContext.DragContext ->
    Int32 ->
    Int32 ->
    Word32 ->
    IO CInt

-- Args: [ Arg
--           { argCName = "widget"
--           , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "context"
--           , argType =
--               TInterface Name { namespace = "Gdk" , name = "DragContext" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "x"
--           , argType = TBasicType TInt
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "y"
--           , argType = TBasicType TInt
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "time_"
--           , argType = TBasicType TUInt
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Just (TBasicType TBoolean)
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_WidgetClassDragMotionFieldCallback :: FunPtr C_WidgetClassDragMotionFieldCallback -> C_WidgetClassDragMotionFieldCallback

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_WidgetClassDragMotionFieldCallback ::
    (B.CallStack.HasCallStack, MonadIO m, Gtk.Widget.IsWidget a, Gdk.DragContext.IsDragContext b) =>
    FunPtr C_WidgetClassDragMotionFieldCallback
    -> a
    -> b
    -> Int32
    -> Int32
    -> Word32
    -> m Bool
dynamic_WidgetClassDragMotionFieldCallback __funPtr widget context x y time_ = liftIO $ do
    widget' <- unsafeManagedPtrCastPtr widget
    context' <- unsafeManagedPtrCastPtr context
    result <- (__dynamic_C_WidgetClassDragMotionFieldCallback __funPtr) widget' context' x y time_
    let result' = (/= 0) result
    touchManagedPtr widget
    touchManagedPtr context
    return result'

-- | Generate a function pointer callable from C code, from a `C_WidgetClassDragMotionFieldCallback`.
foreign import ccall "wrapper"
    mk_WidgetClassDragMotionFieldCallback :: C_WidgetClassDragMotionFieldCallback -> IO (FunPtr C_WidgetClassDragMotionFieldCallback)

-- | /No description available in the introspection data./
type WidgetClassDragMotionFieldCallback =
    Gtk.Widget.Widget
    -> Gdk.DragContext.DragContext
    -> Int32
    -> Int32
    -> Word32
    -> IO Bool

-- | A convenience synonym for @`Nothing` :: `Maybe` `WidgetClassDragMotionFieldCallback`@.
noWidgetClassDragMotionFieldCallback :: Maybe WidgetClassDragMotionFieldCallback
noWidgetClassDragMotionFieldCallback = Nothing

-- | Wrap the callback into a `GClosure`.
genClosure_WidgetClassDragMotionFieldCallback :: MonadIO m => WidgetClassDragMotionFieldCallback -> m (GClosure C_WidgetClassDragMotionFieldCallback)
genClosure_WidgetClassDragMotionFieldCallback cb = liftIO $ do
    let cb' = wrap_WidgetClassDragMotionFieldCallback Nothing cb
    mk_WidgetClassDragMotionFieldCallback cb' >>= B.GClosure.newGClosure


-- | Wrap a `WidgetClassDragMotionFieldCallback` into a `C_WidgetClassDragMotionFieldCallback`.
wrap_WidgetClassDragMotionFieldCallback :: 
    Maybe (Ptr (FunPtr C_WidgetClassDragMotionFieldCallback)) ->
    WidgetClassDragMotionFieldCallback ->
    C_WidgetClassDragMotionFieldCallback
wrap_WidgetClassDragMotionFieldCallback gi'funptrptr gi'cb widget context x y time_ = do
    widget' <- (newObject Gtk.Widget.Widget) widget
    context' <- (newObject Gdk.DragContext.DragContext) context
    result <- gi'cb  widget' context' x y time_
    maybeReleaseFunPtr gi'funptrptr
    let result' = (fromIntegral . fromEnum) result
    return result'


-- callback WidgetClassDragLeaveFieldCallback
{- Callable
  { returnType = Nothing
  , returnMayBeNull = False
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , args =
      [ Arg
          { argCName = "widget"
          , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "context"
          , argType =
              TInterface Name { namespace = "Gdk" , name = "DragContext" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "time_"
          , argType = TBasicType TUInt
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_WidgetClassDragLeaveFieldCallback =
    Ptr Gtk.Widget.Widget ->
    Ptr Gdk.DragContext.DragContext ->
    Word32 ->
    IO ()

-- Args: [ Arg
--           { argCName = "widget"
--           , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "context"
--           , argType =
--               TInterface Name { namespace = "Gdk" , name = "DragContext" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "time_"
--           , argType = TBasicType TUInt
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Nothing
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_WidgetClassDragLeaveFieldCallback :: FunPtr C_WidgetClassDragLeaveFieldCallback -> C_WidgetClassDragLeaveFieldCallback

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_WidgetClassDragLeaveFieldCallback ::
    (B.CallStack.HasCallStack, MonadIO m, Gtk.Widget.IsWidget a, Gdk.DragContext.IsDragContext b) =>
    FunPtr C_WidgetClassDragLeaveFieldCallback
    -> a
    -> b
    -> Word32
    -> m ()
dynamic_WidgetClassDragLeaveFieldCallback __funPtr widget context time_ = liftIO $ do
    widget' <- unsafeManagedPtrCastPtr widget
    context' <- unsafeManagedPtrCastPtr context
    (__dynamic_C_WidgetClassDragLeaveFieldCallback __funPtr) widget' context' time_
    touchManagedPtr widget
    touchManagedPtr context
    return ()

-- | Generate a function pointer callable from C code, from a `C_WidgetClassDragLeaveFieldCallback`.
foreign import ccall "wrapper"
    mk_WidgetClassDragLeaveFieldCallback :: C_WidgetClassDragLeaveFieldCallback -> IO (FunPtr C_WidgetClassDragLeaveFieldCallback)

-- | /No description available in the introspection data./
type WidgetClassDragLeaveFieldCallback =
    Gtk.Widget.Widget
    -> Gdk.DragContext.DragContext
    -> Word32
    -> IO ()

-- | A convenience synonym for @`Nothing` :: `Maybe` `WidgetClassDragLeaveFieldCallback`@.
noWidgetClassDragLeaveFieldCallback :: Maybe WidgetClassDragLeaveFieldCallback
noWidgetClassDragLeaveFieldCallback = Nothing

-- | Wrap the callback into a `GClosure`.
genClosure_WidgetClassDragLeaveFieldCallback :: MonadIO m => WidgetClassDragLeaveFieldCallback -> m (GClosure C_WidgetClassDragLeaveFieldCallback)
genClosure_WidgetClassDragLeaveFieldCallback cb = liftIO $ do
    let cb' = wrap_WidgetClassDragLeaveFieldCallback Nothing cb
    mk_WidgetClassDragLeaveFieldCallback cb' >>= B.GClosure.newGClosure


-- | Wrap a `WidgetClassDragLeaveFieldCallback` into a `C_WidgetClassDragLeaveFieldCallback`.
wrap_WidgetClassDragLeaveFieldCallback :: 
    Maybe (Ptr (FunPtr C_WidgetClassDragLeaveFieldCallback)) ->
    WidgetClassDragLeaveFieldCallback ->
    C_WidgetClassDragLeaveFieldCallback
wrap_WidgetClassDragLeaveFieldCallback gi'funptrptr gi'cb widget context time_ = do
    widget' <- (newObject Gtk.Widget.Widget) widget
    context' <- (newObject Gdk.DragContext.DragContext) context
    gi'cb  widget' context' time_
    maybeReleaseFunPtr gi'funptrptr


-- callback WidgetClassDragFailedFieldCallback
{- Callable
  { returnType = Just (TBasicType TBoolean)
  , returnMayBeNull = False
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , args =
      [ Arg
          { argCName = "widget"
          , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "context"
          , argType =
              TInterface Name { namespace = "Gdk" , name = "DragContext" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "result"
          , argType =
              TInterface Name { namespace = "Gtk" , name = "DragResult" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_WidgetClassDragFailedFieldCallback =
    Ptr Gtk.Widget.Widget ->
    Ptr Gdk.DragContext.DragContext ->
    CUInt ->
    IO CInt

-- Args: [ Arg
--           { argCName = "widget"
--           , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "context"
--           , argType =
--               TInterface Name { namespace = "Gdk" , name = "DragContext" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "result"
--           , argType =
--               TInterface Name { namespace = "Gtk" , name = "DragResult" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Just (TBasicType TBoolean)
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_WidgetClassDragFailedFieldCallback :: FunPtr C_WidgetClassDragFailedFieldCallback -> C_WidgetClassDragFailedFieldCallback

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_WidgetClassDragFailedFieldCallback ::
    (B.CallStack.HasCallStack, MonadIO m, Gtk.Widget.IsWidget a, Gdk.DragContext.IsDragContext b) =>
    FunPtr C_WidgetClassDragFailedFieldCallback
    -> a
    -> b
    -> Gtk.Enums.DragResult
    -> m Bool
dynamic_WidgetClassDragFailedFieldCallback __funPtr widget context result_ = liftIO $ do
    widget' <- unsafeManagedPtrCastPtr widget
    context' <- unsafeManagedPtrCastPtr context
    let result_' = (fromIntegral . fromEnum) result_
    result <- (__dynamic_C_WidgetClassDragFailedFieldCallback __funPtr) widget' context' result_'
    let result' = (/= 0) result
    touchManagedPtr widget
    touchManagedPtr context
    return result'

-- | Generate a function pointer callable from C code, from a `C_WidgetClassDragFailedFieldCallback`.
foreign import ccall "wrapper"
    mk_WidgetClassDragFailedFieldCallback :: C_WidgetClassDragFailedFieldCallback -> IO (FunPtr C_WidgetClassDragFailedFieldCallback)

-- | /No description available in the introspection data./
type WidgetClassDragFailedFieldCallback =
    Gtk.Widget.Widget
    -> Gdk.DragContext.DragContext
    -> Gtk.Enums.DragResult
    -> IO Bool

-- | A convenience synonym for @`Nothing` :: `Maybe` `WidgetClassDragFailedFieldCallback`@.
noWidgetClassDragFailedFieldCallback :: Maybe WidgetClassDragFailedFieldCallback
noWidgetClassDragFailedFieldCallback = Nothing

-- | Wrap the callback into a `GClosure`.
genClosure_WidgetClassDragFailedFieldCallback :: MonadIO m => WidgetClassDragFailedFieldCallback -> m (GClosure C_WidgetClassDragFailedFieldCallback)
genClosure_WidgetClassDragFailedFieldCallback cb = liftIO $ do
    let cb' = wrap_WidgetClassDragFailedFieldCallback Nothing cb
    mk_WidgetClassDragFailedFieldCallback cb' >>= B.GClosure.newGClosure


-- | Wrap a `WidgetClassDragFailedFieldCallback` into a `C_WidgetClassDragFailedFieldCallback`.
wrap_WidgetClassDragFailedFieldCallback :: 
    Maybe (Ptr (FunPtr C_WidgetClassDragFailedFieldCallback)) ->
    WidgetClassDragFailedFieldCallback ->
    C_WidgetClassDragFailedFieldCallback
wrap_WidgetClassDragFailedFieldCallback gi'funptrptr gi'cb widget context result_ = do
    widget' <- (newObject Gtk.Widget.Widget) widget
    context' <- (newObject Gdk.DragContext.DragContext) context
    let result_' = (toEnum . fromIntegral) result_
    result <- gi'cb  widget' context' result_'
    maybeReleaseFunPtr gi'funptrptr
    let result' = (fromIntegral . fromEnum) result
    return result'


-- callback WidgetClassDragEndFieldCallback
{- Callable
  { returnType = Nothing
  , returnMayBeNull = False
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , args =
      [ Arg
          { argCName = "widget"
          , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "context"
          , argType =
              TInterface Name { namespace = "Gdk" , name = "DragContext" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_WidgetClassDragEndFieldCallback =
    Ptr Gtk.Widget.Widget ->
    Ptr Gdk.DragContext.DragContext ->
    IO ()

-- Args: [ Arg
--           { argCName = "widget"
--           , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "context"
--           , argType =
--               TInterface Name { namespace = "Gdk" , name = "DragContext" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Nothing
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_WidgetClassDragEndFieldCallback :: FunPtr C_WidgetClassDragEndFieldCallback -> C_WidgetClassDragEndFieldCallback

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_WidgetClassDragEndFieldCallback ::
    (B.CallStack.HasCallStack, MonadIO m, Gtk.Widget.IsWidget a, Gdk.DragContext.IsDragContext b) =>
    FunPtr C_WidgetClassDragEndFieldCallback
    -> a
    -> b
    -> m ()
dynamic_WidgetClassDragEndFieldCallback __funPtr widget context = liftIO $ do
    widget' <- unsafeManagedPtrCastPtr widget
    context' <- unsafeManagedPtrCastPtr context
    (__dynamic_C_WidgetClassDragEndFieldCallback __funPtr) widget' context'
    touchManagedPtr widget
    touchManagedPtr context
    return ()

-- | Generate a function pointer callable from C code, from a `C_WidgetClassDragEndFieldCallback`.
foreign import ccall "wrapper"
    mk_WidgetClassDragEndFieldCallback :: C_WidgetClassDragEndFieldCallback -> IO (FunPtr C_WidgetClassDragEndFieldCallback)

-- | /No description available in the introspection data./
type WidgetClassDragEndFieldCallback =
    Gtk.Widget.Widget
    -> Gdk.DragContext.DragContext
    -> IO ()

-- | A convenience synonym for @`Nothing` :: `Maybe` `WidgetClassDragEndFieldCallback`@.
noWidgetClassDragEndFieldCallback :: Maybe WidgetClassDragEndFieldCallback
noWidgetClassDragEndFieldCallback = Nothing

-- | Wrap the callback into a `GClosure`.
genClosure_WidgetClassDragEndFieldCallback :: MonadIO m => WidgetClassDragEndFieldCallback -> m (GClosure C_WidgetClassDragEndFieldCallback)
genClosure_WidgetClassDragEndFieldCallback cb = liftIO $ do
    let cb' = wrap_WidgetClassDragEndFieldCallback Nothing cb
    mk_WidgetClassDragEndFieldCallback cb' >>= B.GClosure.newGClosure


-- | Wrap a `WidgetClassDragEndFieldCallback` into a `C_WidgetClassDragEndFieldCallback`.
wrap_WidgetClassDragEndFieldCallback :: 
    Maybe (Ptr (FunPtr C_WidgetClassDragEndFieldCallback)) ->
    WidgetClassDragEndFieldCallback ->
    C_WidgetClassDragEndFieldCallback
wrap_WidgetClassDragEndFieldCallback gi'funptrptr gi'cb widget context = do
    widget' <- (newObject Gtk.Widget.Widget) widget
    context' <- (newObject Gdk.DragContext.DragContext) context
    gi'cb  widget' context'
    maybeReleaseFunPtr gi'funptrptr


-- callback WidgetClassDragDropFieldCallback
{- Callable
  { returnType = Just (TBasicType TBoolean)
  , returnMayBeNull = False
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , args =
      [ Arg
          { argCName = "widget"
          , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "context"
          , argType =
              TInterface Name { namespace = "Gdk" , name = "DragContext" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "x"
          , argType = TBasicType TInt
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "y"
          , argType = TBasicType TInt
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "time_"
          , argType = TBasicType TUInt
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_WidgetClassDragDropFieldCallback =
    Ptr Gtk.Widget.Widget ->
    Ptr Gdk.DragContext.DragContext ->
    Int32 ->
    Int32 ->
    Word32 ->
    IO CInt

-- Args: [ Arg
--           { argCName = "widget"
--           , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "context"
--           , argType =
--               TInterface Name { namespace = "Gdk" , name = "DragContext" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "x"
--           , argType = TBasicType TInt
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "y"
--           , argType = TBasicType TInt
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "time_"
--           , argType = TBasicType TUInt
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Just (TBasicType TBoolean)
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_WidgetClassDragDropFieldCallback :: FunPtr C_WidgetClassDragDropFieldCallback -> C_WidgetClassDragDropFieldCallback

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_WidgetClassDragDropFieldCallback ::
    (B.CallStack.HasCallStack, MonadIO m, Gtk.Widget.IsWidget a, Gdk.DragContext.IsDragContext b) =>
    FunPtr C_WidgetClassDragDropFieldCallback
    -> a
    -> b
    -> Int32
    -> Int32
    -> Word32
    -> m Bool
dynamic_WidgetClassDragDropFieldCallback __funPtr widget context x y time_ = liftIO $ do
    widget' <- unsafeManagedPtrCastPtr widget
    context' <- unsafeManagedPtrCastPtr context
    result <- (__dynamic_C_WidgetClassDragDropFieldCallback __funPtr) widget' context' x y time_
    let result' = (/= 0) result
    touchManagedPtr widget
    touchManagedPtr context
    return result'

-- | Generate a function pointer callable from C code, from a `C_WidgetClassDragDropFieldCallback`.
foreign import ccall "wrapper"
    mk_WidgetClassDragDropFieldCallback :: C_WidgetClassDragDropFieldCallback -> IO (FunPtr C_WidgetClassDragDropFieldCallback)

-- | /No description available in the introspection data./
type WidgetClassDragDropFieldCallback =
    Gtk.Widget.Widget
    -> Gdk.DragContext.DragContext
    -> Int32
    -> Int32
    -> Word32
    -> IO Bool

-- | A convenience synonym for @`Nothing` :: `Maybe` `WidgetClassDragDropFieldCallback`@.
noWidgetClassDragDropFieldCallback :: Maybe WidgetClassDragDropFieldCallback
noWidgetClassDragDropFieldCallback = Nothing

-- | Wrap the callback into a `GClosure`.
genClosure_WidgetClassDragDropFieldCallback :: MonadIO m => WidgetClassDragDropFieldCallback -> m (GClosure C_WidgetClassDragDropFieldCallback)
genClosure_WidgetClassDragDropFieldCallback cb = liftIO $ do
    let cb' = wrap_WidgetClassDragDropFieldCallback Nothing cb
    mk_WidgetClassDragDropFieldCallback cb' >>= B.GClosure.newGClosure


-- | Wrap a `WidgetClassDragDropFieldCallback` into a `C_WidgetClassDragDropFieldCallback`.
wrap_WidgetClassDragDropFieldCallback :: 
    Maybe (Ptr (FunPtr C_WidgetClassDragDropFieldCallback)) ->
    WidgetClassDragDropFieldCallback ->
    C_WidgetClassDragDropFieldCallback
wrap_WidgetClassDragDropFieldCallback gi'funptrptr gi'cb widget context x y time_ = do
    widget' <- (newObject Gtk.Widget.Widget) widget
    context' <- (newObject Gdk.DragContext.DragContext) context
    result <- gi'cb  widget' context' x y time_
    maybeReleaseFunPtr gi'funptrptr
    let result' = (fromIntegral . fromEnum) result
    return result'


-- callback WidgetClassDragDataReceivedFieldCallback
{- Callable
  { returnType = Nothing
  , returnMayBeNull = False
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , args =
      [ Arg
          { argCName = "widget"
          , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "context"
          , argType =
              TInterface Name { namespace = "Gdk" , name = "DragContext" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "x"
          , argType = TBasicType TInt
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "y"
          , argType = TBasicType TInt
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "selection_data"
          , argType =
              TInterface Name { namespace = "Gtk" , name = "SelectionData" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "info"
          , argType = TBasicType TUInt
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "time_"
          , argType = TBasicType TUInt
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_WidgetClassDragDataReceivedFieldCallback =
    Ptr Gtk.Widget.Widget ->
    Ptr Gdk.DragContext.DragContext ->
    Int32 ->
    Int32 ->
    Ptr Gtk.SelectionData.SelectionData ->
    Word32 ->
    Word32 ->
    IO ()

-- Args: [ Arg
--           { argCName = "widget"
--           , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "context"
--           , argType =
--               TInterface Name { namespace = "Gdk" , name = "DragContext" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "x"
--           , argType = TBasicType TInt
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "y"
--           , argType = TBasicType TInt
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "selection_data"
--           , argType =
--               TInterface Name { namespace = "Gtk" , name = "SelectionData" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "info"
--           , argType = TBasicType TUInt
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "time_"
--           , argType = TBasicType TUInt
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Nothing
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_WidgetClassDragDataReceivedFieldCallback :: FunPtr C_WidgetClassDragDataReceivedFieldCallback -> C_WidgetClassDragDataReceivedFieldCallback

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_WidgetClassDragDataReceivedFieldCallback ::
    (B.CallStack.HasCallStack, MonadIO m, Gtk.Widget.IsWidget a, Gdk.DragContext.IsDragContext b) =>
    FunPtr C_WidgetClassDragDataReceivedFieldCallback
    -> a
    -> b
    -> Int32
    -> Int32
    -> Gtk.SelectionData.SelectionData
    -> Word32
    -> Word32
    -> m ()
dynamic_WidgetClassDragDataReceivedFieldCallback __funPtr widget context x y selectionData info time_ = liftIO $ do
    widget' <- unsafeManagedPtrCastPtr widget
    context' <- unsafeManagedPtrCastPtr context
    selectionData' <- unsafeManagedPtrGetPtr selectionData
    (__dynamic_C_WidgetClassDragDataReceivedFieldCallback __funPtr) widget' context' x y selectionData' info time_
    touchManagedPtr widget
    touchManagedPtr context
    touchManagedPtr selectionData
    return ()

-- | Generate a function pointer callable from C code, from a `C_WidgetClassDragDataReceivedFieldCallback`.
foreign import ccall "wrapper"
    mk_WidgetClassDragDataReceivedFieldCallback :: C_WidgetClassDragDataReceivedFieldCallback -> IO (FunPtr C_WidgetClassDragDataReceivedFieldCallback)

-- | /No description available in the introspection data./
type WidgetClassDragDataReceivedFieldCallback =
    Gtk.Widget.Widget
    -> Gdk.DragContext.DragContext
    -> Int32
    -> Int32
    -> Gtk.SelectionData.SelectionData
    -> Word32
    -> Word32
    -> IO ()

-- | A convenience synonym for @`Nothing` :: `Maybe` `WidgetClassDragDataReceivedFieldCallback`@.
noWidgetClassDragDataReceivedFieldCallback :: Maybe WidgetClassDragDataReceivedFieldCallback
noWidgetClassDragDataReceivedFieldCallback = Nothing

-- | Wrap the callback into a `GClosure`.
genClosure_WidgetClassDragDataReceivedFieldCallback :: MonadIO m => WidgetClassDragDataReceivedFieldCallback -> m (GClosure C_WidgetClassDragDataReceivedFieldCallback)
genClosure_WidgetClassDragDataReceivedFieldCallback cb = liftIO $ do
    let cb' = wrap_WidgetClassDragDataReceivedFieldCallback Nothing cb
    mk_WidgetClassDragDataReceivedFieldCallback cb' >>= B.GClosure.newGClosure


-- | Wrap a `WidgetClassDragDataReceivedFieldCallback` into a `C_WidgetClassDragDataReceivedFieldCallback`.
wrap_WidgetClassDragDataReceivedFieldCallback :: 
    Maybe (Ptr (FunPtr C_WidgetClassDragDataReceivedFieldCallback)) ->
    WidgetClassDragDataReceivedFieldCallback ->
    C_WidgetClassDragDataReceivedFieldCallback
wrap_WidgetClassDragDataReceivedFieldCallback gi'funptrptr gi'cb widget context x y selectionData info time_ = do
    widget' <- (newObject Gtk.Widget.Widget) widget
    context' <- (newObject Gdk.DragContext.DragContext) context
    B.ManagedPtr.withTransient  selectionData $ \selectionData' -> do
        gi'cb  widget' context' x y selectionData' info time_
        maybeReleaseFunPtr gi'funptrptr


-- callback WidgetClassDragDataGetFieldCallback
{- Callable
  { returnType = Nothing
  , returnMayBeNull = False
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , args =
      [ Arg
          { argCName = "widget"
          , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "context"
          , argType =
              TInterface Name { namespace = "Gdk" , name = "DragContext" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "selection_data"
          , argType =
              TInterface Name { namespace = "Gtk" , name = "SelectionData" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "info"
          , argType = TBasicType TUInt
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "time_"
          , argType = TBasicType TUInt
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_WidgetClassDragDataGetFieldCallback =
    Ptr Gtk.Widget.Widget ->
    Ptr Gdk.DragContext.DragContext ->
    Ptr Gtk.SelectionData.SelectionData ->
    Word32 ->
    Word32 ->
    IO ()

-- Args: [ Arg
--           { argCName = "widget"
--           , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "context"
--           , argType =
--               TInterface Name { namespace = "Gdk" , name = "DragContext" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "selection_data"
--           , argType =
--               TInterface Name { namespace = "Gtk" , name = "SelectionData" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "info"
--           , argType = TBasicType TUInt
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "time_"
--           , argType = TBasicType TUInt
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Nothing
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_WidgetClassDragDataGetFieldCallback :: FunPtr C_WidgetClassDragDataGetFieldCallback -> C_WidgetClassDragDataGetFieldCallback

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_WidgetClassDragDataGetFieldCallback ::
    (B.CallStack.HasCallStack, MonadIO m, Gtk.Widget.IsWidget a, Gdk.DragContext.IsDragContext b) =>
    FunPtr C_WidgetClassDragDataGetFieldCallback
    -> a
    -> b
    -> Gtk.SelectionData.SelectionData
    -> Word32
    -> Word32
    -> m ()
dynamic_WidgetClassDragDataGetFieldCallback __funPtr widget context selectionData info time_ = liftIO $ do
    widget' <- unsafeManagedPtrCastPtr widget
    context' <- unsafeManagedPtrCastPtr context
    selectionData' <- unsafeManagedPtrGetPtr selectionData
    (__dynamic_C_WidgetClassDragDataGetFieldCallback __funPtr) widget' context' selectionData' info time_
    touchManagedPtr widget
    touchManagedPtr context
    touchManagedPtr selectionData
    return ()

-- | Generate a function pointer callable from C code, from a `C_WidgetClassDragDataGetFieldCallback`.
foreign import ccall "wrapper"
    mk_WidgetClassDragDataGetFieldCallback :: C_WidgetClassDragDataGetFieldCallback -> IO (FunPtr C_WidgetClassDragDataGetFieldCallback)

-- | /No description available in the introspection data./
type WidgetClassDragDataGetFieldCallback =
    Gtk.Widget.Widget
    -> Gdk.DragContext.DragContext
    -> Gtk.SelectionData.SelectionData
    -> Word32
    -> Word32
    -> IO ()

-- | A convenience synonym for @`Nothing` :: `Maybe` `WidgetClassDragDataGetFieldCallback`@.
noWidgetClassDragDataGetFieldCallback :: Maybe WidgetClassDragDataGetFieldCallback
noWidgetClassDragDataGetFieldCallback = Nothing

-- | Wrap the callback into a `GClosure`.
genClosure_WidgetClassDragDataGetFieldCallback :: MonadIO m => WidgetClassDragDataGetFieldCallback -> m (GClosure C_WidgetClassDragDataGetFieldCallback)
genClosure_WidgetClassDragDataGetFieldCallback cb = liftIO $ do
    let cb' = wrap_WidgetClassDragDataGetFieldCallback Nothing cb
    mk_WidgetClassDragDataGetFieldCallback cb' >>= B.GClosure.newGClosure


-- | Wrap a `WidgetClassDragDataGetFieldCallback` into a `C_WidgetClassDragDataGetFieldCallback`.
wrap_WidgetClassDragDataGetFieldCallback :: 
    Maybe (Ptr (FunPtr C_WidgetClassDragDataGetFieldCallback)) ->
    WidgetClassDragDataGetFieldCallback ->
    C_WidgetClassDragDataGetFieldCallback
wrap_WidgetClassDragDataGetFieldCallback gi'funptrptr gi'cb widget context selectionData info time_ = do
    widget' <- (newObject Gtk.Widget.Widget) widget
    context' <- (newObject Gdk.DragContext.DragContext) context
    B.ManagedPtr.withTransient  selectionData $ \selectionData' -> do
        gi'cb  widget' context' selectionData' info time_
        maybeReleaseFunPtr gi'funptrptr


-- callback WidgetClassDragDataDeleteFieldCallback
{- Callable
  { returnType = Nothing
  , returnMayBeNull = False
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , args =
      [ Arg
          { argCName = "widget"
          , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "context"
          , argType =
              TInterface Name { namespace = "Gdk" , name = "DragContext" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_WidgetClassDragDataDeleteFieldCallback =
    Ptr Gtk.Widget.Widget ->
    Ptr Gdk.DragContext.DragContext ->
    IO ()

-- Args: [ Arg
--           { argCName = "widget"
--           , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "context"
--           , argType =
--               TInterface Name { namespace = "Gdk" , name = "DragContext" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Nothing
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_WidgetClassDragDataDeleteFieldCallback :: FunPtr C_WidgetClassDragDataDeleteFieldCallback -> C_WidgetClassDragDataDeleteFieldCallback

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_WidgetClassDragDataDeleteFieldCallback ::
    (B.CallStack.HasCallStack, MonadIO m, Gtk.Widget.IsWidget a, Gdk.DragContext.IsDragContext b) =>
    FunPtr C_WidgetClassDragDataDeleteFieldCallback
    -> a
    -> b
    -> m ()
dynamic_WidgetClassDragDataDeleteFieldCallback __funPtr widget context = liftIO $ do
    widget' <- unsafeManagedPtrCastPtr widget
    context' <- unsafeManagedPtrCastPtr context
    (__dynamic_C_WidgetClassDragDataDeleteFieldCallback __funPtr) widget' context'
    touchManagedPtr widget
    touchManagedPtr context
    return ()

-- | Generate a function pointer callable from C code, from a `C_WidgetClassDragDataDeleteFieldCallback`.
foreign import ccall "wrapper"
    mk_WidgetClassDragDataDeleteFieldCallback :: C_WidgetClassDragDataDeleteFieldCallback -> IO (FunPtr C_WidgetClassDragDataDeleteFieldCallback)

-- | /No description available in the introspection data./
type WidgetClassDragDataDeleteFieldCallback =
    Gtk.Widget.Widget
    -> Gdk.DragContext.DragContext
    -> IO ()

-- | A convenience synonym for @`Nothing` :: `Maybe` `WidgetClassDragDataDeleteFieldCallback`@.
noWidgetClassDragDataDeleteFieldCallback :: Maybe WidgetClassDragDataDeleteFieldCallback
noWidgetClassDragDataDeleteFieldCallback = Nothing

-- | Wrap the callback into a `GClosure`.
genClosure_WidgetClassDragDataDeleteFieldCallback :: MonadIO m => WidgetClassDragDataDeleteFieldCallback -> m (GClosure C_WidgetClassDragDataDeleteFieldCallback)
genClosure_WidgetClassDragDataDeleteFieldCallback cb = liftIO $ do
    let cb' = wrap_WidgetClassDragDataDeleteFieldCallback Nothing cb
    mk_WidgetClassDragDataDeleteFieldCallback cb' >>= B.GClosure.newGClosure


-- | Wrap a `WidgetClassDragDataDeleteFieldCallback` into a `C_WidgetClassDragDataDeleteFieldCallback`.
wrap_WidgetClassDragDataDeleteFieldCallback :: 
    Maybe (Ptr (FunPtr C_WidgetClassDragDataDeleteFieldCallback)) ->
    WidgetClassDragDataDeleteFieldCallback ->
    C_WidgetClassDragDataDeleteFieldCallback
wrap_WidgetClassDragDataDeleteFieldCallback gi'funptrptr gi'cb widget context = do
    widget' <- (newObject Gtk.Widget.Widget) widget
    context' <- (newObject Gdk.DragContext.DragContext) context
    gi'cb  widget' context'
    maybeReleaseFunPtr gi'funptrptr


-- callback WidgetClassDragBeginFieldCallback
{- Callable
  { returnType = Nothing
  , returnMayBeNull = False
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , args =
      [ Arg
          { argCName = "widget"
          , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "context"
          , argType =
              TInterface Name { namespace = "Gdk" , name = "DragContext" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_WidgetClassDragBeginFieldCallback =
    Ptr Gtk.Widget.Widget ->
    Ptr Gdk.DragContext.DragContext ->
    IO ()

-- Args: [ Arg
--           { argCName = "widget"
--           , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "context"
--           , argType =
--               TInterface Name { namespace = "Gdk" , name = "DragContext" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Nothing
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_WidgetClassDragBeginFieldCallback :: FunPtr C_WidgetClassDragBeginFieldCallback -> C_WidgetClassDragBeginFieldCallback

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_WidgetClassDragBeginFieldCallback ::
    (B.CallStack.HasCallStack, MonadIO m, Gtk.Widget.IsWidget a, Gdk.DragContext.IsDragContext b) =>
    FunPtr C_WidgetClassDragBeginFieldCallback
    -> a
    -> b
    -> m ()
dynamic_WidgetClassDragBeginFieldCallback __funPtr widget context = liftIO $ do
    widget' <- unsafeManagedPtrCastPtr widget
    context' <- unsafeManagedPtrCastPtr context
    (__dynamic_C_WidgetClassDragBeginFieldCallback __funPtr) widget' context'
    touchManagedPtr widget
    touchManagedPtr context
    return ()

-- | Generate a function pointer callable from C code, from a `C_WidgetClassDragBeginFieldCallback`.
foreign import ccall "wrapper"
    mk_WidgetClassDragBeginFieldCallback :: C_WidgetClassDragBeginFieldCallback -> IO (FunPtr C_WidgetClassDragBeginFieldCallback)

-- | /No description available in the introspection data./
type WidgetClassDragBeginFieldCallback =
    Gtk.Widget.Widget
    -> Gdk.DragContext.DragContext
    -> IO ()

-- | A convenience synonym for @`Nothing` :: `Maybe` `WidgetClassDragBeginFieldCallback`@.
noWidgetClassDragBeginFieldCallback :: Maybe WidgetClassDragBeginFieldCallback
noWidgetClassDragBeginFieldCallback = Nothing

-- | Wrap the callback into a `GClosure`.
genClosure_WidgetClassDragBeginFieldCallback :: MonadIO m => WidgetClassDragBeginFieldCallback -> m (GClosure C_WidgetClassDragBeginFieldCallback)
genClosure_WidgetClassDragBeginFieldCallback cb = liftIO $ do
    let cb' = wrap_WidgetClassDragBeginFieldCallback Nothing cb
    mk_WidgetClassDragBeginFieldCallback cb' >>= B.GClosure.newGClosure


-- | Wrap a `WidgetClassDragBeginFieldCallback` into a `C_WidgetClassDragBeginFieldCallback`.
wrap_WidgetClassDragBeginFieldCallback :: 
    Maybe (Ptr (FunPtr C_WidgetClassDragBeginFieldCallback)) ->
    WidgetClassDragBeginFieldCallback ->
    C_WidgetClassDragBeginFieldCallback
wrap_WidgetClassDragBeginFieldCallback gi'funptrptr gi'cb widget context = do
    widget' <- (newObject Gtk.Widget.Widget) widget
    context' <- (newObject Gdk.DragContext.DragContext) context
    gi'cb  widget' context'
    maybeReleaseFunPtr gi'funptrptr


-- callback WidgetClassDispatchChildPropertiesChangedFieldCallback
{- Callable
  { returnType = Nothing
  , returnMayBeNull = False
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , args =
      [ Arg
          { argCName = "widget"
          , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "n_pspecs"
          , argType = TBasicType TUInt
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "pspecs"
          , argType = TParamSpec
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_WidgetClassDispatchChildPropertiesChangedFieldCallback =
    Ptr Gtk.Widget.Widget ->
    Word32 ->
    Ptr GParamSpec ->
    IO ()

-- Args: [ Arg
--           { argCName = "widget"
--           , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "n_pspecs"
--           , argType = TBasicType TUInt
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "pspecs"
--           , argType = TParamSpec
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Nothing
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_WidgetClassDispatchChildPropertiesChangedFieldCallback :: FunPtr C_WidgetClassDispatchChildPropertiesChangedFieldCallback -> C_WidgetClassDispatchChildPropertiesChangedFieldCallback

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_WidgetClassDispatchChildPropertiesChangedFieldCallback ::
    (B.CallStack.HasCallStack, MonadIO m, Gtk.Widget.IsWidget a) =>
    FunPtr C_WidgetClassDispatchChildPropertiesChangedFieldCallback
    -> a
    -> Word32
    -> GParamSpec
    -> m ()
dynamic_WidgetClassDispatchChildPropertiesChangedFieldCallback __funPtr widget nPspecs pspecs = liftIO $ do
    widget' <- unsafeManagedPtrCastPtr widget
    pspecs' <- unsafeManagedPtrGetPtr pspecs
    (__dynamic_C_WidgetClassDispatchChildPropertiesChangedFieldCallback __funPtr) widget' nPspecs pspecs'
    touchManagedPtr widget
    touchManagedPtr pspecs
    return ()

-- | Generate a function pointer callable from C code, from a `C_WidgetClassDispatchChildPropertiesChangedFieldCallback`.
foreign import ccall "wrapper"
    mk_WidgetClassDispatchChildPropertiesChangedFieldCallback :: C_WidgetClassDispatchChildPropertiesChangedFieldCallback -> IO (FunPtr C_WidgetClassDispatchChildPropertiesChangedFieldCallback)

-- | /No description available in the introspection data./
type WidgetClassDispatchChildPropertiesChangedFieldCallback =
    Gtk.Widget.Widget
    -> Word32
    -> GParamSpec
    -> IO ()

-- | A convenience synonym for @`Nothing` :: `Maybe` `WidgetClassDispatchChildPropertiesChangedFieldCallback`@.
noWidgetClassDispatchChildPropertiesChangedFieldCallback :: Maybe WidgetClassDispatchChildPropertiesChangedFieldCallback
noWidgetClassDispatchChildPropertiesChangedFieldCallback = Nothing

-- | Wrap the callback into a `GClosure`.
genClosure_WidgetClassDispatchChildPropertiesChangedFieldCallback :: MonadIO m => WidgetClassDispatchChildPropertiesChangedFieldCallback -> m (GClosure C_WidgetClassDispatchChildPropertiesChangedFieldCallback)
genClosure_WidgetClassDispatchChildPropertiesChangedFieldCallback cb = liftIO $ do
    let cb' = wrap_WidgetClassDispatchChildPropertiesChangedFieldCallback Nothing cb
    mk_WidgetClassDispatchChildPropertiesChangedFieldCallback cb' >>= B.GClosure.newGClosure


-- | Wrap a `WidgetClassDispatchChildPropertiesChangedFieldCallback` into a `C_WidgetClassDispatchChildPropertiesChangedFieldCallback`.
wrap_WidgetClassDispatchChildPropertiesChangedFieldCallback :: 
    Maybe (Ptr (FunPtr C_WidgetClassDispatchChildPropertiesChangedFieldCallback)) ->
    WidgetClassDispatchChildPropertiesChangedFieldCallback ->
    C_WidgetClassDispatchChildPropertiesChangedFieldCallback
wrap_WidgetClassDispatchChildPropertiesChangedFieldCallback gi'funptrptr gi'cb widget nPspecs pspecs = do
    widget' <- (newObject Gtk.Widget.Widget) widget
    pspecs' <- B.GParamSpec.newGParamSpecFromPtr pspecs
    gi'cb  widget' nPspecs pspecs'
    maybeReleaseFunPtr gi'funptrptr


-- callback WidgetClassDirectionChangedFieldCallback
{- Callable
  { returnType = Nothing
  , returnMayBeNull = False
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , args =
      [ Arg
          { argCName = "widget"
          , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "previous_direction"
          , argType =
              TInterface Name { namespace = "Gtk" , name = "TextDirection" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_WidgetClassDirectionChangedFieldCallback =
    Ptr Gtk.Widget.Widget ->
    CUInt ->
    IO ()

-- Args: [ Arg
--           { argCName = "widget"
--           , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "previous_direction"
--           , argType =
--               TInterface Name { namespace = "Gtk" , name = "TextDirection" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Nothing
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_WidgetClassDirectionChangedFieldCallback :: FunPtr C_WidgetClassDirectionChangedFieldCallback -> C_WidgetClassDirectionChangedFieldCallback

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_WidgetClassDirectionChangedFieldCallback ::
    (B.CallStack.HasCallStack, MonadIO m, Gtk.Widget.IsWidget a) =>
    FunPtr C_WidgetClassDirectionChangedFieldCallback
    -> a
    -> Gtk.Enums.TextDirection
    -> m ()
dynamic_WidgetClassDirectionChangedFieldCallback __funPtr widget previousDirection = liftIO $ do
    widget' <- unsafeManagedPtrCastPtr widget
    let previousDirection' = (fromIntegral . fromEnum) previousDirection
    (__dynamic_C_WidgetClassDirectionChangedFieldCallback __funPtr) widget' previousDirection'
    touchManagedPtr widget
    return ()

-- | Generate a function pointer callable from C code, from a `C_WidgetClassDirectionChangedFieldCallback`.
foreign import ccall "wrapper"
    mk_WidgetClassDirectionChangedFieldCallback :: C_WidgetClassDirectionChangedFieldCallback -> IO (FunPtr C_WidgetClassDirectionChangedFieldCallback)

-- | /No description available in the introspection data./
type WidgetClassDirectionChangedFieldCallback =
    Gtk.Widget.Widget
    -> Gtk.Enums.TextDirection
    -> IO ()

-- | A convenience synonym for @`Nothing` :: `Maybe` `WidgetClassDirectionChangedFieldCallback`@.
noWidgetClassDirectionChangedFieldCallback :: Maybe WidgetClassDirectionChangedFieldCallback
noWidgetClassDirectionChangedFieldCallback = Nothing

-- | Wrap the callback into a `GClosure`.
genClosure_WidgetClassDirectionChangedFieldCallback :: MonadIO m => WidgetClassDirectionChangedFieldCallback -> m (GClosure C_WidgetClassDirectionChangedFieldCallback)
genClosure_WidgetClassDirectionChangedFieldCallback cb = liftIO $ do
    let cb' = wrap_WidgetClassDirectionChangedFieldCallback Nothing cb
    mk_WidgetClassDirectionChangedFieldCallback cb' >>= B.GClosure.newGClosure


-- | Wrap a `WidgetClassDirectionChangedFieldCallback` into a `C_WidgetClassDirectionChangedFieldCallback`.
wrap_WidgetClassDirectionChangedFieldCallback :: 
    Maybe (Ptr (FunPtr C_WidgetClassDirectionChangedFieldCallback)) ->
    WidgetClassDirectionChangedFieldCallback ->
    C_WidgetClassDirectionChangedFieldCallback
wrap_WidgetClassDirectionChangedFieldCallback gi'funptrptr gi'cb widget previousDirection = do
    widget' <- (newObject Gtk.Widget.Widget) widget
    let previousDirection' = (toEnum . fromIntegral) previousDirection
    gi'cb  widget' previousDirection'
    maybeReleaseFunPtr gi'funptrptr


-- callback WidgetClassDestroyFieldCallback
{- Callable
  { returnType = Nothing
  , returnMayBeNull = False
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , args =
      [ Arg
          { argCName = "widget"
          , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText = Just "a #GtkWidget" , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_WidgetClassDestroyFieldCallback =
    Ptr Gtk.Widget.Widget ->
    IO ()

-- Args: [ Arg
--           { argCName = "widget"
--           , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "a #GtkWidget" , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Nothing
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_WidgetClassDestroyFieldCallback :: FunPtr C_WidgetClassDestroyFieldCallback -> C_WidgetClassDestroyFieldCallback

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_WidgetClassDestroyFieldCallback ::
    (B.CallStack.HasCallStack, MonadIO m, Gtk.Widget.IsWidget a) =>
    FunPtr C_WidgetClassDestroyFieldCallback
    -> a
    -- ^ /@widget@/: a t'GI.Gtk.Objects.Widget.Widget'
    -> m ()
dynamic_WidgetClassDestroyFieldCallback __funPtr widget = liftIO $ do
    widget' <- unsafeManagedPtrCastPtr widget
    (__dynamic_C_WidgetClassDestroyFieldCallback __funPtr) widget'
    touchManagedPtr widget
    return ()

-- | Generate a function pointer callable from C code, from a `C_WidgetClassDestroyFieldCallback`.
foreign import ccall "wrapper"
    mk_WidgetClassDestroyFieldCallback :: C_WidgetClassDestroyFieldCallback -> IO (FunPtr C_WidgetClassDestroyFieldCallback)

-- | /No description available in the introspection data./
type WidgetClassDestroyFieldCallback =
    Gtk.Widget.Widget
    -- ^ /@widget@/: a t'GI.Gtk.Objects.Widget.Widget'
    -> IO ()

-- | A convenience synonym for @`Nothing` :: `Maybe` `WidgetClassDestroyFieldCallback`@.
noWidgetClassDestroyFieldCallback :: Maybe WidgetClassDestroyFieldCallback
noWidgetClassDestroyFieldCallback = Nothing

-- | Wrap the callback into a `GClosure`.
genClosure_WidgetClassDestroyFieldCallback :: MonadIO m => WidgetClassDestroyFieldCallback -> m (GClosure C_WidgetClassDestroyFieldCallback)
genClosure_WidgetClassDestroyFieldCallback cb = liftIO $ do
    let cb' = wrap_WidgetClassDestroyFieldCallback Nothing cb
    mk_WidgetClassDestroyFieldCallback cb' >>= B.GClosure.newGClosure


-- | Wrap a `WidgetClassDestroyFieldCallback` into a `C_WidgetClassDestroyFieldCallback`.
wrap_WidgetClassDestroyFieldCallback :: 
    Maybe (Ptr (FunPtr C_WidgetClassDestroyFieldCallback)) ->
    WidgetClassDestroyFieldCallback ->
    C_WidgetClassDestroyFieldCallback
wrap_WidgetClassDestroyFieldCallback gi'funptrptr gi'cb widget = do
    widget' <- (newObject Gtk.Widget.Widget) widget
    gi'cb  widget'
    maybeReleaseFunPtr gi'funptrptr


-- callback WidgetClassDestroyEventFieldCallback
{- Callable
  { returnType = Just (TBasicType TBoolean)
  , returnMayBeNull = False
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , args =
      [ Arg
          { argCName = "widget"
          , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "event"
          , argType =
              TInterface Name { namespace = "Gdk" , name = "EventAny" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_WidgetClassDestroyEventFieldCallback =
    Ptr Gtk.Widget.Widget ->
    Ptr Gdk.EventAny.EventAny ->
    IO CInt

-- Args: [ Arg
--           { argCName = "widget"
--           , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "event"
--           , argType =
--               TInterface Name { namespace = "Gdk" , name = "EventAny" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Just (TBasicType TBoolean)
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_WidgetClassDestroyEventFieldCallback :: FunPtr C_WidgetClassDestroyEventFieldCallback -> C_WidgetClassDestroyEventFieldCallback

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_WidgetClassDestroyEventFieldCallback ::
    (B.CallStack.HasCallStack, MonadIO m, Gtk.Widget.IsWidget a) =>
    FunPtr C_WidgetClassDestroyEventFieldCallback
    -> a
    -> Gdk.EventAny.EventAny
    -> m Bool
dynamic_WidgetClassDestroyEventFieldCallback __funPtr widget event = liftIO $ do
    widget' <- unsafeManagedPtrCastPtr widget
    event' <- unsafeManagedPtrGetPtr event
    result <- (__dynamic_C_WidgetClassDestroyEventFieldCallback __funPtr) widget' event'
    let result' = (/= 0) result
    touchManagedPtr widget
    touchManagedPtr event
    return result'

-- | Generate a function pointer callable from C code, from a `C_WidgetClassDestroyEventFieldCallback`.
foreign import ccall "wrapper"
    mk_WidgetClassDestroyEventFieldCallback :: C_WidgetClassDestroyEventFieldCallback -> IO (FunPtr C_WidgetClassDestroyEventFieldCallback)

-- | /No description available in the introspection data./
type WidgetClassDestroyEventFieldCallback =
    Gtk.Widget.Widget
    -> Gdk.EventAny.EventAny
    -> IO Bool

-- | A convenience synonym for @`Nothing` :: `Maybe` `WidgetClassDestroyEventFieldCallback`@.
noWidgetClassDestroyEventFieldCallback :: Maybe WidgetClassDestroyEventFieldCallback
noWidgetClassDestroyEventFieldCallback = Nothing

-- | Wrap the callback into a `GClosure`.
genClosure_WidgetClassDestroyEventFieldCallback :: MonadIO m => WidgetClassDestroyEventFieldCallback -> m (GClosure C_WidgetClassDestroyEventFieldCallback)
genClosure_WidgetClassDestroyEventFieldCallback cb = liftIO $ do
    let cb' = wrap_WidgetClassDestroyEventFieldCallback Nothing cb
    mk_WidgetClassDestroyEventFieldCallback cb' >>= B.GClosure.newGClosure


-- | Wrap a `WidgetClassDestroyEventFieldCallback` into a `C_WidgetClassDestroyEventFieldCallback`.
wrap_WidgetClassDestroyEventFieldCallback :: 
    Maybe (Ptr (FunPtr C_WidgetClassDestroyEventFieldCallback)) ->
    WidgetClassDestroyEventFieldCallback ->
    C_WidgetClassDestroyEventFieldCallback
wrap_WidgetClassDestroyEventFieldCallback gi'funptrptr gi'cb widget event = do
    widget' <- (newObject Gtk.Widget.Widget) widget
    event' <- (newPtr Gdk.EventAny.EventAny) event
    result <- gi'cb  widget' event'
    maybeReleaseFunPtr gi'funptrptr
    let result' = (fromIntegral . fromEnum) result
    return result'


-- callback WidgetClassDeleteEventFieldCallback
{- Callable
  { returnType = Just (TBasicType TBoolean)
  , returnMayBeNull = False
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , args =
      [ Arg
          { argCName = "widget"
          , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "event"
          , argType =
              TInterface Name { namespace = "Gdk" , name = "EventAny" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_WidgetClassDeleteEventFieldCallback =
    Ptr Gtk.Widget.Widget ->
    Ptr Gdk.EventAny.EventAny ->
    IO CInt

-- Args: [ Arg
--           { argCName = "widget"
--           , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "event"
--           , argType =
--               TInterface Name { namespace = "Gdk" , name = "EventAny" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Just (TBasicType TBoolean)
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_WidgetClassDeleteEventFieldCallback :: FunPtr C_WidgetClassDeleteEventFieldCallback -> C_WidgetClassDeleteEventFieldCallback

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_WidgetClassDeleteEventFieldCallback ::
    (B.CallStack.HasCallStack, MonadIO m, Gtk.Widget.IsWidget a) =>
    FunPtr C_WidgetClassDeleteEventFieldCallback
    -> a
    -> Gdk.EventAny.EventAny
    -> m Bool
dynamic_WidgetClassDeleteEventFieldCallback __funPtr widget event = liftIO $ do
    widget' <- unsafeManagedPtrCastPtr widget
    event' <- unsafeManagedPtrGetPtr event
    result <- (__dynamic_C_WidgetClassDeleteEventFieldCallback __funPtr) widget' event'
    let result' = (/= 0) result
    touchManagedPtr widget
    touchManagedPtr event
    return result'

-- | Generate a function pointer callable from C code, from a `C_WidgetClassDeleteEventFieldCallback`.
foreign import ccall "wrapper"
    mk_WidgetClassDeleteEventFieldCallback :: C_WidgetClassDeleteEventFieldCallback -> IO (FunPtr C_WidgetClassDeleteEventFieldCallback)

-- | /No description available in the introspection data./
type WidgetClassDeleteEventFieldCallback =
    Gtk.Widget.Widget
    -> Gdk.EventAny.EventAny
    -> IO Bool

-- | A convenience synonym for @`Nothing` :: `Maybe` `WidgetClassDeleteEventFieldCallback`@.
noWidgetClassDeleteEventFieldCallback :: Maybe WidgetClassDeleteEventFieldCallback
noWidgetClassDeleteEventFieldCallback = Nothing

-- | Wrap the callback into a `GClosure`.
genClosure_WidgetClassDeleteEventFieldCallback :: MonadIO m => WidgetClassDeleteEventFieldCallback -> m (GClosure C_WidgetClassDeleteEventFieldCallback)
genClosure_WidgetClassDeleteEventFieldCallback cb = liftIO $ do
    let cb' = wrap_WidgetClassDeleteEventFieldCallback Nothing cb
    mk_WidgetClassDeleteEventFieldCallback cb' >>= B.GClosure.newGClosure


-- | Wrap a `WidgetClassDeleteEventFieldCallback` into a `C_WidgetClassDeleteEventFieldCallback`.
wrap_WidgetClassDeleteEventFieldCallback :: 
    Maybe (Ptr (FunPtr C_WidgetClassDeleteEventFieldCallback)) ->
    WidgetClassDeleteEventFieldCallback ->
    C_WidgetClassDeleteEventFieldCallback
wrap_WidgetClassDeleteEventFieldCallback gi'funptrptr gi'cb widget event = do
    widget' <- (newObject Gtk.Widget.Widget) widget
    event' <- (newPtr Gdk.EventAny.EventAny) event
    result <- gi'cb  widget' event'
    maybeReleaseFunPtr gi'funptrptr
    let result' = (fromIntegral . fromEnum) result
    return result'


-- callback WidgetClassDamageEventFieldCallback
{- Callable
  { returnType = Just (TBasicType TBoolean)
  , returnMayBeNull = False
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , args =
      [ Arg
          { argCName = "widget"
          , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "event"
          , argType =
              TInterface Name { namespace = "Gdk" , name = "EventExpose" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_WidgetClassDamageEventFieldCallback =
    Ptr Gtk.Widget.Widget ->
    Ptr Gdk.EventExpose.EventExpose ->
    IO CInt

-- Args: [ Arg
--           { argCName = "widget"
--           , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "event"
--           , argType =
--               TInterface Name { namespace = "Gdk" , name = "EventExpose" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Just (TBasicType TBoolean)
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_WidgetClassDamageEventFieldCallback :: FunPtr C_WidgetClassDamageEventFieldCallback -> C_WidgetClassDamageEventFieldCallback

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_WidgetClassDamageEventFieldCallback ::
    (B.CallStack.HasCallStack, MonadIO m, Gtk.Widget.IsWidget a) =>
    FunPtr C_WidgetClassDamageEventFieldCallback
    -> a
    -> Gdk.EventExpose.EventExpose
    -> m Bool
dynamic_WidgetClassDamageEventFieldCallback __funPtr widget event = liftIO $ do
    widget' <- unsafeManagedPtrCastPtr widget
    event' <- unsafeManagedPtrGetPtr event
    result <- (__dynamic_C_WidgetClassDamageEventFieldCallback __funPtr) widget' event'
    let result' = (/= 0) result
    touchManagedPtr widget
    touchManagedPtr event
    return result'

-- | Generate a function pointer callable from C code, from a `C_WidgetClassDamageEventFieldCallback`.
foreign import ccall "wrapper"
    mk_WidgetClassDamageEventFieldCallback :: C_WidgetClassDamageEventFieldCallback -> IO (FunPtr C_WidgetClassDamageEventFieldCallback)

-- | /No description available in the introspection data./
type WidgetClassDamageEventFieldCallback =
    Gtk.Widget.Widget
    -> Gdk.EventExpose.EventExpose
    -> IO Bool

-- | A convenience synonym for @`Nothing` :: `Maybe` `WidgetClassDamageEventFieldCallback`@.
noWidgetClassDamageEventFieldCallback :: Maybe WidgetClassDamageEventFieldCallback
noWidgetClassDamageEventFieldCallback = Nothing

-- | Wrap the callback into a `GClosure`.
genClosure_WidgetClassDamageEventFieldCallback :: MonadIO m => WidgetClassDamageEventFieldCallback -> m (GClosure C_WidgetClassDamageEventFieldCallback)
genClosure_WidgetClassDamageEventFieldCallback cb = liftIO $ do
    let cb' = wrap_WidgetClassDamageEventFieldCallback Nothing cb
    mk_WidgetClassDamageEventFieldCallback cb' >>= B.GClosure.newGClosure


-- | Wrap a `WidgetClassDamageEventFieldCallback` into a `C_WidgetClassDamageEventFieldCallback`.
wrap_WidgetClassDamageEventFieldCallback :: 
    Maybe (Ptr (FunPtr C_WidgetClassDamageEventFieldCallback)) ->
    WidgetClassDamageEventFieldCallback ->
    C_WidgetClassDamageEventFieldCallback
wrap_WidgetClassDamageEventFieldCallback gi'funptrptr gi'cb widget event = do
    widget' <- (newObject Gtk.Widget.Widget) widget
    event' <- (newPtr Gdk.EventExpose.EventExpose) event
    result <- gi'cb  widget' event'
    maybeReleaseFunPtr gi'funptrptr
    let result' = (fromIntegral . fromEnum) result
    return result'


-- callback WidgetClassConfigureEventFieldCallback
{- Callable
  { returnType = Just (TBasicType TBoolean)
  , returnMayBeNull = False
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , args =
      [ Arg
          { argCName = "widget"
          , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "event"
          , argType =
              TInterface Name { namespace = "Gdk" , name = "EventConfigure" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_WidgetClassConfigureEventFieldCallback =
    Ptr Gtk.Widget.Widget ->
    Ptr Gdk.EventConfigure.EventConfigure ->
    IO CInt

-- Args: [ Arg
--           { argCName = "widget"
--           , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "event"
--           , argType =
--               TInterface Name { namespace = "Gdk" , name = "EventConfigure" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Just (TBasicType TBoolean)
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_WidgetClassConfigureEventFieldCallback :: FunPtr C_WidgetClassConfigureEventFieldCallback -> C_WidgetClassConfigureEventFieldCallback

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_WidgetClassConfigureEventFieldCallback ::
    (B.CallStack.HasCallStack, MonadIO m, Gtk.Widget.IsWidget a) =>
    FunPtr C_WidgetClassConfigureEventFieldCallback
    -> a
    -> Gdk.EventConfigure.EventConfigure
    -> m Bool
dynamic_WidgetClassConfigureEventFieldCallback __funPtr widget event = liftIO $ do
    widget' <- unsafeManagedPtrCastPtr widget
    event' <- unsafeManagedPtrGetPtr event
    result <- (__dynamic_C_WidgetClassConfigureEventFieldCallback __funPtr) widget' event'
    let result' = (/= 0) result
    touchManagedPtr widget
    touchManagedPtr event
    return result'

-- | Generate a function pointer callable from C code, from a `C_WidgetClassConfigureEventFieldCallback`.
foreign import ccall "wrapper"
    mk_WidgetClassConfigureEventFieldCallback :: C_WidgetClassConfigureEventFieldCallback -> IO (FunPtr C_WidgetClassConfigureEventFieldCallback)

-- | /No description available in the introspection data./
type WidgetClassConfigureEventFieldCallback =
    Gtk.Widget.Widget
    -> Gdk.EventConfigure.EventConfigure
    -> IO Bool

-- | A convenience synonym for @`Nothing` :: `Maybe` `WidgetClassConfigureEventFieldCallback`@.
noWidgetClassConfigureEventFieldCallback :: Maybe WidgetClassConfigureEventFieldCallback
noWidgetClassConfigureEventFieldCallback = Nothing

-- | Wrap the callback into a `GClosure`.
genClosure_WidgetClassConfigureEventFieldCallback :: MonadIO m => WidgetClassConfigureEventFieldCallback -> m (GClosure C_WidgetClassConfigureEventFieldCallback)
genClosure_WidgetClassConfigureEventFieldCallback cb = liftIO $ do
    let cb' = wrap_WidgetClassConfigureEventFieldCallback Nothing cb
    mk_WidgetClassConfigureEventFieldCallback cb' >>= B.GClosure.newGClosure


-- | Wrap a `WidgetClassConfigureEventFieldCallback` into a `C_WidgetClassConfigureEventFieldCallback`.
wrap_WidgetClassConfigureEventFieldCallback :: 
    Maybe (Ptr (FunPtr C_WidgetClassConfigureEventFieldCallback)) ->
    WidgetClassConfigureEventFieldCallback ->
    C_WidgetClassConfigureEventFieldCallback
wrap_WidgetClassConfigureEventFieldCallback gi'funptrptr gi'cb widget event = do
    widget' <- (newObject Gtk.Widget.Widget) widget
    event' <- (newPtr Gdk.EventConfigure.EventConfigure) event
    result <- gi'cb  widget' event'
    maybeReleaseFunPtr gi'funptrptr
    let result' = (fromIntegral . fromEnum) result
    return result'


-- callback WidgetClassComputeExpandFieldCallback
{- Callable
  { returnType = Nothing
  , returnMayBeNull = False
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , args =
      [ Arg
          { argCName = "widget"
          , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "hexpand_p"
          , argType = TBasicType TBoolean
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "vexpand_p"
          , argType = TBasicType TBoolean
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_WidgetClassComputeExpandFieldCallback =
    Ptr Gtk.Widget.Widget ->
    CInt ->
    CInt ->
    IO ()

-- Args: [ Arg
--           { argCName = "widget"
--           , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "hexpand_p"
--           , argType = TBasicType TBoolean
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "vexpand_p"
--           , argType = TBasicType TBoolean
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Nothing
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_WidgetClassComputeExpandFieldCallback :: FunPtr C_WidgetClassComputeExpandFieldCallback -> C_WidgetClassComputeExpandFieldCallback

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_WidgetClassComputeExpandFieldCallback ::
    (B.CallStack.HasCallStack, MonadIO m, Gtk.Widget.IsWidget a) =>
    FunPtr C_WidgetClassComputeExpandFieldCallback
    -> a
    -> Bool
    -> Bool
    -> m ()
dynamic_WidgetClassComputeExpandFieldCallback __funPtr widget hexpandP vexpandP = liftIO $ do
    widget' <- unsafeManagedPtrCastPtr widget
    let hexpandP' = (fromIntegral . fromEnum) hexpandP
    let vexpandP' = (fromIntegral . fromEnum) vexpandP
    (__dynamic_C_WidgetClassComputeExpandFieldCallback __funPtr) widget' hexpandP' vexpandP'
    touchManagedPtr widget
    return ()

-- | Generate a function pointer callable from C code, from a `C_WidgetClassComputeExpandFieldCallback`.
foreign import ccall "wrapper"
    mk_WidgetClassComputeExpandFieldCallback :: C_WidgetClassComputeExpandFieldCallback -> IO (FunPtr C_WidgetClassComputeExpandFieldCallback)

-- | /No description available in the introspection data./
type WidgetClassComputeExpandFieldCallback =
    Gtk.Widget.Widget
    -> Bool
    -> Bool
    -> IO ()

-- | A convenience synonym for @`Nothing` :: `Maybe` `WidgetClassComputeExpandFieldCallback`@.
noWidgetClassComputeExpandFieldCallback :: Maybe WidgetClassComputeExpandFieldCallback
noWidgetClassComputeExpandFieldCallback = Nothing

-- | Wrap the callback into a `GClosure`.
genClosure_WidgetClassComputeExpandFieldCallback :: MonadIO m => WidgetClassComputeExpandFieldCallback -> m (GClosure C_WidgetClassComputeExpandFieldCallback)
genClosure_WidgetClassComputeExpandFieldCallback cb = liftIO $ do
    let cb' = wrap_WidgetClassComputeExpandFieldCallback Nothing cb
    mk_WidgetClassComputeExpandFieldCallback cb' >>= B.GClosure.newGClosure


-- | Wrap a `WidgetClassComputeExpandFieldCallback` into a `C_WidgetClassComputeExpandFieldCallback`.
wrap_WidgetClassComputeExpandFieldCallback :: 
    Maybe (Ptr (FunPtr C_WidgetClassComputeExpandFieldCallback)) ->
    WidgetClassComputeExpandFieldCallback ->
    C_WidgetClassComputeExpandFieldCallback
wrap_WidgetClassComputeExpandFieldCallback gi'funptrptr gi'cb widget hexpandP vexpandP = do
    widget' <- (newObject Gtk.Widget.Widget) widget
    let hexpandP' = (/= 0) hexpandP
    let vexpandP' = (/= 0) vexpandP
    gi'cb  widget' hexpandP' vexpandP'
    maybeReleaseFunPtr gi'funptrptr


-- callback WidgetClassCompositedChangedFieldCallback
{- Callable
  { returnType = Nothing
  , returnMayBeNull = False
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , args =
      [ Arg
          { argCName = "widget"
          , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_WidgetClassCompositedChangedFieldCallback =
    Ptr Gtk.Widget.Widget ->
    IO ()

-- Args: [ Arg
--           { argCName = "widget"
--           , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Nothing
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_WidgetClassCompositedChangedFieldCallback :: FunPtr C_WidgetClassCompositedChangedFieldCallback -> C_WidgetClassCompositedChangedFieldCallback

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_WidgetClassCompositedChangedFieldCallback ::
    (B.CallStack.HasCallStack, MonadIO m, Gtk.Widget.IsWidget a) =>
    FunPtr C_WidgetClassCompositedChangedFieldCallback
    -> a
    -> m ()
dynamic_WidgetClassCompositedChangedFieldCallback __funPtr widget = liftIO $ do
    widget' <- unsafeManagedPtrCastPtr widget
    (__dynamic_C_WidgetClassCompositedChangedFieldCallback __funPtr) widget'
    touchManagedPtr widget
    return ()

-- | Generate a function pointer callable from C code, from a `C_WidgetClassCompositedChangedFieldCallback`.
foreign import ccall "wrapper"
    mk_WidgetClassCompositedChangedFieldCallback :: C_WidgetClassCompositedChangedFieldCallback -> IO (FunPtr C_WidgetClassCompositedChangedFieldCallback)

-- | /No description available in the introspection data./
type WidgetClassCompositedChangedFieldCallback =
    Gtk.Widget.Widget
    -> IO ()

-- | A convenience synonym for @`Nothing` :: `Maybe` `WidgetClassCompositedChangedFieldCallback`@.
noWidgetClassCompositedChangedFieldCallback :: Maybe WidgetClassCompositedChangedFieldCallback
noWidgetClassCompositedChangedFieldCallback = Nothing

-- | Wrap the callback into a `GClosure`.
genClosure_WidgetClassCompositedChangedFieldCallback :: MonadIO m => WidgetClassCompositedChangedFieldCallback -> m (GClosure C_WidgetClassCompositedChangedFieldCallback)
genClosure_WidgetClassCompositedChangedFieldCallback cb = liftIO $ do
    let cb' = wrap_WidgetClassCompositedChangedFieldCallback Nothing cb
    mk_WidgetClassCompositedChangedFieldCallback cb' >>= B.GClosure.newGClosure


-- | Wrap a `WidgetClassCompositedChangedFieldCallback` into a `C_WidgetClassCompositedChangedFieldCallback`.
wrap_WidgetClassCompositedChangedFieldCallback :: 
    Maybe (Ptr (FunPtr C_WidgetClassCompositedChangedFieldCallback)) ->
    WidgetClassCompositedChangedFieldCallback ->
    C_WidgetClassCompositedChangedFieldCallback
wrap_WidgetClassCompositedChangedFieldCallback gi'funptrptr gi'cb widget = do
    widget' <- (newObject Gtk.Widget.Widget) widget
    gi'cb  widget'
    maybeReleaseFunPtr gi'funptrptr


-- callback WidgetClassChildNotifyFieldCallback
{- Callable
  { returnType = Nothing
  , returnMayBeNull = False
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , args =
      [ Arg
          { argCName = "widget"
          , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText = Just "a #GtkWidget" , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "child_property"
          , argType = TParamSpec
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText =
                    Just
                      "the name of a child property installed on the\n                 class of @widget\8217s parent"
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_WidgetClassChildNotifyFieldCallback =
    Ptr Gtk.Widget.Widget ->
    Ptr GParamSpec ->
    IO ()

-- Args: [ Arg
--           { argCName = "widget"
--           , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "a #GtkWidget" , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "child_property"
--           , argType = TParamSpec
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText =
--                     Just
--                       "the name of a child property installed on the\n                 class of @widget\8217s parent"
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Nothing
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_WidgetClassChildNotifyFieldCallback :: FunPtr C_WidgetClassChildNotifyFieldCallback -> C_WidgetClassChildNotifyFieldCallback

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_WidgetClassChildNotifyFieldCallback ::
    (B.CallStack.HasCallStack, MonadIO m, Gtk.Widget.IsWidget a) =>
    FunPtr C_WidgetClassChildNotifyFieldCallback
    -> a
    -- ^ /@widget@/: a t'GI.Gtk.Objects.Widget.Widget'
    -> GParamSpec
    -- ^ /@childProperty@/: the name of a child property installed on the
    --                  class of /@widget@/’s parent
    -> m ()
dynamic_WidgetClassChildNotifyFieldCallback __funPtr widget childProperty = liftIO $ do
    widget' <- unsafeManagedPtrCastPtr widget
    childProperty' <- unsafeManagedPtrGetPtr childProperty
    (__dynamic_C_WidgetClassChildNotifyFieldCallback __funPtr) widget' childProperty'
    touchManagedPtr widget
    touchManagedPtr childProperty
    return ()

-- | Generate a function pointer callable from C code, from a `C_WidgetClassChildNotifyFieldCallback`.
foreign import ccall "wrapper"
    mk_WidgetClassChildNotifyFieldCallback :: C_WidgetClassChildNotifyFieldCallback -> IO (FunPtr C_WidgetClassChildNotifyFieldCallback)

-- | /No description available in the introspection data./
type WidgetClassChildNotifyFieldCallback =
    Gtk.Widget.Widget
    -- ^ /@widget@/: a t'GI.Gtk.Objects.Widget.Widget'
    -> GParamSpec
    -- ^ /@childProperty@/: the name of a child property installed on the
    --                  class of /@widget@/’s parent
    -> IO ()

-- | A convenience synonym for @`Nothing` :: `Maybe` `WidgetClassChildNotifyFieldCallback`@.
noWidgetClassChildNotifyFieldCallback :: Maybe WidgetClassChildNotifyFieldCallback
noWidgetClassChildNotifyFieldCallback = Nothing

-- | Wrap the callback into a `GClosure`.
genClosure_WidgetClassChildNotifyFieldCallback :: MonadIO m => WidgetClassChildNotifyFieldCallback -> m (GClosure C_WidgetClassChildNotifyFieldCallback)
genClosure_WidgetClassChildNotifyFieldCallback cb = liftIO $ do
    let cb' = wrap_WidgetClassChildNotifyFieldCallback Nothing cb
    mk_WidgetClassChildNotifyFieldCallback cb' >>= B.GClosure.newGClosure


-- | Wrap a `WidgetClassChildNotifyFieldCallback` into a `C_WidgetClassChildNotifyFieldCallback`.
wrap_WidgetClassChildNotifyFieldCallback :: 
    Maybe (Ptr (FunPtr C_WidgetClassChildNotifyFieldCallback)) ->
    WidgetClassChildNotifyFieldCallback ->
    C_WidgetClassChildNotifyFieldCallback
wrap_WidgetClassChildNotifyFieldCallback gi'funptrptr gi'cb widget childProperty = do
    widget' <- (newObject Gtk.Widget.Widget) widget
    childProperty' <- B.GParamSpec.newGParamSpecFromPtr childProperty
    gi'cb  widget' childProperty'
    maybeReleaseFunPtr gi'funptrptr


-- callback WidgetClassCanActivateAccelFieldCallback
{- Callable
  { returnType = Just (TBasicType TBoolean)
  , returnMayBeNull = False
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation
        { rawDocText = Just "%TRUE if the accelerator can be activated."
        , sinceVersion = Nothing
        }
  , args =
      [ Arg
          { argCName = "widget"
          , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText = Just "a #GtkWidget" , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "signal_id"
          , argType = TBasicType TUInt
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText = Just "the ID of a signal installed on @widget"
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_WidgetClassCanActivateAccelFieldCallback =
    Ptr Gtk.Widget.Widget ->
    Word32 ->
    IO CInt

-- Args: [ Arg
--           { argCName = "widget"
--           , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "a #GtkWidget" , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "signal_id"
--           , argType = TBasicType TUInt
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "the ID of a signal installed on @widget"
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Just (TBasicType TBoolean)
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_WidgetClassCanActivateAccelFieldCallback :: FunPtr C_WidgetClassCanActivateAccelFieldCallback -> C_WidgetClassCanActivateAccelFieldCallback

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_WidgetClassCanActivateAccelFieldCallback ::
    (B.CallStack.HasCallStack, MonadIO m, Gtk.Widget.IsWidget a) =>
    FunPtr C_WidgetClassCanActivateAccelFieldCallback
    -> a
    -- ^ /@widget@/: a t'GI.Gtk.Objects.Widget.Widget'
    -> Word32
    -- ^ /@signalId@/: the ID of a signal installed on /@widget@/
    -> m Bool
    -- ^ __Returns:__ 'P.True' if the accelerator can be activated.
dynamic_WidgetClassCanActivateAccelFieldCallback __funPtr widget signalId = liftIO $ do
    widget' <- unsafeManagedPtrCastPtr widget
    result <- (__dynamic_C_WidgetClassCanActivateAccelFieldCallback __funPtr) widget' signalId
    let result' = (/= 0) result
    touchManagedPtr widget
    return result'

-- | Generate a function pointer callable from C code, from a `C_WidgetClassCanActivateAccelFieldCallback`.
foreign import ccall "wrapper"
    mk_WidgetClassCanActivateAccelFieldCallback :: C_WidgetClassCanActivateAccelFieldCallback -> IO (FunPtr C_WidgetClassCanActivateAccelFieldCallback)

-- | /No description available in the introspection data./
type WidgetClassCanActivateAccelFieldCallback =
    Gtk.Widget.Widget
    -- ^ /@widget@/: a t'GI.Gtk.Objects.Widget.Widget'
    -> Word32
    -- ^ /@signalId@/: the ID of a signal installed on /@widget@/
    -> IO Bool
    -- ^ __Returns:__ 'P.True' if the accelerator can be activated.

-- | A convenience synonym for @`Nothing` :: `Maybe` `WidgetClassCanActivateAccelFieldCallback`@.
noWidgetClassCanActivateAccelFieldCallback :: Maybe WidgetClassCanActivateAccelFieldCallback
noWidgetClassCanActivateAccelFieldCallback = Nothing

-- | Wrap the callback into a `GClosure`.
genClosure_WidgetClassCanActivateAccelFieldCallback :: MonadIO m => WidgetClassCanActivateAccelFieldCallback -> m (GClosure C_WidgetClassCanActivateAccelFieldCallback)
genClosure_WidgetClassCanActivateAccelFieldCallback cb = liftIO $ do
    let cb' = wrap_WidgetClassCanActivateAccelFieldCallback Nothing cb
    mk_WidgetClassCanActivateAccelFieldCallback cb' >>= B.GClosure.newGClosure


-- | Wrap a `WidgetClassCanActivateAccelFieldCallback` into a `C_WidgetClassCanActivateAccelFieldCallback`.
wrap_WidgetClassCanActivateAccelFieldCallback :: 
    Maybe (Ptr (FunPtr C_WidgetClassCanActivateAccelFieldCallback)) ->
    WidgetClassCanActivateAccelFieldCallback ->
    C_WidgetClassCanActivateAccelFieldCallback
wrap_WidgetClassCanActivateAccelFieldCallback gi'funptrptr gi'cb widget signalId = do
    widget' <- (newObject Gtk.Widget.Widget) widget
    result <- gi'cb  widget' signalId
    maybeReleaseFunPtr gi'funptrptr
    let result' = (fromIntegral . fromEnum) result
    return result'


-- callback WidgetClassButtonReleaseEventFieldCallback
{- Callable
  { returnType = Just (TBasicType TBoolean)
  , returnMayBeNull = False
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , args =
      [ Arg
          { argCName = "widget"
          , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "event"
          , argType =
              TInterface Name { namespace = "Gdk" , name = "EventButton" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_WidgetClassButtonReleaseEventFieldCallback =
    Ptr Gtk.Widget.Widget ->
    Ptr Gdk.EventButton.EventButton ->
    IO CInt

-- Args: [ Arg
--           { argCName = "widget"
--           , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "event"
--           , argType =
--               TInterface Name { namespace = "Gdk" , name = "EventButton" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Just (TBasicType TBoolean)
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_WidgetClassButtonReleaseEventFieldCallback :: FunPtr C_WidgetClassButtonReleaseEventFieldCallback -> C_WidgetClassButtonReleaseEventFieldCallback

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_WidgetClassButtonReleaseEventFieldCallback ::
    (B.CallStack.HasCallStack, MonadIO m, Gtk.Widget.IsWidget a) =>
    FunPtr C_WidgetClassButtonReleaseEventFieldCallback
    -> a
    -> Gdk.EventButton.EventButton
    -> m Bool
dynamic_WidgetClassButtonReleaseEventFieldCallback __funPtr widget event = liftIO $ do
    widget' <- unsafeManagedPtrCastPtr widget
    event' <- unsafeManagedPtrGetPtr event
    result <- (__dynamic_C_WidgetClassButtonReleaseEventFieldCallback __funPtr) widget' event'
    let result' = (/= 0) result
    touchManagedPtr widget
    touchManagedPtr event
    return result'

-- | Generate a function pointer callable from C code, from a `C_WidgetClassButtonReleaseEventFieldCallback`.
foreign import ccall "wrapper"
    mk_WidgetClassButtonReleaseEventFieldCallback :: C_WidgetClassButtonReleaseEventFieldCallback -> IO (FunPtr C_WidgetClassButtonReleaseEventFieldCallback)

-- | /No description available in the introspection data./
type WidgetClassButtonReleaseEventFieldCallback =
    Gtk.Widget.Widget
    -> Gdk.EventButton.EventButton
    -> IO Bool

-- | A convenience synonym for @`Nothing` :: `Maybe` `WidgetClassButtonReleaseEventFieldCallback`@.
noWidgetClassButtonReleaseEventFieldCallback :: Maybe WidgetClassButtonReleaseEventFieldCallback
noWidgetClassButtonReleaseEventFieldCallback = Nothing

-- | Wrap the callback into a `GClosure`.
genClosure_WidgetClassButtonReleaseEventFieldCallback :: MonadIO m => WidgetClassButtonReleaseEventFieldCallback -> m (GClosure C_WidgetClassButtonReleaseEventFieldCallback)
genClosure_WidgetClassButtonReleaseEventFieldCallback cb = liftIO $ do
    let cb' = wrap_WidgetClassButtonReleaseEventFieldCallback Nothing cb
    mk_WidgetClassButtonReleaseEventFieldCallback cb' >>= B.GClosure.newGClosure


-- | Wrap a `WidgetClassButtonReleaseEventFieldCallback` into a `C_WidgetClassButtonReleaseEventFieldCallback`.
wrap_WidgetClassButtonReleaseEventFieldCallback :: 
    Maybe (Ptr (FunPtr C_WidgetClassButtonReleaseEventFieldCallback)) ->
    WidgetClassButtonReleaseEventFieldCallback ->
    C_WidgetClassButtonReleaseEventFieldCallback
wrap_WidgetClassButtonReleaseEventFieldCallback gi'funptrptr gi'cb widget event = do
    widget' <- (newObject Gtk.Widget.Widget) widget
    event' <- (newPtr Gdk.EventButton.EventButton) event
    result <- gi'cb  widget' event'
    maybeReleaseFunPtr gi'funptrptr
    let result' = (fromIntegral . fromEnum) result
    return result'


-- callback WidgetClassButtonPressEventFieldCallback
{- Callable
  { returnType = Just (TBasicType TBoolean)
  , returnMayBeNull = False
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , args =
      [ Arg
          { argCName = "widget"
          , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "event"
          , argType =
              TInterface Name { namespace = "Gdk" , name = "EventButton" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_WidgetClassButtonPressEventFieldCallback =
    Ptr Gtk.Widget.Widget ->
    Ptr Gdk.EventButton.EventButton ->
    IO CInt

-- Args: [ Arg
--           { argCName = "widget"
--           , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "event"
--           , argType =
--               TInterface Name { namespace = "Gdk" , name = "EventButton" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Just (TBasicType TBoolean)
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_WidgetClassButtonPressEventFieldCallback :: FunPtr C_WidgetClassButtonPressEventFieldCallback -> C_WidgetClassButtonPressEventFieldCallback

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_WidgetClassButtonPressEventFieldCallback ::
    (B.CallStack.HasCallStack, MonadIO m, Gtk.Widget.IsWidget a) =>
    FunPtr C_WidgetClassButtonPressEventFieldCallback
    -> a
    -> Gdk.EventButton.EventButton
    -> m Bool
dynamic_WidgetClassButtonPressEventFieldCallback __funPtr widget event = liftIO $ do
    widget' <- unsafeManagedPtrCastPtr widget
    event' <- unsafeManagedPtrGetPtr event
    result <- (__dynamic_C_WidgetClassButtonPressEventFieldCallback __funPtr) widget' event'
    let result' = (/= 0) result
    touchManagedPtr widget
    touchManagedPtr event
    return result'

-- | Generate a function pointer callable from C code, from a `C_WidgetClassButtonPressEventFieldCallback`.
foreign import ccall "wrapper"
    mk_WidgetClassButtonPressEventFieldCallback :: C_WidgetClassButtonPressEventFieldCallback -> IO (FunPtr C_WidgetClassButtonPressEventFieldCallback)

-- | /No description available in the introspection data./
type WidgetClassButtonPressEventFieldCallback =
    Gtk.Widget.Widget
    -> Gdk.EventButton.EventButton
    -> IO Bool

-- | A convenience synonym for @`Nothing` :: `Maybe` `WidgetClassButtonPressEventFieldCallback`@.
noWidgetClassButtonPressEventFieldCallback :: Maybe WidgetClassButtonPressEventFieldCallback
noWidgetClassButtonPressEventFieldCallback = Nothing

-- | Wrap the callback into a `GClosure`.
genClosure_WidgetClassButtonPressEventFieldCallback :: MonadIO m => WidgetClassButtonPressEventFieldCallback -> m (GClosure C_WidgetClassButtonPressEventFieldCallback)
genClosure_WidgetClassButtonPressEventFieldCallback cb = liftIO $ do
    let cb' = wrap_WidgetClassButtonPressEventFieldCallback Nothing cb
    mk_WidgetClassButtonPressEventFieldCallback cb' >>= B.GClosure.newGClosure


-- | Wrap a `WidgetClassButtonPressEventFieldCallback` into a `C_WidgetClassButtonPressEventFieldCallback`.
wrap_WidgetClassButtonPressEventFieldCallback :: 
    Maybe (Ptr (FunPtr C_WidgetClassButtonPressEventFieldCallback)) ->
    WidgetClassButtonPressEventFieldCallback ->
    C_WidgetClassButtonPressEventFieldCallback
wrap_WidgetClassButtonPressEventFieldCallback gi'funptrptr gi'cb widget event = do
    widget' <- (newObject Gtk.Widget.Widget) widget
    event' <- (newPtr Gdk.EventButton.EventButton) event
    result <- gi'cb  widget' event'
    maybeReleaseFunPtr gi'funptrptr
    let result' = (fromIntegral . fromEnum) result
    return result'


-- callback WidgetClassAdjustSizeRequestFieldCallback
{- Callable
  { returnType = Nothing
  , returnMayBeNull = False
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , args =
      [ Arg
          { argCName = "widget"
          , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "orientation"
          , argType =
              TInterface Name { namespace = "Gtk" , name = "Orientation" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "minimum_size"
          , argType = TBasicType TInt
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "natural_size"
          , argType = TBasicType TInt
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_WidgetClassAdjustSizeRequestFieldCallback =
    Ptr Gtk.Widget.Widget ->
    CUInt ->
    Int32 ->
    Int32 ->
    IO ()

-- Args: [ Arg
--           { argCName = "widget"
--           , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "orientation"
--           , argType =
--               TInterface Name { namespace = "Gtk" , name = "Orientation" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "minimum_size"
--           , argType = TBasicType TInt
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "natural_size"
--           , argType = TBasicType TInt
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Nothing
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_WidgetClassAdjustSizeRequestFieldCallback :: FunPtr C_WidgetClassAdjustSizeRequestFieldCallback -> C_WidgetClassAdjustSizeRequestFieldCallback

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_WidgetClassAdjustSizeRequestFieldCallback ::
    (B.CallStack.HasCallStack, MonadIO m, Gtk.Widget.IsWidget a) =>
    FunPtr C_WidgetClassAdjustSizeRequestFieldCallback
    -> a
    -> Gtk.Enums.Orientation
    -> Int32
    -> Int32
    -> m ()
dynamic_WidgetClassAdjustSizeRequestFieldCallback __funPtr widget orientation minimumSize naturalSize = liftIO $ do
    widget' <- unsafeManagedPtrCastPtr widget
    let orientation' = (fromIntegral . fromEnum) orientation
    (__dynamic_C_WidgetClassAdjustSizeRequestFieldCallback __funPtr) widget' orientation' minimumSize naturalSize
    touchManagedPtr widget
    return ()

-- | Generate a function pointer callable from C code, from a `C_WidgetClassAdjustSizeRequestFieldCallback`.
foreign import ccall "wrapper"
    mk_WidgetClassAdjustSizeRequestFieldCallback :: C_WidgetClassAdjustSizeRequestFieldCallback -> IO (FunPtr C_WidgetClassAdjustSizeRequestFieldCallback)

-- | /No description available in the introspection data./
type WidgetClassAdjustSizeRequestFieldCallback =
    Gtk.Widget.Widget
    -> Gtk.Enums.Orientation
    -> Int32
    -> Int32
    -> IO ()

-- | A convenience synonym for @`Nothing` :: `Maybe` `WidgetClassAdjustSizeRequestFieldCallback`@.
noWidgetClassAdjustSizeRequestFieldCallback :: Maybe WidgetClassAdjustSizeRequestFieldCallback
noWidgetClassAdjustSizeRequestFieldCallback = Nothing

-- | Wrap the callback into a `GClosure`.
genClosure_WidgetClassAdjustSizeRequestFieldCallback :: MonadIO m => WidgetClassAdjustSizeRequestFieldCallback -> m (GClosure C_WidgetClassAdjustSizeRequestFieldCallback)
genClosure_WidgetClassAdjustSizeRequestFieldCallback cb = liftIO $ do
    let cb' = wrap_WidgetClassAdjustSizeRequestFieldCallback Nothing cb
    mk_WidgetClassAdjustSizeRequestFieldCallback cb' >>= B.GClosure.newGClosure


-- | Wrap a `WidgetClassAdjustSizeRequestFieldCallback` into a `C_WidgetClassAdjustSizeRequestFieldCallback`.
wrap_WidgetClassAdjustSizeRequestFieldCallback :: 
    Maybe (Ptr (FunPtr C_WidgetClassAdjustSizeRequestFieldCallback)) ->
    WidgetClassAdjustSizeRequestFieldCallback ->
    C_WidgetClassAdjustSizeRequestFieldCallback
wrap_WidgetClassAdjustSizeRequestFieldCallback gi'funptrptr gi'cb widget orientation minimumSize naturalSize = do
    widget' <- (newObject Gtk.Widget.Widget) widget
    let orientation' = (toEnum . fromIntegral) orientation
    gi'cb  widget' orientation' minimumSize naturalSize
    maybeReleaseFunPtr gi'funptrptr


-- callback WidgetClassAdjustSizeAllocationFieldCallback
{- Callable
  { returnType = Nothing
  , returnMayBeNull = False
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , args =
      [ Arg
          { argCName = "widget"
          , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "orientation"
          , argType =
              TInterface Name { namespace = "Gtk" , name = "Orientation" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "minimum_size"
          , argType = TBasicType TInt
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "natural_size"
          , argType = TBasicType TInt
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "allocated_pos"
          , argType = TBasicType TInt
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "allocated_size"
          , argType = TBasicType TInt
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_WidgetClassAdjustSizeAllocationFieldCallback =
    Ptr Gtk.Widget.Widget ->
    CUInt ->
    Int32 ->
    Int32 ->
    Int32 ->
    Int32 ->
    IO ()

-- Args: [ Arg
--           { argCName = "widget"
--           , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "orientation"
--           , argType =
--               TInterface Name { namespace = "Gtk" , name = "Orientation" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "minimum_size"
--           , argType = TBasicType TInt
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "natural_size"
--           , argType = TBasicType TInt
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "allocated_pos"
--           , argType = TBasicType TInt
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "allocated_size"
--           , argType = TBasicType TInt
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Nothing
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_WidgetClassAdjustSizeAllocationFieldCallback :: FunPtr C_WidgetClassAdjustSizeAllocationFieldCallback -> C_WidgetClassAdjustSizeAllocationFieldCallback

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_WidgetClassAdjustSizeAllocationFieldCallback ::
    (B.CallStack.HasCallStack, MonadIO m, Gtk.Widget.IsWidget a) =>
    FunPtr C_WidgetClassAdjustSizeAllocationFieldCallback
    -> a
    -> Gtk.Enums.Orientation
    -> Int32
    -> Int32
    -> Int32
    -> Int32
    -> m ()
dynamic_WidgetClassAdjustSizeAllocationFieldCallback __funPtr widget orientation minimumSize naturalSize allocatedPos allocatedSize = liftIO $ do
    widget' <- unsafeManagedPtrCastPtr widget
    let orientation' = (fromIntegral . fromEnum) orientation
    (__dynamic_C_WidgetClassAdjustSizeAllocationFieldCallback __funPtr) widget' orientation' minimumSize naturalSize allocatedPos allocatedSize
    touchManagedPtr widget
    return ()

-- | Generate a function pointer callable from C code, from a `C_WidgetClassAdjustSizeAllocationFieldCallback`.
foreign import ccall "wrapper"
    mk_WidgetClassAdjustSizeAllocationFieldCallback :: C_WidgetClassAdjustSizeAllocationFieldCallback -> IO (FunPtr C_WidgetClassAdjustSizeAllocationFieldCallback)

-- | /No description available in the introspection data./
type WidgetClassAdjustSizeAllocationFieldCallback =
    Gtk.Widget.Widget
    -> Gtk.Enums.Orientation
    -> Int32
    -> Int32
    -> Int32
    -> Int32
    -> IO ()

-- | A convenience synonym for @`Nothing` :: `Maybe` `WidgetClassAdjustSizeAllocationFieldCallback`@.
noWidgetClassAdjustSizeAllocationFieldCallback :: Maybe WidgetClassAdjustSizeAllocationFieldCallback
noWidgetClassAdjustSizeAllocationFieldCallback = Nothing

-- | Wrap the callback into a `GClosure`.
genClosure_WidgetClassAdjustSizeAllocationFieldCallback :: MonadIO m => WidgetClassAdjustSizeAllocationFieldCallback -> m (GClosure C_WidgetClassAdjustSizeAllocationFieldCallback)
genClosure_WidgetClassAdjustSizeAllocationFieldCallback cb = liftIO $ do
    let cb' = wrap_WidgetClassAdjustSizeAllocationFieldCallback Nothing cb
    mk_WidgetClassAdjustSizeAllocationFieldCallback cb' >>= B.GClosure.newGClosure


-- | Wrap a `WidgetClassAdjustSizeAllocationFieldCallback` into a `C_WidgetClassAdjustSizeAllocationFieldCallback`.
wrap_WidgetClassAdjustSizeAllocationFieldCallback :: 
    Maybe (Ptr (FunPtr C_WidgetClassAdjustSizeAllocationFieldCallback)) ->
    WidgetClassAdjustSizeAllocationFieldCallback ->
    C_WidgetClassAdjustSizeAllocationFieldCallback
wrap_WidgetClassAdjustSizeAllocationFieldCallback gi'funptrptr gi'cb widget orientation minimumSize naturalSize allocatedPos allocatedSize = do
    widget' <- (newObject Gtk.Widget.Widget) widget
    let orientation' = (toEnum . fromIntegral) orientation
    gi'cb  widget' orientation' minimumSize naturalSize allocatedPos allocatedSize
    maybeReleaseFunPtr gi'funptrptr


-- callback WidgetClassAdjustBaselineRequestFieldCallback
{- Callable
  { returnType = Nothing
  , returnMayBeNull = False
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , args =
      [ Arg
          { argCName = "widget"
          , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "minimum_baseline"
          , argType = TBasicType TInt
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "natural_baseline"
          , argType = TBasicType TInt
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_WidgetClassAdjustBaselineRequestFieldCallback =
    Ptr Gtk.Widget.Widget ->
    Int32 ->
    Int32 ->
    IO ()

-- Args: [ Arg
--           { argCName = "widget"
--           , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "minimum_baseline"
--           , argType = TBasicType TInt
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "natural_baseline"
--           , argType = TBasicType TInt
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Nothing
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_WidgetClassAdjustBaselineRequestFieldCallback :: FunPtr C_WidgetClassAdjustBaselineRequestFieldCallback -> C_WidgetClassAdjustBaselineRequestFieldCallback

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_WidgetClassAdjustBaselineRequestFieldCallback ::
    (B.CallStack.HasCallStack, MonadIO m, Gtk.Widget.IsWidget a) =>
    FunPtr C_WidgetClassAdjustBaselineRequestFieldCallback
    -> a
    -> Int32
    -> Int32
    -> m ()
dynamic_WidgetClassAdjustBaselineRequestFieldCallback __funPtr widget minimumBaseline naturalBaseline = liftIO $ do
    widget' <- unsafeManagedPtrCastPtr widget
    (__dynamic_C_WidgetClassAdjustBaselineRequestFieldCallback __funPtr) widget' minimumBaseline naturalBaseline
    touchManagedPtr widget
    return ()

-- | Generate a function pointer callable from C code, from a `C_WidgetClassAdjustBaselineRequestFieldCallback`.
foreign import ccall "wrapper"
    mk_WidgetClassAdjustBaselineRequestFieldCallback :: C_WidgetClassAdjustBaselineRequestFieldCallback -> IO (FunPtr C_WidgetClassAdjustBaselineRequestFieldCallback)

-- | /No description available in the introspection data./
type WidgetClassAdjustBaselineRequestFieldCallback =
    Gtk.Widget.Widget
    -> Int32
    -> Int32
    -> IO ()

-- | A convenience synonym for @`Nothing` :: `Maybe` `WidgetClassAdjustBaselineRequestFieldCallback`@.
noWidgetClassAdjustBaselineRequestFieldCallback :: Maybe WidgetClassAdjustBaselineRequestFieldCallback
noWidgetClassAdjustBaselineRequestFieldCallback = Nothing

-- | Wrap the callback into a `GClosure`.
genClosure_WidgetClassAdjustBaselineRequestFieldCallback :: MonadIO m => WidgetClassAdjustBaselineRequestFieldCallback -> m (GClosure C_WidgetClassAdjustBaselineRequestFieldCallback)
genClosure_WidgetClassAdjustBaselineRequestFieldCallback cb = liftIO $ do
    let cb' = wrap_WidgetClassAdjustBaselineRequestFieldCallback Nothing cb
    mk_WidgetClassAdjustBaselineRequestFieldCallback cb' >>= B.GClosure.newGClosure


-- | Wrap a `WidgetClassAdjustBaselineRequestFieldCallback` into a `C_WidgetClassAdjustBaselineRequestFieldCallback`.
wrap_WidgetClassAdjustBaselineRequestFieldCallback :: 
    Maybe (Ptr (FunPtr C_WidgetClassAdjustBaselineRequestFieldCallback)) ->
    WidgetClassAdjustBaselineRequestFieldCallback ->
    C_WidgetClassAdjustBaselineRequestFieldCallback
wrap_WidgetClassAdjustBaselineRequestFieldCallback gi'funptrptr gi'cb widget minimumBaseline naturalBaseline = do
    widget' <- (newObject Gtk.Widget.Widget) widget
    gi'cb  widget' minimumBaseline naturalBaseline
    maybeReleaseFunPtr gi'funptrptr


-- callback WidgetClassAdjustBaselineAllocationFieldCallback
{- Callable
  { returnType = Nothing
  , returnMayBeNull = False
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , args =
      [ Arg
          { argCName = "widget"
          , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "baseline"
          , argType = TBasicType TInt
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_WidgetClassAdjustBaselineAllocationFieldCallback =
    Ptr Gtk.Widget.Widget ->
    Int32 ->
    IO ()

-- Args: [ Arg
--           { argCName = "widget"
--           , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "baseline"
--           , argType = TBasicType TInt
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Nothing
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_WidgetClassAdjustBaselineAllocationFieldCallback :: FunPtr C_WidgetClassAdjustBaselineAllocationFieldCallback -> C_WidgetClassAdjustBaselineAllocationFieldCallback

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_WidgetClassAdjustBaselineAllocationFieldCallback ::
    (B.CallStack.HasCallStack, MonadIO m, Gtk.Widget.IsWidget a) =>
    FunPtr C_WidgetClassAdjustBaselineAllocationFieldCallback
    -> a
    -> Int32
    -> m ()
dynamic_WidgetClassAdjustBaselineAllocationFieldCallback __funPtr widget baseline = liftIO $ do
    widget' <- unsafeManagedPtrCastPtr widget
    (__dynamic_C_WidgetClassAdjustBaselineAllocationFieldCallback __funPtr) widget' baseline
    touchManagedPtr widget
    return ()

-- | Generate a function pointer callable from C code, from a `C_WidgetClassAdjustBaselineAllocationFieldCallback`.
foreign import ccall "wrapper"
    mk_WidgetClassAdjustBaselineAllocationFieldCallback :: C_WidgetClassAdjustBaselineAllocationFieldCallback -> IO (FunPtr C_WidgetClassAdjustBaselineAllocationFieldCallback)

-- | /No description available in the introspection data./
type WidgetClassAdjustBaselineAllocationFieldCallback =
    Gtk.Widget.Widget
    -> Int32
    -> IO ()

-- | A convenience synonym for @`Nothing` :: `Maybe` `WidgetClassAdjustBaselineAllocationFieldCallback`@.
noWidgetClassAdjustBaselineAllocationFieldCallback :: Maybe WidgetClassAdjustBaselineAllocationFieldCallback
noWidgetClassAdjustBaselineAllocationFieldCallback = Nothing

-- | Wrap the callback into a `GClosure`.
genClosure_WidgetClassAdjustBaselineAllocationFieldCallback :: MonadIO m => WidgetClassAdjustBaselineAllocationFieldCallback -> m (GClosure C_WidgetClassAdjustBaselineAllocationFieldCallback)
genClosure_WidgetClassAdjustBaselineAllocationFieldCallback cb = liftIO $ do
    let cb' = wrap_WidgetClassAdjustBaselineAllocationFieldCallback Nothing cb
    mk_WidgetClassAdjustBaselineAllocationFieldCallback cb' >>= B.GClosure.newGClosure


-- | Wrap a `WidgetClassAdjustBaselineAllocationFieldCallback` into a `C_WidgetClassAdjustBaselineAllocationFieldCallback`.
wrap_WidgetClassAdjustBaselineAllocationFieldCallback :: 
    Maybe (Ptr (FunPtr C_WidgetClassAdjustBaselineAllocationFieldCallback)) ->
    WidgetClassAdjustBaselineAllocationFieldCallback ->
    C_WidgetClassAdjustBaselineAllocationFieldCallback
wrap_WidgetClassAdjustBaselineAllocationFieldCallback gi'funptrptr gi'cb widget baseline = do
    widget' <- (newObject Gtk.Widget.Widget) widget
    gi'cb  widget' baseline
    maybeReleaseFunPtr gi'funptrptr


-- callback TreeViewSearchPositionFunc
{- Callable
  { returnType = Nothing
  , returnMayBeNull = False
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , args =
      [ Arg
          { argCName = "tree_view"
          , argType =
              TInterface Name { namespace = "Gtk" , name = "TreeView" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "search_dialog"
          , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "user_data"
          , argType = TBasicType TPtr
          , direction = DirectionIn
          , mayBeNull = True
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = 2
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_TreeViewSearchPositionFunc =
    Ptr Gtk.TreeView.TreeView ->
    Ptr Gtk.Widget.Widget ->
    Ptr () ->
    IO ()

-- Args: [ Arg
--           { argCName = "tree_view"
--           , argType =
--               TInterface Name { namespace = "Gtk" , name = "TreeView" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "search_dialog"
--           , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "user_data"
--           , argType = TBasicType TPtr
--           , direction = DirectionIn
--           , mayBeNull = True
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = 2
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Nothing
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_TreeViewSearchPositionFunc :: FunPtr C_TreeViewSearchPositionFunc -> C_TreeViewSearchPositionFunc

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_TreeViewSearchPositionFunc ::
    (B.CallStack.HasCallStack, MonadIO m, Gtk.TreeView.IsTreeView a, Gtk.Widget.IsWidget b) =>
    FunPtr C_TreeViewSearchPositionFunc
    -> a
    -> b
    -> Ptr ()
    -> m ()
dynamic_TreeViewSearchPositionFunc __funPtr treeView searchDialog userData = liftIO $ do
    treeView' <- unsafeManagedPtrCastPtr treeView
    searchDialog' <- unsafeManagedPtrCastPtr searchDialog
    (__dynamic_C_TreeViewSearchPositionFunc __funPtr) treeView' searchDialog' userData
    touchManagedPtr treeView
    touchManagedPtr searchDialog
    return ()

-- | Generate a function pointer callable from C code, from a `C_TreeViewSearchPositionFunc`.
foreign import ccall "wrapper"
    mk_TreeViewSearchPositionFunc :: C_TreeViewSearchPositionFunc -> IO (FunPtr C_TreeViewSearchPositionFunc)

-- | /No description available in the introspection data./
type TreeViewSearchPositionFunc =
    Gtk.TreeView.TreeView
    -> Gtk.Widget.Widget
    -> IO ()

-- | A convenience synonym for @`Nothing` :: `Maybe` `TreeViewSearchPositionFunc`@.
noTreeViewSearchPositionFunc :: Maybe TreeViewSearchPositionFunc
noTreeViewSearchPositionFunc = Nothing

-- | /No description available in the introspection data./
type TreeViewSearchPositionFunc_WithClosures =
    Gtk.TreeView.TreeView
    -> Gtk.Widget.Widget
    -> Ptr ()
    -> IO ()

-- | A convenience synonym for @`Nothing` :: `Maybe` `TreeViewSearchPositionFunc_WithClosures`@.
noTreeViewSearchPositionFunc_WithClosures :: Maybe TreeViewSearchPositionFunc_WithClosures
noTreeViewSearchPositionFunc_WithClosures = Nothing

-- | A simple wrapper that ignores the closure arguments.
drop_closures_TreeViewSearchPositionFunc :: TreeViewSearchPositionFunc -> TreeViewSearchPositionFunc_WithClosures
drop_closures_TreeViewSearchPositionFunc _f treeView searchDialog _ = _f treeView searchDialog

-- | Wrap the callback into a `GClosure`.
genClosure_TreeViewSearchPositionFunc :: MonadIO m => TreeViewSearchPositionFunc -> m (GClosure C_TreeViewSearchPositionFunc)
genClosure_TreeViewSearchPositionFunc cb = liftIO $ do
    let cb' = drop_closures_TreeViewSearchPositionFunc cb
    let cb'' = wrap_TreeViewSearchPositionFunc Nothing cb'
    mk_TreeViewSearchPositionFunc cb'' >>= B.GClosure.newGClosure


-- | Wrap a `TreeViewSearchPositionFunc` into a `C_TreeViewSearchPositionFunc`.
wrap_TreeViewSearchPositionFunc :: 
    Maybe (Ptr (FunPtr C_TreeViewSearchPositionFunc)) ->
    TreeViewSearchPositionFunc_WithClosures ->
    C_TreeViewSearchPositionFunc
wrap_TreeViewSearchPositionFunc gi'funptrptr gi'cb treeView searchDialog userData = do
    treeView' <- (newObject Gtk.TreeView.TreeView) treeView
    searchDialog' <- (newObject Gtk.Widget.Widget) searchDialog
    gi'cb  treeView' searchDialog' userData
    maybeReleaseFunPtr gi'funptrptr


-- callback TreeViewSearchEqualFunc
{- Callable
  { returnType = Just (TBasicType TBoolean)
  , returnMayBeNull = False
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation
        { rawDocText = Just "%FALSE if the row matches, %TRUE otherwise."
        , sinceVersion = Nothing
        }
  , args =
      [ Arg
          { argCName = "model"
          , argType =
              TInterface Name { namespace = "Gtk" , name = "TreeModel" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText = Just "the #GtkTreeModel being searched"
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "column"
          , argType = TBasicType TInt
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText =
                    Just "the search column set by gtk_tree_view_set_search_column()"
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "key"
          , argType = TBasicType TUTF8
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText = Just "the key string to compare with"
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "iter"
          , argType =
              TInterface Name { namespace = "Gtk" , name = "TreeIter" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText =
                    Just
                      "a #GtkTreeIter pointing the row of @model that should be compared\n with @key."
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "search_data"
          , argType = TBasicType TPtr
          , direction = DirectionIn
          , mayBeNull = True
          , argDoc =
              Documentation
                { rawDocText =
                    Just "user data from gtk_tree_view_set_search_equal_func()"
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = 4
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation
        { rawDocText =
            Just
              "A function used for checking whether a row in @model matches\na search key string entered by the user. Note the return value\nis reversed from what you would normally expect, though it\nhas some similarity to strcmp() returning 0 for equal strings."
        , sinceVersion = Nothing
        }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_TreeViewSearchEqualFunc =
    Ptr Gtk.TreeModel.TreeModel ->
    Int32 ->
    CString ->
    Ptr Gtk.TreeIter.TreeIter ->
    Ptr () ->
    IO CInt

-- Args: [ Arg
--           { argCName = "model"
--           , argType =
--               TInterface Name { namespace = "Gtk" , name = "TreeModel" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "the #GtkTreeModel being searched"
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "column"
--           , argType = TBasicType TInt
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText =
--                     Just "the search column set by gtk_tree_view_set_search_column()"
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "key"
--           , argType = TBasicType TUTF8
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "the key string to compare with"
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "iter"
--           , argType =
--               TInterface Name { namespace = "Gtk" , name = "TreeIter" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText =
--                     Just
--                       "a #GtkTreeIter pointing the row of @model that should be compared\n with @key."
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "search_data"
--           , argType = TBasicType TPtr
--           , direction = DirectionIn
--           , mayBeNull = True
--           , argDoc =
--               Documentation
--                 { rawDocText =
--                     Just "user data from gtk_tree_view_set_search_equal_func()"
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = 4
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Just (TBasicType TBoolean)
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_TreeViewSearchEqualFunc :: FunPtr C_TreeViewSearchEqualFunc -> C_TreeViewSearchEqualFunc

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_TreeViewSearchEqualFunc ::
    (B.CallStack.HasCallStack, MonadIO m, Gtk.TreeModel.IsTreeModel a) =>
    FunPtr C_TreeViewSearchEqualFunc
    -> a
    -- ^ /@model@/: the t'GI.Gtk.Interfaces.TreeModel.TreeModel' being searched
    -> Int32
    -- ^ /@column@/: the search column set by 'GI.Gtk.Objects.TreeView.treeViewSetSearchColumn'
    -> T.Text
    -- ^ /@key@/: the key string to compare with
    -> Gtk.TreeIter.TreeIter
    -- ^ /@iter@/: a t'GI.Gtk.Structs.TreeIter.TreeIter' pointing the row of /@model@/ that should be compared
    --  with /@key@/.
    -> Ptr ()
    -- ^ /@searchData@/: user data from 'GI.Gtk.Objects.TreeView.treeViewSetSearchEqualFunc'
    -> m Bool
    -- ^ __Returns:__ 'P.False' if the row matches, 'P.True' otherwise.
dynamic_TreeViewSearchEqualFunc __funPtr model column key iter searchData = liftIO $ do
    model' <- unsafeManagedPtrCastPtr model
    key' <- textToCString key
    iter' <- unsafeManagedPtrGetPtr iter
    result <- (__dynamic_C_TreeViewSearchEqualFunc __funPtr) model' column key' iter' searchData
    let result' = (/= 0) result
    touchManagedPtr model
    touchManagedPtr iter
    freeMem key'
    return result'

-- | Generate a function pointer callable from C code, from a `C_TreeViewSearchEqualFunc`.
foreign import ccall "wrapper"
    mk_TreeViewSearchEqualFunc :: C_TreeViewSearchEqualFunc -> IO (FunPtr C_TreeViewSearchEqualFunc)

-- | A function used for checking whether a row in /@model@/ matches
-- a search key string entered by the user. Note the return value
-- is reversed from what you would normally expect, though it
-- has some similarity to @/strcmp()/@ returning 0 for equal strings.
type TreeViewSearchEqualFunc =
    Gtk.TreeModel.TreeModel
    -- ^ /@model@/: the t'GI.Gtk.Interfaces.TreeModel.TreeModel' being searched
    -> Int32
    -- ^ /@column@/: the search column set by 'GI.Gtk.Objects.TreeView.treeViewSetSearchColumn'
    -> T.Text
    -- ^ /@key@/: the key string to compare with
    -> Gtk.TreeIter.TreeIter
    -- ^ /@iter@/: a t'GI.Gtk.Structs.TreeIter.TreeIter' pointing the row of /@model@/ that should be compared
    --  with /@key@/.
    -> IO Bool
    -- ^ __Returns:__ 'P.False' if the row matches, 'P.True' otherwise.

-- | A convenience synonym for @`Nothing` :: `Maybe` `TreeViewSearchEqualFunc`@.
noTreeViewSearchEqualFunc :: Maybe TreeViewSearchEqualFunc
noTreeViewSearchEqualFunc = Nothing

-- | A function used for checking whether a row in /@model@/ matches
-- a search key string entered by the user. Note the return value
-- is reversed from what you would normally expect, though it
-- has some similarity to @/strcmp()/@ returning 0 for equal strings.
type TreeViewSearchEqualFunc_WithClosures =
    Gtk.TreeModel.TreeModel
    -- ^ /@model@/: the t'GI.Gtk.Interfaces.TreeModel.TreeModel' being searched
    -> Int32
    -- ^ /@column@/: the search column set by 'GI.Gtk.Objects.TreeView.treeViewSetSearchColumn'
    -> T.Text
    -- ^ /@key@/: the key string to compare with
    -> Gtk.TreeIter.TreeIter
    -- ^ /@iter@/: a t'GI.Gtk.Structs.TreeIter.TreeIter' pointing the row of /@model@/ that should be compared
    --  with /@key@/.
    -> Ptr ()
    -- ^ /@searchData@/: user data from 'GI.Gtk.Objects.TreeView.treeViewSetSearchEqualFunc'
    -> IO Bool
    -- ^ __Returns:__ 'P.False' if the row matches, 'P.True' otherwise.

-- | A convenience synonym for @`Nothing` :: `Maybe` `TreeViewSearchEqualFunc_WithClosures`@.
noTreeViewSearchEqualFunc_WithClosures :: Maybe TreeViewSearchEqualFunc_WithClosures
noTreeViewSearchEqualFunc_WithClosures = Nothing

-- | A simple wrapper that ignores the closure arguments.
drop_closures_TreeViewSearchEqualFunc :: TreeViewSearchEqualFunc -> TreeViewSearchEqualFunc_WithClosures
drop_closures_TreeViewSearchEqualFunc _f model column key iter _ = _f model column key iter

-- | Wrap the callback into a `GClosure`.
genClosure_TreeViewSearchEqualFunc :: MonadIO m => TreeViewSearchEqualFunc -> m (GClosure C_TreeViewSearchEqualFunc)
genClosure_TreeViewSearchEqualFunc cb = liftIO $ do
    let cb' = drop_closures_TreeViewSearchEqualFunc cb
    let cb'' = wrap_TreeViewSearchEqualFunc Nothing cb'
    mk_TreeViewSearchEqualFunc cb'' >>= B.GClosure.newGClosure


-- | Wrap a `TreeViewSearchEqualFunc` into a `C_TreeViewSearchEqualFunc`.
wrap_TreeViewSearchEqualFunc :: 
    Maybe (Ptr (FunPtr C_TreeViewSearchEqualFunc)) ->
    TreeViewSearchEqualFunc_WithClosures ->
    C_TreeViewSearchEqualFunc
wrap_TreeViewSearchEqualFunc gi'funptrptr gi'cb model column key iter searchData = do
    model' <- (newObject Gtk.TreeModel.TreeModel) model
    key' <- cstringToText key
    B.ManagedPtr.withTransient  iter $ \iter' -> do
        result <- gi'cb  model' column key' iter' searchData
        maybeReleaseFunPtr gi'funptrptr
        let result' = (fromIntegral . fromEnum) result
        return result'


-- callback TreeViewRowSeparatorFunc
{- Callable
  { returnType = Just (TBasicType TBoolean)
  , returnMayBeNull = False
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation
        { rawDocText = Just "%TRUE if the row is a separator"
        , sinceVersion = Nothing
        }
  , args =
      [ Arg
          { argCName = "model"
          , argType =
              TInterface Name { namespace = "Gtk" , name = "TreeModel" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText = Just "the #GtkTreeModel" , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "iter"
          , argType =
              TInterface Name { namespace = "Gtk" , name = "TreeIter" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText = Just "a #GtkTreeIter pointing at a row in @model"
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "data"
          , argType = TBasicType TPtr
          , direction = DirectionIn
          , mayBeNull = True
          , argDoc =
              Documentation
                { rawDocText = Just "user data" , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = 2
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation
        { rawDocText =
            Just
              "Function type for determining whether the row pointed to by @iter should\nbe rendered as a separator. A common way to implement this is to have a\nboolean column in the model, whose values the #GtkTreeViewRowSeparatorFunc\nreturns."
        , sinceVersion = Nothing
        }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_TreeViewRowSeparatorFunc =
    Ptr Gtk.TreeModel.TreeModel ->
    Ptr Gtk.TreeIter.TreeIter ->
    Ptr () ->
    IO CInt

-- Args: [ Arg
--           { argCName = "model"
--           , argType =
--               TInterface Name { namespace = "Gtk" , name = "TreeModel" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "the #GtkTreeModel" , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "iter"
--           , argType =
--               TInterface Name { namespace = "Gtk" , name = "TreeIter" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "a #GtkTreeIter pointing at a row in @model"
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "data"
--           , argType = TBasicType TPtr
--           , direction = DirectionIn
--           , mayBeNull = True
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "user data" , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = 2
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Just (TBasicType TBoolean)
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_TreeViewRowSeparatorFunc :: FunPtr C_TreeViewRowSeparatorFunc -> C_TreeViewRowSeparatorFunc

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_TreeViewRowSeparatorFunc ::
    (B.CallStack.HasCallStack, MonadIO m, Gtk.TreeModel.IsTreeModel a) =>
    FunPtr C_TreeViewRowSeparatorFunc
    -> a
    -- ^ /@model@/: the t'GI.Gtk.Interfaces.TreeModel.TreeModel'
    -> Gtk.TreeIter.TreeIter
    -- ^ /@iter@/: a t'GI.Gtk.Structs.TreeIter.TreeIter' pointing at a row in /@model@/
    -> Ptr ()
    -- ^ /@data@/: user data
    -> m Bool
    -- ^ __Returns:__ 'P.True' if the row is a separator
dynamic_TreeViewRowSeparatorFunc __funPtr model iter data_ = liftIO $ do
    model' <- unsafeManagedPtrCastPtr model
    iter' <- unsafeManagedPtrGetPtr iter
    result <- (__dynamic_C_TreeViewRowSeparatorFunc __funPtr) model' iter' data_
    let result' = (/= 0) result
    touchManagedPtr model
    touchManagedPtr iter
    return result'

-- | Generate a function pointer callable from C code, from a `C_TreeViewRowSeparatorFunc`.
foreign import ccall "wrapper"
    mk_TreeViewRowSeparatorFunc :: C_TreeViewRowSeparatorFunc -> IO (FunPtr C_TreeViewRowSeparatorFunc)

-- | Function type for determining whether the row pointed to by /@iter@/ should
-- be rendered as a separator. A common way to implement this is to have a
-- boolean column in the model, whose values the t'GI.Gtk.Callbacks.TreeViewRowSeparatorFunc'
-- returns.
type TreeViewRowSeparatorFunc =
    Gtk.TreeModel.TreeModel
    -- ^ /@model@/: the t'GI.Gtk.Interfaces.TreeModel.TreeModel'
    -> Gtk.TreeIter.TreeIter
    -- ^ /@iter@/: a t'GI.Gtk.Structs.TreeIter.TreeIter' pointing at a row in /@model@/
    -> IO Bool
    -- ^ __Returns:__ 'P.True' if the row is a separator

-- | A convenience synonym for @`Nothing` :: `Maybe` `TreeViewRowSeparatorFunc`@.
noTreeViewRowSeparatorFunc :: Maybe TreeViewRowSeparatorFunc
noTreeViewRowSeparatorFunc = Nothing

-- | Function type for determining whether the row pointed to by /@iter@/ should
-- be rendered as a separator. A common way to implement this is to have a
-- boolean column in the model, whose values the t'GI.Gtk.Callbacks.TreeViewRowSeparatorFunc'
-- returns.
type TreeViewRowSeparatorFunc_WithClosures =
    Gtk.TreeModel.TreeModel
    -- ^ /@model@/: the t'GI.Gtk.Interfaces.TreeModel.TreeModel'
    -> Gtk.TreeIter.TreeIter
    -- ^ /@iter@/: a t'GI.Gtk.Structs.TreeIter.TreeIter' pointing at a row in /@model@/
    -> Ptr ()
    -- ^ /@data@/: user data
    -> IO Bool
    -- ^ __Returns:__ 'P.True' if the row is a separator

-- | A convenience synonym for @`Nothing` :: `Maybe` `TreeViewRowSeparatorFunc_WithClosures`@.
noTreeViewRowSeparatorFunc_WithClosures :: Maybe TreeViewRowSeparatorFunc_WithClosures
noTreeViewRowSeparatorFunc_WithClosures = Nothing

-- | A simple wrapper that ignores the closure arguments.
drop_closures_TreeViewRowSeparatorFunc :: TreeViewRowSeparatorFunc -> TreeViewRowSeparatorFunc_WithClosures
drop_closures_TreeViewRowSeparatorFunc _f model iter _ = _f model iter

-- | Wrap the callback into a `GClosure`.
genClosure_TreeViewRowSeparatorFunc :: MonadIO m => TreeViewRowSeparatorFunc -> m (GClosure C_TreeViewRowSeparatorFunc)
genClosure_TreeViewRowSeparatorFunc cb = liftIO $ do
    let cb' = drop_closures_TreeViewRowSeparatorFunc cb
    let cb'' = wrap_TreeViewRowSeparatorFunc Nothing cb'
    mk_TreeViewRowSeparatorFunc cb'' >>= B.GClosure.newGClosure


-- | Wrap a `TreeViewRowSeparatorFunc` into a `C_TreeViewRowSeparatorFunc`.
wrap_TreeViewRowSeparatorFunc :: 
    Maybe (Ptr (FunPtr C_TreeViewRowSeparatorFunc)) ->
    TreeViewRowSeparatorFunc_WithClosures ->
    C_TreeViewRowSeparatorFunc
wrap_TreeViewRowSeparatorFunc gi'funptrptr gi'cb model iter data_ = do
    model' <- (newObject Gtk.TreeModel.TreeModel) model
    B.ManagedPtr.withTransient  iter $ \iter' -> do
        result <- gi'cb  model' iter' data_
        maybeReleaseFunPtr gi'funptrptr
        let result' = (fromIntegral . fromEnum) result
        return result'


-- callback TreeViewMappingFunc
{- Callable
  { returnType = Nothing
  , returnMayBeNull = False
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , args =
      [ Arg
          { argCName = "tree_view"
          , argType =
              TInterface Name { namespace = "Gtk" , name = "TreeView" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText = Just "A #GtkTreeView" , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "path"
          , argType =
              TInterface Name { namespace = "Gtk" , name = "TreePath" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText = Just "The path that\8217s expanded"
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "user_data"
          , argType = TBasicType TPtr
          , direction = DirectionIn
          , mayBeNull = True
          , argDoc =
              Documentation
                { rawDocText = Just "user data" , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = 2
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation
        { rawDocText =
            Just "Function used for gtk_tree_view_map_expanded_rows()."
        , sinceVersion = Nothing
        }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_TreeViewMappingFunc =
    Ptr Gtk.TreeView.TreeView ->
    Ptr Gtk.TreePath.TreePath ->
    Ptr () ->
    IO ()

-- Args: [ Arg
--           { argCName = "tree_view"
--           , argType =
--               TInterface Name { namespace = "Gtk" , name = "TreeView" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "A #GtkTreeView" , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "path"
--           , argType =
--               TInterface Name { namespace = "Gtk" , name = "TreePath" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "The path that\8217s expanded"
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "user_data"
--           , argType = TBasicType TPtr
--           , direction = DirectionIn
--           , mayBeNull = True
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "user data" , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = 2
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Nothing
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_TreeViewMappingFunc :: FunPtr C_TreeViewMappingFunc -> C_TreeViewMappingFunc

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_TreeViewMappingFunc ::
    (B.CallStack.HasCallStack, MonadIO m, Gtk.TreeView.IsTreeView a) =>
    FunPtr C_TreeViewMappingFunc
    -> a
    -- ^ /@treeView@/: A t'GI.Gtk.Objects.TreeView.TreeView'
    -> Gtk.TreePath.TreePath
    -- ^ /@path@/: The path that’s expanded
    -> Ptr ()
    -- ^ /@userData@/: user data
    -> m ()
dynamic_TreeViewMappingFunc __funPtr treeView path userData = liftIO $ do
    treeView' <- unsafeManagedPtrCastPtr treeView
    path' <- unsafeManagedPtrGetPtr path
    (__dynamic_C_TreeViewMappingFunc __funPtr) treeView' path' userData
    touchManagedPtr treeView
    touchManagedPtr path
    return ()

-- | Generate a function pointer callable from C code, from a `C_TreeViewMappingFunc`.
foreign import ccall "wrapper"
    mk_TreeViewMappingFunc :: C_TreeViewMappingFunc -> IO (FunPtr C_TreeViewMappingFunc)

-- | Function used for 'GI.Gtk.Objects.TreeView.treeViewMapExpandedRows'.
type TreeViewMappingFunc =
    Gtk.TreeView.TreeView
    -- ^ /@treeView@/: A t'GI.Gtk.Objects.TreeView.TreeView'
    -> Gtk.TreePath.TreePath
    -- ^ /@path@/: The path that’s expanded
    -> IO ()

-- | A convenience synonym for @`Nothing` :: `Maybe` `TreeViewMappingFunc`@.
noTreeViewMappingFunc :: Maybe TreeViewMappingFunc
noTreeViewMappingFunc = Nothing

-- | Function used for 'GI.Gtk.Objects.TreeView.treeViewMapExpandedRows'.
type TreeViewMappingFunc_WithClosures =
    Gtk.TreeView.TreeView
    -- ^ /@treeView@/: A t'GI.Gtk.Objects.TreeView.TreeView'
    -> Gtk.TreePath.TreePath
    -- ^ /@path@/: The path that’s expanded
    -> Ptr ()
    -- ^ /@userData@/: user data
    -> IO ()

-- | A convenience synonym for @`Nothing` :: `Maybe` `TreeViewMappingFunc_WithClosures`@.
noTreeViewMappingFunc_WithClosures :: Maybe TreeViewMappingFunc_WithClosures
noTreeViewMappingFunc_WithClosures = Nothing

-- | A simple wrapper that ignores the closure arguments.
drop_closures_TreeViewMappingFunc :: TreeViewMappingFunc -> TreeViewMappingFunc_WithClosures
drop_closures_TreeViewMappingFunc _f treeView path _ = _f treeView path

-- | Wrap the callback into a `GClosure`.
genClosure_TreeViewMappingFunc :: MonadIO m => TreeViewMappingFunc -> m (GClosure C_TreeViewMappingFunc)
genClosure_TreeViewMappingFunc cb = liftIO $ do
    let cb' = drop_closures_TreeViewMappingFunc cb
    let cb'' = wrap_TreeViewMappingFunc Nothing cb'
    mk_TreeViewMappingFunc cb'' >>= B.GClosure.newGClosure


-- | Wrap a `TreeViewMappingFunc` into a `C_TreeViewMappingFunc`.
wrap_TreeViewMappingFunc :: 
    Maybe (Ptr (FunPtr C_TreeViewMappingFunc)) ->
    TreeViewMappingFunc_WithClosures ->
    C_TreeViewMappingFunc
wrap_TreeViewMappingFunc gi'funptrptr gi'cb treeView path userData = do
    treeView' <- (newObject Gtk.TreeView.TreeView) treeView
    B.ManagedPtr.withTransient  path $ \path' -> do
        gi'cb  treeView' path' userData
        maybeReleaseFunPtr gi'funptrptr


-- callback TreeViewColumnDropFunc
{- Callable
  { returnType = Just (TBasicType TBoolean)
  , returnMayBeNull = False
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation
        { rawDocText = Just "%TRUE, if @column can be dropped in this spot"
        , sinceVersion = Nothing
        }
  , args =
      [ Arg
          { argCName = "tree_view"
          , argType =
              TInterface Name { namespace = "Gtk" , name = "TreeView" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText = Just "A #GtkTreeView" , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "column"
          , argType =
              TInterface Name { namespace = "Gtk" , name = "TreeViewColumn" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText = Just "The #GtkTreeViewColumn being dragged"
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "prev_column"
          , argType =
              TInterface Name { namespace = "Gtk" , name = "TreeViewColumn" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText = Just "A #GtkTreeViewColumn on one side of @column"
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "next_column"
          , argType =
              TInterface Name { namespace = "Gtk" , name = "TreeViewColumn" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText =
                    Just "A #GtkTreeViewColumn on the other side of @column"
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "data"
          , argType = TBasicType TPtr
          , direction = DirectionIn
          , mayBeNull = True
          , argDoc =
              Documentation
                { rawDocText = Just "user data" , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = 4
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation
        { rawDocText =
            Just
              "Function type for determining whether @column can be dropped in a\nparticular spot (as determined by @prev_column and @next_column).  In\nleft to right locales, @prev_column is on the left of the potential drop\nspot, and @next_column is on the right.  In right to left mode, this is\nreversed.  This function should return %TRUE if the spot is a valid drop\nspot.  Please note that returning %TRUE does not actually indicate that\nthe column drop was made, but is meant only to indicate a possible drop\nspot to the user."
        , sinceVersion = Nothing
        }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_TreeViewColumnDropFunc =
    Ptr Gtk.TreeView.TreeView ->
    Ptr Gtk.TreeViewColumn.TreeViewColumn ->
    Ptr Gtk.TreeViewColumn.TreeViewColumn ->
    Ptr Gtk.TreeViewColumn.TreeViewColumn ->
    Ptr () ->
    IO CInt

-- Args: [ Arg
--           { argCName = "tree_view"
--           , argType =
--               TInterface Name { namespace = "Gtk" , name = "TreeView" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "A #GtkTreeView" , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "column"
--           , argType =
--               TInterface Name { namespace = "Gtk" , name = "TreeViewColumn" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "The #GtkTreeViewColumn being dragged"
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "prev_column"
--           , argType =
--               TInterface Name { namespace = "Gtk" , name = "TreeViewColumn" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "A #GtkTreeViewColumn on one side of @column"
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "next_column"
--           , argType =
--               TInterface Name { namespace = "Gtk" , name = "TreeViewColumn" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText =
--                     Just "A #GtkTreeViewColumn on the other side of @column"
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "data"
--           , argType = TBasicType TPtr
--           , direction = DirectionIn
--           , mayBeNull = True
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "user data" , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = 4
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Just (TBasicType TBoolean)
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_TreeViewColumnDropFunc :: FunPtr C_TreeViewColumnDropFunc -> C_TreeViewColumnDropFunc

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_TreeViewColumnDropFunc ::
    (B.CallStack.HasCallStack, MonadIO m, Gtk.TreeView.IsTreeView a, Gtk.TreeViewColumn.IsTreeViewColumn b, Gtk.TreeViewColumn.IsTreeViewColumn c, Gtk.TreeViewColumn.IsTreeViewColumn d) =>
    FunPtr C_TreeViewColumnDropFunc
    -> a
    -- ^ /@treeView@/: A t'GI.Gtk.Objects.TreeView.TreeView'
    -> b
    -- ^ /@column@/: The t'GI.Gtk.Objects.TreeViewColumn.TreeViewColumn' being dragged
    -> c
    -- ^ /@prevColumn@/: A t'GI.Gtk.Objects.TreeViewColumn.TreeViewColumn' on one side of /@column@/
    -> d
    -- ^ /@nextColumn@/: A t'GI.Gtk.Objects.TreeViewColumn.TreeViewColumn' on the other side of /@column@/
    -> Ptr ()
    -- ^ /@data@/: user data
    -> m Bool
    -- ^ __Returns:__ 'P.True', if /@column@/ can be dropped in this spot
dynamic_TreeViewColumnDropFunc __funPtr treeView column prevColumn nextColumn data_ = liftIO $ do
    treeView' <- unsafeManagedPtrCastPtr treeView
    column' <- unsafeManagedPtrCastPtr column
    prevColumn' <- unsafeManagedPtrCastPtr prevColumn
    nextColumn' <- unsafeManagedPtrCastPtr nextColumn
    result <- (__dynamic_C_TreeViewColumnDropFunc __funPtr) treeView' column' prevColumn' nextColumn' data_
    let result' = (/= 0) result
    touchManagedPtr treeView
    touchManagedPtr column
    touchManagedPtr prevColumn
    touchManagedPtr nextColumn
    return result'

-- | Generate a function pointer callable from C code, from a `C_TreeViewColumnDropFunc`.
foreign import ccall "wrapper"
    mk_TreeViewColumnDropFunc :: C_TreeViewColumnDropFunc -> IO (FunPtr C_TreeViewColumnDropFunc)

-- | Function type for determining whether /@column@/ can be dropped in a
-- particular spot (as determined by /@prevColumn@/ and /@nextColumn@/).  In
-- left to right locales, /@prevColumn@/ is on the left of the potential drop
-- spot, and /@nextColumn@/ is on the right.  In right to left mode, this is
-- reversed.  This function should return 'P.True' if the spot is a valid drop
-- spot.  Please note that returning 'P.True' does not actually indicate that
-- the column drop was made, but is meant only to indicate a possible drop
-- spot to the user.
type TreeViewColumnDropFunc =
    Gtk.TreeView.TreeView
    -- ^ /@treeView@/: A t'GI.Gtk.Objects.TreeView.TreeView'
    -> Gtk.TreeViewColumn.TreeViewColumn
    -- ^ /@column@/: The t'GI.Gtk.Objects.TreeViewColumn.TreeViewColumn' being dragged
    -> Gtk.TreeViewColumn.TreeViewColumn
    -- ^ /@prevColumn@/: A t'GI.Gtk.Objects.TreeViewColumn.TreeViewColumn' on one side of /@column@/
    -> Gtk.TreeViewColumn.TreeViewColumn
    -- ^ /@nextColumn@/: A t'GI.Gtk.Objects.TreeViewColumn.TreeViewColumn' on the other side of /@column@/
    -> IO Bool
    -- ^ __Returns:__ 'P.True', if /@column@/ can be dropped in this spot

-- | A convenience synonym for @`Nothing` :: `Maybe` `TreeViewColumnDropFunc`@.
noTreeViewColumnDropFunc :: Maybe TreeViewColumnDropFunc
noTreeViewColumnDropFunc = Nothing

-- | Function type for determining whether /@column@/ can be dropped in a
-- particular spot (as determined by /@prevColumn@/ and /@nextColumn@/).  In
-- left to right locales, /@prevColumn@/ is on the left of the potential drop
-- spot, and /@nextColumn@/ is on the right.  In right to left mode, this is
-- reversed.  This function should return 'P.True' if the spot is a valid drop
-- spot.  Please note that returning 'P.True' does not actually indicate that
-- the column drop was made, but is meant only to indicate a possible drop
-- spot to the user.
type TreeViewColumnDropFunc_WithClosures =
    Gtk.TreeView.TreeView
    -- ^ /@treeView@/: A t'GI.Gtk.Objects.TreeView.TreeView'
    -> Gtk.TreeViewColumn.TreeViewColumn
    -- ^ /@column@/: The t'GI.Gtk.Objects.TreeViewColumn.TreeViewColumn' being dragged
    -> Gtk.TreeViewColumn.TreeViewColumn
    -- ^ /@prevColumn@/: A t'GI.Gtk.Objects.TreeViewColumn.TreeViewColumn' on one side of /@column@/
    -> Gtk.TreeViewColumn.TreeViewColumn
    -- ^ /@nextColumn@/: A t'GI.Gtk.Objects.TreeViewColumn.TreeViewColumn' on the other side of /@column@/
    -> Ptr ()
    -- ^ /@data@/: user data
    -> IO Bool
    -- ^ __Returns:__ 'P.True', if /@column@/ can be dropped in this spot

-- | A convenience synonym for @`Nothing` :: `Maybe` `TreeViewColumnDropFunc_WithClosures`@.
noTreeViewColumnDropFunc_WithClosures :: Maybe TreeViewColumnDropFunc_WithClosures
noTreeViewColumnDropFunc_WithClosures = Nothing

-- | A simple wrapper that ignores the closure arguments.
drop_closures_TreeViewColumnDropFunc :: TreeViewColumnDropFunc -> TreeViewColumnDropFunc_WithClosures
drop_closures_TreeViewColumnDropFunc _f treeView column prevColumn nextColumn _ = _f treeView column prevColumn nextColumn

-- | Wrap the callback into a `GClosure`.
genClosure_TreeViewColumnDropFunc :: MonadIO m => TreeViewColumnDropFunc -> m (GClosure C_TreeViewColumnDropFunc)
genClosure_TreeViewColumnDropFunc cb = liftIO $ do
    let cb' = drop_closures_TreeViewColumnDropFunc cb
    let cb'' = wrap_TreeViewColumnDropFunc Nothing cb'
    mk_TreeViewColumnDropFunc cb'' >>= B.GClosure.newGClosure


-- | Wrap a `TreeViewColumnDropFunc` into a `C_TreeViewColumnDropFunc`.
wrap_TreeViewColumnDropFunc :: 
    Maybe (Ptr (FunPtr C_TreeViewColumnDropFunc)) ->
    TreeViewColumnDropFunc_WithClosures ->
    C_TreeViewColumnDropFunc
wrap_TreeViewColumnDropFunc gi'funptrptr gi'cb treeView column prevColumn nextColumn data_ = do
    treeView' <- (newObject Gtk.TreeView.TreeView) treeView
    column' <- (newObject Gtk.TreeViewColumn.TreeViewColumn) column
    prevColumn' <- (newObject Gtk.TreeViewColumn.TreeViewColumn) prevColumn
    nextColumn' <- (newObject Gtk.TreeViewColumn.TreeViewColumn) nextColumn
    result <- gi'cb  treeView' column' prevColumn' nextColumn' data_
    maybeReleaseFunPtr gi'funptrptr
    let result' = (fromIntegral . fromEnum) result
    return result'


-- callback TreeSelectionFunc
{- Callable
  { returnType = Just (TBasicType TBoolean)
  , returnMayBeNull = False
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation
        { rawDocText =
            Just "%TRUE, if the selection state of the row can be toggled"
        , sinceVersion = Nothing
        }
  , args =
      [ Arg
          { argCName = "selection"
          , argType =
              TInterface Name { namespace = "Gtk" , name = "TreeSelection" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText = Just "A #GtkTreeSelection"
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "model"
          , argType =
              TInterface Name { namespace = "Gtk" , name = "TreeModel" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText = Just "A #GtkTreeModel being viewed"
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "path"
          , argType =
              TInterface Name { namespace = "Gtk" , name = "TreePath" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText = Just "The #GtkTreePath of the row in question"
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "path_currently_selected"
          , argType = TBasicType TBoolean
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText = Just "%TRUE, if the path is currently selected"
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "data"
          , argType = TBasicType TPtr
          , direction = DirectionIn
          , mayBeNull = True
          , argDoc =
              Documentation
                { rawDocText = Just "user data" , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = 4
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation
        { rawDocText =
            Just
              "A function used by gtk_tree_selection_set_select_function() to filter\nwhether or not a row may be selected.  It is called whenever a row's\nstate might change.  A return value of %TRUE indicates to @selection\nthat it is okay to change the selection."
        , sinceVersion = Nothing
        }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_TreeSelectionFunc =
    Ptr Gtk.TreeSelection.TreeSelection ->
    Ptr Gtk.TreeModel.TreeModel ->
    Ptr Gtk.TreePath.TreePath ->
    CInt ->
    Ptr () ->
    IO CInt

-- Args: [ Arg
--           { argCName = "selection"
--           , argType =
--               TInterface Name { namespace = "Gtk" , name = "TreeSelection" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "A #GtkTreeSelection"
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "model"
--           , argType =
--               TInterface Name { namespace = "Gtk" , name = "TreeModel" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "A #GtkTreeModel being viewed"
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "path"
--           , argType =
--               TInterface Name { namespace = "Gtk" , name = "TreePath" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "The #GtkTreePath of the row in question"
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "path_currently_selected"
--           , argType = TBasicType TBoolean
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "%TRUE, if the path is currently selected"
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "data"
--           , argType = TBasicType TPtr
--           , direction = DirectionIn
--           , mayBeNull = True
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "user data" , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = 4
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Just (TBasicType TBoolean)
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_TreeSelectionFunc :: FunPtr C_TreeSelectionFunc -> C_TreeSelectionFunc

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_TreeSelectionFunc ::
    (B.CallStack.HasCallStack, MonadIO m, Gtk.TreeSelection.IsTreeSelection a, Gtk.TreeModel.IsTreeModel b) =>
    FunPtr C_TreeSelectionFunc
    -> a
    -- ^ /@selection@/: A t'GI.Gtk.Objects.TreeSelection.TreeSelection'
    -> b
    -- ^ /@model@/: A t'GI.Gtk.Interfaces.TreeModel.TreeModel' being viewed
    -> Gtk.TreePath.TreePath
    -- ^ /@path@/: The t'GI.Gtk.Structs.TreePath.TreePath' of the row in question
    -> Bool
    -- ^ /@pathCurrentlySelected@/: 'P.True', if the path is currently selected
    -> Ptr ()
    -- ^ /@data@/: user data
    -> m Bool
    -- ^ __Returns:__ 'P.True', if the selection state of the row can be toggled
dynamic_TreeSelectionFunc __funPtr selection model path pathCurrentlySelected data_ = liftIO $ do
    selection' <- unsafeManagedPtrCastPtr selection
    model' <- unsafeManagedPtrCastPtr model
    path' <- unsafeManagedPtrGetPtr path
    let pathCurrentlySelected' = (fromIntegral . fromEnum) pathCurrentlySelected
    result <- (__dynamic_C_TreeSelectionFunc __funPtr) selection' model' path' pathCurrentlySelected' data_
    let result' = (/= 0) result
    touchManagedPtr selection
    touchManagedPtr model
    touchManagedPtr path
    return result'

-- | Generate a function pointer callable from C code, from a `C_TreeSelectionFunc`.
foreign import ccall "wrapper"
    mk_TreeSelectionFunc :: C_TreeSelectionFunc -> IO (FunPtr C_TreeSelectionFunc)

-- | A function used by 'GI.Gtk.Objects.TreeSelection.treeSelectionSetSelectFunction' to filter
-- whether or not a row may be selected.  It is called whenever a row\'s
-- state might change.  A return value of 'P.True' indicates to /@selection@/
-- that it is okay to change the selection.
type TreeSelectionFunc =
    Gtk.TreeSelection.TreeSelection
    -- ^ /@selection@/: A t'GI.Gtk.Objects.TreeSelection.TreeSelection'
    -> Gtk.TreeModel.TreeModel
    -- ^ /@model@/: A t'GI.Gtk.Interfaces.TreeModel.TreeModel' being viewed
    -> Gtk.TreePath.TreePath
    -- ^ /@path@/: The t'GI.Gtk.Structs.TreePath.TreePath' of the row in question
    -> Bool
    -- ^ /@pathCurrentlySelected@/: 'P.True', if the path is currently selected
    -> IO Bool
    -- ^ __Returns:__ 'P.True', if the selection state of the row can be toggled

-- | A convenience synonym for @`Nothing` :: `Maybe` `TreeSelectionFunc`@.
noTreeSelectionFunc :: Maybe TreeSelectionFunc
noTreeSelectionFunc = Nothing

-- | A function used by 'GI.Gtk.Objects.TreeSelection.treeSelectionSetSelectFunction' to filter
-- whether or not a row may be selected.  It is called whenever a row\'s
-- state might change.  A return value of 'P.True' indicates to /@selection@/
-- that it is okay to change the selection.
type TreeSelectionFunc_WithClosures =
    Gtk.TreeSelection.TreeSelection
    -- ^ /@selection@/: A t'GI.Gtk.Objects.TreeSelection.TreeSelection'
    -> Gtk.TreeModel.TreeModel
    -- ^ /@model@/: A t'GI.Gtk.Interfaces.TreeModel.TreeModel' being viewed
    -> Gtk.TreePath.TreePath
    -- ^ /@path@/: The t'GI.Gtk.Structs.TreePath.TreePath' of the row in question
    -> Bool
    -- ^ /@pathCurrentlySelected@/: 'P.True', if the path is currently selected
    -> Ptr ()
    -- ^ /@data@/: user data
    -> IO Bool
    -- ^ __Returns:__ 'P.True', if the selection state of the row can be toggled

-- | A convenience synonym for @`Nothing` :: `Maybe` `TreeSelectionFunc_WithClosures`@.
noTreeSelectionFunc_WithClosures :: Maybe TreeSelectionFunc_WithClosures
noTreeSelectionFunc_WithClosures = Nothing

-- | A simple wrapper that ignores the closure arguments.
drop_closures_TreeSelectionFunc :: TreeSelectionFunc -> TreeSelectionFunc_WithClosures
drop_closures_TreeSelectionFunc _f selection model path pathCurrentlySelected _ = _f selection model path pathCurrentlySelected

-- | Wrap the callback into a `GClosure`.
genClosure_TreeSelectionFunc :: MonadIO m => TreeSelectionFunc -> m (GClosure C_TreeSelectionFunc)
genClosure_TreeSelectionFunc cb = liftIO $ do
    let cb' = drop_closures_TreeSelectionFunc cb
    let cb'' = wrap_TreeSelectionFunc Nothing cb'
    mk_TreeSelectionFunc cb'' >>= B.GClosure.newGClosure


-- | Wrap a `TreeSelectionFunc` into a `C_TreeSelectionFunc`.
wrap_TreeSelectionFunc :: 
    Maybe (Ptr (FunPtr C_TreeSelectionFunc)) ->
    TreeSelectionFunc_WithClosures ->
    C_TreeSelectionFunc
wrap_TreeSelectionFunc gi'funptrptr gi'cb selection model path pathCurrentlySelected data_ = do
    selection' <- (newObject Gtk.TreeSelection.TreeSelection) selection
    model' <- (newObject Gtk.TreeModel.TreeModel) model
    B.ManagedPtr.withTransient  path $ \path' -> do
        let pathCurrentlySelected' = (/= 0) pathCurrentlySelected
        result <- gi'cb  selection' model' path' pathCurrentlySelected' data_
        maybeReleaseFunPtr gi'funptrptr
        let result' = (fromIntegral . fromEnum) result
        return result'


-- callback TreeSelectionForeachFunc
{- Callable
  { returnType = Nothing
  , returnMayBeNull = False
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , args =
      [ Arg
          { argCName = "model"
          , argType =
              TInterface Name { namespace = "Gtk" , name = "TreeModel" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText = Just "The #GtkTreeModel being viewed"
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "path"
          , argType =
              TInterface Name { namespace = "Gtk" , name = "TreePath" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText = Just "The #GtkTreePath of a selected row"
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "iter"
          , argType =
              TInterface Name { namespace = "Gtk" , name = "TreeIter" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText = Just "A #GtkTreeIter pointing to a selected row"
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "data"
          , argType = TBasicType TPtr
          , direction = DirectionIn
          , mayBeNull = True
          , argDoc =
              Documentation
                { rawDocText = Just "user data" , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = 3
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation
        { rawDocText =
            Just
              "A function used by gtk_tree_selection_selected_foreach() to map all\nselected rows.  It will be called on every selected row in the view."
        , sinceVersion = Nothing
        }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_TreeSelectionForeachFunc =
    Ptr Gtk.TreeModel.TreeModel ->
    Ptr Gtk.TreePath.TreePath ->
    Ptr Gtk.TreeIter.TreeIter ->
    Ptr () ->
    IO ()

-- Args: [ Arg
--           { argCName = "model"
--           , argType =
--               TInterface Name { namespace = "Gtk" , name = "TreeModel" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "The #GtkTreeModel being viewed"
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "path"
--           , argType =
--               TInterface Name { namespace = "Gtk" , name = "TreePath" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "The #GtkTreePath of a selected row"
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "iter"
--           , argType =
--               TInterface Name { namespace = "Gtk" , name = "TreeIter" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "A #GtkTreeIter pointing to a selected row"
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "data"
--           , argType = TBasicType TPtr
--           , direction = DirectionIn
--           , mayBeNull = True
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "user data" , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = 3
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Nothing
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_TreeSelectionForeachFunc :: FunPtr C_TreeSelectionForeachFunc -> C_TreeSelectionForeachFunc

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_TreeSelectionForeachFunc ::
    (B.CallStack.HasCallStack, MonadIO m, Gtk.TreeModel.IsTreeModel a) =>
    FunPtr C_TreeSelectionForeachFunc
    -> a
    -- ^ /@model@/: The t'GI.Gtk.Interfaces.TreeModel.TreeModel' being viewed
    -> Gtk.TreePath.TreePath
    -- ^ /@path@/: The t'GI.Gtk.Structs.TreePath.TreePath' of a selected row
    -> Gtk.TreeIter.TreeIter
    -- ^ /@iter@/: A t'GI.Gtk.Structs.TreeIter.TreeIter' pointing to a selected row
    -> Ptr ()
    -- ^ /@data@/: user data
    -> m ()
dynamic_TreeSelectionForeachFunc __funPtr model path iter data_ = liftIO $ do
    model' <- unsafeManagedPtrCastPtr model
    path' <- unsafeManagedPtrGetPtr path
    iter' <- unsafeManagedPtrGetPtr iter
    (__dynamic_C_TreeSelectionForeachFunc __funPtr) model' path' iter' data_
    touchManagedPtr model
    touchManagedPtr path
    touchManagedPtr iter
    return ()

-- | Generate a function pointer callable from C code, from a `C_TreeSelectionForeachFunc`.
foreign import ccall "wrapper"
    mk_TreeSelectionForeachFunc :: C_TreeSelectionForeachFunc -> IO (FunPtr C_TreeSelectionForeachFunc)

-- | A function used by 'GI.Gtk.Objects.TreeSelection.treeSelectionSelectedForeach' to map all
-- selected rows.  It will be called on every selected row in the view.
type TreeSelectionForeachFunc =
    Gtk.TreeModel.TreeModel
    -- ^ /@model@/: The t'GI.Gtk.Interfaces.TreeModel.TreeModel' being viewed
    -> Gtk.TreePath.TreePath
    -- ^ /@path@/: The t'GI.Gtk.Structs.TreePath.TreePath' of a selected row
    -> Gtk.TreeIter.TreeIter
    -- ^ /@iter@/: A t'GI.Gtk.Structs.TreeIter.TreeIter' pointing to a selected row
    -> IO ()

-- | A convenience synonym for @`Nothing` :: `Maybe` `TreeSelectionForeachFunc`@.
noTreeSelectionForeachFunc :: Maybe TreeSelectionForeachFunc
noTreeSelectionForeachFunc = Nothing

-- | A function used by 'GI.Gtk.Objects.TreeSelection.treeSelectionSelectedForeach' to map all
-- selected rows.  It will be called on every selected row in the view.
type TreeSelectionForeachFunc_WithClosures =
    Gtk.TreeModel.TreeModel
    -- ^ /@model@/: The t'GI.Gtk.Interfaces.TreeModel.TreeModel' being viewed
    -> Gtk.TreePath.TreePath
    -- ^ /@path@/: The t'GI.Gtk.Structs.TreePath.TreePath' of a selected row
    -> Gtk.TreeIter.TreeIter
    -- ^ /@iter@/: A t'GI.Gtk.Structs.TreeIter.TreeIter' pointing to a selected row
    -> Ptr ()
    -- ^ /@data@/: user data
    -> IO ()

-- | A convenience synonym for @`Nothing` :: `Maybe` `TreeSelectionForeachFunc_WithClosures`@.
noTreeSelectionForeachFunc_WithClosures :: Maybe TreeSelectionForeachFunc_WithClosures
noTreeSelectionForeachFunc_WithClosures = Nothing

-- | A simple wrapper that ignores the closure arguments.
drop_closures_TreeSelectionForeachFunc :: TreeSelectionForeachFunc -> TreeSelectionForeachFunc_WithClosures
drop_closures_TreeSelectionForeachFunc _f model path iter _ = _f model path iter

-- | Wrap the callback into a `GClosure`.
genClosure_TreeSelectionForeachFunc :: MonadIO m => TreeSelectionForeachFunc -> m (GClosure C_TreeSelectionForeachFunc)
genClosure_TreeSelectionForeachFunc cb = liftIO $ do
    let cb' = drop_closures_TreeSelectionForeachFunc cb
    let cb'' = wrap_TreeSelectionForeachFunc Nothing cb'
    mk_TreeSelectionForeachFunc cb'' >>= B.GClosure.newGClosure


-- | Wrap a `TreeSelectionForeachFunc` into a `C_TreeSelectionForeachFunc`.
wrap_TreeSelectionForeachFunc :: 
    Maybe (Ptr (FunPtr C_TreeSelectionForeachFunc)) ->
    TreeSelectionForeachFunc_WithClosures ->
    C_TreeSelectionForeachFunc
wrap_TreeSelectionForeachFunc gi'funptrptr gi'cb model path iter data_ = do
    model' <- (newObject Gtk.TreeModel.TreeModel) model
    B.ManagedPtr.withTransient  path $ \path' -> do
        B.ManagedPtr.withTransient  iter $ \iter' -> do
            gi'cb  model' path' iter' data_
            maybeReleaseFunPtr gi'funptrptr


-- callback TreeModelForeachFunc
{- Callable
  { returnType = Just (TBasicType TBoolean)
  , returnMayBeNull = False
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation
        { rawDocText = Just "%TRUE to stop iterating, %FALSE to continue"
        , sinceVersion = Nothing
        }
  , args =
      [ Arg
          { argCName = "model"
          , argType =
              TInterface Name { namespace = "Gtk" , name = "TreeModel" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText = Just "the #GtkTreeModel being iterated"
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "path"
          , argType =
              TInterface Name { namespace = "Gtk" , name = "TreePath" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText = Just "the current #GtkTreePath"
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "iter"
          , argType =
              TInterface Name { namespace = "Gtk" , name = "TreeIter" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText = Just "the current #GtkTreeIter"
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "data"
          , argType = TBasicType TPtr
          , direction = DirectionIn
          , mayBeNull = True
          , argDoc =
              Documentation
                { rawDocText =
                    Just "The user data passed to gtk_tree_model_foreach()"
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = 3
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation
        { rawDocText =
            Just
              "Type of the callback passed to gtk_tree_model_foreach() to\niterate over the rows in a tree model."
        , sinceVersion = Nothing
        }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_TreeModelForeachFunc =
    Ptr Gtk.TreeModel.TreeModel ->
    Ptr Gtk.TreePath.TreePath ->
    Ptr Gtk.TreeIter.TreeIter ->
    Ptr () ->
    IO CInt

-- Args: [ Arg
--           { argCName = "model"
--           , argType =
--               TInterface Name { namespace = "Gtk" , name = "TreeModel" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "the #GtkTreeModel being iterated"
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "path"
--           , argType =
--               TInterface Name { namespace = "Gtk" , name = "TreePath" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "the current #GtkTreePath"
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "iter"
--           , argType =
--               TInterface Name { namespace = "Gtk" , name = "TreeIter" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "the current #GtkTreeIter"
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "data"
--           , argType = TBasicType TPtr
--           , direction = DirectionIn
--           , mayBeNull = True
--           , argDoc =
--               Documentation
--                 { rawDocText =
--                     Just "The user data passed to gtk_tree_model_foreach()"
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = 3
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Just (TBasicType TBoolean)
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_TreeModelForeachFunc :: FunPtr C_TreeModelForeachFunc -> C_TreeModelForeachFunc

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_TreeModelForeachFunc ::
    (B.CallStack.HasCallStack, MonadIO m, Gtk.TreeModel.IsTreeModel a) =>
    FunPtr C_TreeModelForeachFunc
    -> a
    -- ^ /@model@/: the t'GI.Gtk.Interfaces.TreeModel.TreeModel' being iterated
    -> Gtk.TreePath.TreePath
    -- ^ /@path@/: the current t'GI.Gtk.Structs.TreePath.TreePath'
    -> Gtk.TreeIter.TreeIter
    -- ^ /@iter@/: the current t'GI.Gtk.Structs.TreeIter.TreeIter'
    -> Ptr ()
    -- ^ /@data@/: The user data passed to 'GI.Gtk.Interfaces.TreeModel.treeModelForeach'
    -> m Bool
    -- ^ __Returns:__ 'P.True' to stop iterating, 'P.False' to continue
dynamic_TreeModelForeachFunc __funPtr model path iter data_ = liftIO $ do
    model' <- unsafeManagedPtrCastPtr model
    path' <- unsafeManagedPtrGetPtr path
    iter' <- unsafeManagedPtrGetPtr iter
    result <- (__dynamic_C_TreeModelForeachFunc __funPtr) model' path' iter' data_
    let result' = (/= 0) result
    touchManagedPtr model
    touchManagedPtr path
    touchManagedPtr iter
    return result'

-- | Generate a function pointer callable from C code, from a `C_TreeModelForeachFunc`.
foreign import ccall "wrapper"
    mk_TreeModelForeachFunc :: C_TreeModelForeachFunc -> IO (FunPtr C_TreeModelForeachFunc)

-- | Type of the callback passed to 'GI.Gtk.Interfaces.TreeModel.treeModelForeach' to
-- iterate over the rows in a tree model.
type TreeModelForeachFunc =
    Gtk.TreeModel.TreeModel
    -- ^ /@model@/: the t'GI.Gtk.Interfaces.TreeModel.TreeModel' being iterated
    -> Gtk.TreePath.TreePath
    -- ^ /@path@/: the current t'GI.Gtk.Structs.TreePath.TreePath'
    -> Gtk.TreeIter.TreeIter
    -- ^ /@iter@/: the current t'GI.Gtk.Structs.TreeIter.TreeIter'
    -> IO Bool
    -- ^ __Returns:__ 'P.True' to stop iterating, 'P.False' to continue

-- | A convenience synonym for @`Nothing` :: `Maybe` `TreeModelForeachFunc`@.
noTreeModelForeachFunc :: Maybe TreeModelForeachFunc
noTreeModelForeachFunc = Nothing

-- | Type of the callback passed to 'GI.Gtk.Interfaces.TreeModel.treeModelForeach' to
-- iterate over the rows in a tree model.
type TreeModelForeachFunc_WithClosures =
    Gtk.TreeModel.TreeModel
    -- ^ /@model@/: the t'GI.Gtk.Interfaces.TreeModel.TreeModel' being iterated
    -> Gtk.TreePath.TreePath
    -- ^ /@path@/: the current t'GI.Gtk.Structs.TreePath.TreePath'
    -> Gtk.TreeIter.TreeIter
    -- ^ /@iter@/: the current t'GI.Gtk.Structs.TreeIter.TreeIter'
    -> Ptr ()
    -- ^ /@data@/: The user data passed to 'GI.Gtk.Interfaces.TreeModel.treeModelForeach'
    -> IO Bool
    -- ^ __Returns:__ 'P.True' to stop iterating, 'P.False' to continue

-- | A convenience synonym for @`Nothing` :: `Maybe` `TreeModelForeachFunc_WithClosures`@.
noTreeModelForeachFunc_WithClosures :: Maybe TreeModelForeachFunc_WithClosures
noTreeModelForeachFunc_WithClosures = Nothing

-- | A simple wrapper that ignores the closure arguments.
drop_closures_TreeModelForeachFunc :: TreeModelForeachFunc -> TreeModelForeachFunc_WithClosures
drop_closures_TreeModelForeachFunc _f model path iter _ = _f model path iter

-- | Wrap the callback into a `GClosure`.
genClosure_TreeModelForeachFunc :: MonadIO m => TreeModelForeachFunc -> m (GClosure C_TreeModelForeachFunc)
genClosure_TreeModelForeachFunc cb = liftIO $ do
    let cb' = drop_closures_TreeModelForeachFunc cb
    let cb'' = wrap_TreeModelForeachFunc Nothing cb'
    mk_TreeModelForeachFunc cb'' >>= B.GClosure.newGClosure


-- | Wrap a `TreeModelForeachFunc` into a `C_TreeModelForeachFunc`.
wrap_TreeModelForeachFunc :: 
    Maybe (Ptr (FunPtr C_TreeModelForeachFunc)) ->
    TreeModelForeachFunc_WithClosures ->
    C_TreeModelForeachFunc
wrap_TreeModelForeachFunc gi'funptrptr gi'cb model path iter data_ = do
    model' <- (newObject Gtk.TreeModel.TreeModel) model
    B.ManagedPtr.withTransient  path $ \path' -> do
        B.ManagedPtr.withTransient  iter $ \iter' -> do
            result <- gi'cb  model' path' iter' data_
            maybeReleaseFunPtr gi'funptrptr
            let result' = (fromIntegral . fromEnum) result
            return result'


-- callback TreeModelFilterVisibleFunc
{- Callable
  { returnType = Just (TBasicType TBoolean)
  , returnMayBeNull = False
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation
        { rawDocText =
            Just "Whether the row indicated by @iter is visible."
        , sinceVersion = Nothing
        }
  , args =
      [ Arg
          { argCName = "model"
          , argType =
              TInterface Name { namespace = "Gtk" , name = "TreeModel" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText = Just "the child model of the #GtkTreeModelFilter"
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "iter"
          , argType =
              TInterface Name { namespace = "Gtk" , name = "TreeIter" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText =
                    Just
                      "a #GtkTreeIter pointing to the row in @model whose visibility\n  is determined"
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "data"
          , argType = TBasicType TPtr
          , direction = DirectionIn
          , mayBeNull = True
          , argDoc =
              Documentation
                { rawDocText =
                    Just "user data given to gtk_tree_model_filter_set_visible_func()"
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = 2
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation
        { rawDocText =
            Just
              "A function which decides whether the row indicated by @iter is visible."
        , sinceVersion = Nothing
        }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_TreeModelFilterVisibleFunc =
    Ptr Gtk.TreeModel.TreeModel ->
    Ptr Gtk.TreeIter.TreeIter ->
    Ptr () ->
    IO CInt

-- Args: [ Arg
--           { argCName = "model"
--           , argType =
--               TInterface Name { namespace = "Gtk" , name = "TreeModel" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "the child model of the #GtkTreeModelFilter"
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "iter"
--           , argType =
--               TInterface Name { namespace = "Gtk" , name = "TreeIter" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText =
--                     Just
--                       "a #GtkTreeIter pointing to the row in @model whose visibility\n  is determined"
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "data"
--           , argType = TBasicType TPtr
--           , direction = DirectionIn
--           , mayBeNull = True
--           , argDoc =
--               Documentation
--                 { rawDocText =
--                     Just "user data given to gtk_tree_model_filter_set_visible_func()"
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = 2
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Just (TBasicType TBoolean)
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_TreeModelFilterVisibleFunc :: FunPtr C_TreeModelFilterVisibleFunc -> C_TreeModelFilterVisibleFunc

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_TreeModelFilterVisibleFunc ::
    (B.CallStack.HasCallStack, MonadIO m, Gtk.TreeModel.IsTreeModel a) =>
    FunPtr C_TreeModelFilterVisibleFunc
    -> a
    -- ^ /@model@/: the child model of the t'GI.Gtk.Objects.TreeModelFilter.TreeModelFilter'
    -> Gtk.TreeIter.TreeIter
    -- ^ /@iter@/: a t'GI.Gtk.Structs.TreeIter.TreeIter' pointing to the row in /@model@/ whose visibility
    --   is determined
    -> Ptr ()
    -- ^ /@data@/: user data given to 'GI.Gtk.Objects.TreeModelFilter.treeModelFilterSetVisibleFunc'
    -> m Bool
    -- ^ __Returns:__ Whether the row indicated by /@iter@/ is visible.
dynamic_TreeModelFilterVisibleFunc __funPtr model iter data_ = liftIO $ do
    model' <- unsafeManagedPtrCastPtr model
    iter' <- unsafeManagedPtrGetPtr iter
    result <- (__dynamic_C_TreeModelFilterVisibleFunc __funPtr) model' iter' data_
    let result' = (/= 0) result
    touchManagedPtr model
    touchManagedPtr iter
    return result'

-- | Generate a function pointer callable from C code, from a `C_TreeModelFilterVisibleFunc`.
foreign import ccall "wrapper"
    mk_TreeModelFilterVisibleFunc :: C_TreeModelFilterVisibleFunc -> IO (FunPtr C_TreeModelFilterVisibleFunc)

-- | A function which decides whether the row indicated by /@iter@/ is visible.
type TreeModelFilterVisibleFunc =
    Gtk.TreeModel.TreeModel
    -- ^ /@model@/: the child model of the t'GI.Gtk.Objects.TreeModelFilter.TreeModelFilter'
    -> Gtk.TreeIter.TreeIter
    -- ^ /@iter@/: a t'GI.Gtk.Structs.TreeIter.TreeIter' pointing to the row in /@model@/ whose visibility
    --   is determined
    -> IO Bool
    -- ^ __Returns:__ Whether the row indicated by /@iter@/ is visible.

-- | A convenience synonym for @`Nothing` :: `Maybe` `TreeModelFilterVisibleFunc`@.
noTreeModelFilterVisibleFunc :: Maybe TreeModelFilterVisibleFunc
noTreeModelFilterVisibleFunc = Nothing

-- | A function which decides whether the row indicated by /@iter@/ is visible.
type TreeModelFilterVisibleFunc_WithClosures =
    Gtk.TreeModel.TreeModel
    -- ^ /@model@/: the child model of the t'GI.Gtk.Objects.TreeModelFilter.TreeModelFilter'
    -> Gtk.TreeIter.TreeIter
    -- ^ /@iter@/: a t'GI.Gtk.Structs.TreeIter.TreeIter' pointing to the row in /@model@/ whose visibility
    --   is determined
    -> Ptr ()
    -- ^ /@data@/: user data given to 'GI.Gtk.Objects.TreeModelFilter.treeModelFilterSetVisibleFunc'
    -> IO Bool
    -- ^ __Returns:__ Whether the row indicated by /@iter@/ is visible.

-- | A convenience synonym for @`Nothing` :: `Maybe` `TreeModelFilterVisibleFunc_WithClosures`@.
noTreeModelFilterVisibleFunc_WithClosures :: Maybe TreeModelFilterVisibleFunc_WithClosures
noTreeModelFilterVisibleFunc_WithClosures = Nothing

-- | A simple wrapper that ignores the closure arguments.
drop_closures_TreeModelFilterVisibleFunc :: TreeModelFilterVisibleFunc -> TreeModelFilterVisibleFunc_WithClosures
drop_closures_TreeModelFilterVisibleFunc _f model iter _ = _f model iter

-- | Wrap the callback into a `GClosure`.
genClosure_TreeModelFilterVisibleFunc :: MonadIO m => TreeModelFilterVisibleFunc -> m (GClosure C_TreeModelFilterVisibleFunc)
genClosure_TreeModelFilterVisibleFunc cb = liftIO $ do
    let cb' = drop_closures_TreeModelFilterVisibleFunc cb
    let cb'' = wrap_TreeModelFilterVisibleFunc Nothing cb'
    mk_TreeModelFilterVisibleFunc cb'' >>= B.GClosure.newGClosure


-- | Wrap a `TreeModelFilterVisibleFunc` into a `C_TreeModelFilterVisibleFunc`.
wrap_TreeModelFilterVisibleFunc :: 
    Maybe (Ptr (FunPtr C_TreeModelFilterVisibleFunc)) ->
    TreeModelFilterVisibleFunc_WithClosures ->
    C_TreeModelFilterVisibleFunc
wrap_TreeModelFilterVisibleFunc gi'funptrptr gi'cb model iter data_ = do
    model' <- (newObject Gtk.TreeModel.TreeModel) model
    B.ManagedPtr.withTransient  iter $ \iter' -> do
        result <- gi'cb  model' iter' data_
        maybeReleaseFunPtr gi'funptrptr
        let result' = (fromIntegral . fromEnum) result
        return result'


-- callback TreeModelFilterModifyFunc
{- Callable
  { returnType = Nothing
  , returnMayBeNull = False
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , args =
      [ Arg
          { argCName = "model"
          , argType =
              TInterface Name { namespace = "Gtk" , name = "TreeModel" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText = Just "the #GtkTreeModelFilter"
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "iter"
          , argType =
              TInterface Name { namespace = "Gtk" , name = "TreeIter" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText =
                    Just
                      "a #GtkTreeIter pointing to the row whose display values are determined"
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "value"
          , argType = TGValue
          , direction = DirectionOut
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText =
                    Just
                      "A #GValue which is already initialized for\n with the correct type for the column @column."
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = True
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "column"
          , argType = TBasicType TInt
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText = Just "the column whose display value is determined"
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "data"
          , argType = TBasicType TPtr
          , direction = DirectionIn
          , mayBeNull = True
          , argDoc =
              Documentation
                { rawDocText =
                    Just "user data given to gtk_tree_model_filter_set_modify_func()"
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = 4
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation
        { rawDocText =
            Just
              "A function which calculates display values from raw values in the model.\nIt must fill @value with the display value for the column @column in the\nrow indicated by @iter.\n\nSince this function is called for each data access, it\8217s not a\nparticularly efficient operation."
        , sinceVersion = Nothing
        }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_TreeModelFilterModifyFunc =
    Ptr Gtk.TreeModel.TreeModel ->
    Ptr Gtk.TreeIter.TreeIter ->
    Ptr GValue ->
    Int32 ->
    Ptr () ->
    IO ()

-- Args: [ Arg
--           { argCName = "model"
--           , argType =
--               TInterface Name { namespace = "Gtk" , name = "TreeModel" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "the #GtkTreeModelFilter"
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "iter"
--           , argType =
--               TInterface Name { namespace = "Gtk" , name = "TreeIter" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText =
--                     Just
--                       "a #GtkTreeIter pointing to the row whose display values are determined"
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "value"
--           , argType = TGValue
--           , direction = DirectionOut
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText =
--                     Just
--                       "A #GValue which is already initialized for\n with the correct type for the column @column."
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = True
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "column"
--           , argType = TBasicType TInt
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "the column whose display value is determined"
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "data"
--           , argType = TBasicType TPtr
--           , direction = DirectionIn
--           , mayBeNull = True
--           , argDoc =
--               Documentation
--                 { rawDocText =
--                     Just "user data given to gtk_tree_model_filter_set_modify_func()"
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = 4
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Nothing
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_TreeModelFilterModifyFunc :: FunPtr C_TreeModelFilterModifyFunc -> C_TreeModelFilterModifyFunc

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_TreeModelFilterModifyFunc ::
    (B.CallStack.HasCallStack, MonadIO m, Gtk.TreeModel.IsTreeModel a) =>
    FunPtr C_TreeModelFilterModifyFunc
    -> a
    -- ^ /@model@/: the t'GI.Gtk.Objects.TreeModelFilter.TreeModelFilter'
    -> Gtk.TreeIter.TreeIter
    -- ^ /@iter@/: a t'GI.Gtk.Structs.TreeIter.TreeIter' pointing to the row whose display values are determined
    -> Int32
    -- ^ /@column@/: the column whose display value is determined
    -> Ptr ()
    -- ^ /@data@/: user data given to @/gtk_tree_model_filter_set_modify_func()/@
    -> m (GValue)
dynamic_TreeModelFilterModifyFunc __funPtr model iter column data_ = liftIO $ do
    model' <- unsafeManagedPtrCastPtr model
    iter' <- unsafeManagedPtrGetPtr iter
    value <- SP.callocBytes 24 :: IO (Ptr GValue)
    (__dynamic_C_TreeModelFilterModifyFunc __funPtr) model' iter' value column data_
    value' <- B.GValue.wrapGValuePtr value
    touchManagedPtr model
    touchManagedPtr iter
    return value'

-- | Generate a function pointer callable from C code, from a `C_TreeModelFilterModifyFunc`.
foreign import ccall "wrapper"
    mk_TreeModelFilterModifyFunc :: C_TreeModelFilterModifyFunc -> IO (FunPtr C_TreeModelFilterModifyFunc)

-- | A function which calculates display values from raw values in the model.
-- It must fill /@value@/ with the display value for the column /@column@/ in the
-- row indicated by /@iter@/.
-- 
-- Since this function is called for each data access, it’s not a
-- particularly efficient operation.
type TreeModelFilterModifyFunc =
    Gtk.TreeModel.TreeModel
    -- ^ /@model@/: the t'GI.Gtk.Objects.TreeModelFilter.TreeModelFilter'
    -> Gtk.TreeIter.TreeIter
    -- ^ /@iter@/: a t'GI.Gtk.Structs.TreeIter.TreeIter' pointing to the row whose display values are determined
    -> Int32
    -- ^ /@column@/: the column whose display value is determined
    -> IO (GValue)

-- | A convenience synonym for @`Nothing` :: `Maybe` `TreeModelFilterModifyFunc`@.
noTreeModelFilterModifyFunc :: Maybe TreeModelFilterModifyFunc
noTreeModelFilterModifyFunc = Nothing

-- | A function which calculates display values from raw values in the model.
-- It must fill /@value@/ with the display value for the column /@column@/ in the
-- row indicated by /@iter@/.
-- 
-- Since this function is called for each data access, it’s not a
-- particularly efficient operation.
type TreeModelFilterModifyFunc_WithClosures =
    Gtk.TreeModel.TreeModel
    -- ^ /@model@/: the t'GI.Gtk.Objects.TreeModelFilter.TreeModelFilter'
    -> Gtk.TreeIter.TreeIter
    -- ^ /@iter@/: a t'GI.Gtk.Structs.TreeIter.TreeIter' pointing to the row whose display values are determined
    -> Int32
    -- ^ /@column@/: the column whose display value is determined
    -> Ptr ()
    -- ^ /@data@/: user data given to @/gtk_tree_model_filter_set_modify_func()/@
    -> IO (GValue)

-- | A convenience synonym for @`Nothing` :: `Maybe` `TreeModelFilterModifyFunc_WithClosures`@.
noTreeModelFilterModifyFunc_WithClosures :: Maybe TreeModelFilterModifyFunc_WithClosures
noTreeModelFilterModifyFunc_WithClosures = Nothing

-- | A simple wrapper that ignores the closure arguments.
drop_closures_TreeModelFilterModifyFunc :: TreeModelFilterModifyFunc -> TreeModelFilterModifyFunc_WithClosures
drop_closures_TreeModelFilterModifyFunc _f model iter column _ = _f model iter column

-- | Wrap the callback into a `GClosure`.
genClosure_TreeModelFilterModifyFunc :: MonadIO m => TreeModelFilterModifyFunc -> m (GClosure C_TreeModelFilterModifyFunc)
genClosure_TreeModelFilterModifyFunc cb = liftIO $ do
    let cb' = drop_closures_TreeModelFilterModifyFunc cb
    let cb'' = wrap_TreeModelFilterModifyFunc Nothing cb'
    mk_TreeModelFilterModifyFunc cb'' >>= B.GClosure.newGClosure


-- | Wrap a `TreeModelFilterModifyFunc` into a `C_TreeModelFilterModifyFunc`.
wrap_TreeModelFilterModifyFunc :: 
    Maybe (Ptr (FunPtr C_TreeModelFilterModifyFunc)) ->
    TreeModelFilterModifyFunc_WithClosures ->
    C_TreeModelFilterModifyFunc
wrap_TreeModelFilterModifyFunc gi'funptrptr gi'cb model iter value column data_ = do
    -- XXX Could not generate callback wrapper for TreeModelFilterModifyFunc
    -- Not implemented: Unexpected transfer type for "value"
    P.error "The bindings for wrap_TreeModelFilterModifyFunc could not be generated, function unsupported."


-- callback TreeIterCompareFunc
{- Callable
  { returnType = Just (TBasicType TInt)
  , returnMayBeNull = False
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation
        { rawDocText =
            Just
              "a negative integer, zero or a positive integer depending on whether\n  @a sorts before, with or after @b"
        , sinceVersion = Nothing
        }
  , args =
      [ Arg
          { argCName = "model"
          , argType =
              TInterface Name { namespace = "Gtk" , name = "TreeModel" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText = Just "The #GtkTreeModel the comparison is within"
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "a"
          , argType =
              TInterface Name { namespace = "Gtk" , name = "TreeIter" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText = Just "A #GtkTreeIter in @model"
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "b"
          , argType =
              TInterface Name { namespace = "Gtk" , name = "TreeIter" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText = Just "Another #GtkTreeIter in @model"
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "user_data"
          , argType = TBasicType TPtr
          , direction = DirectionIn
          , mayBeNull = True
          , argDoc =
              Documentation
                { rawDocText =
                    Just
                      "Data passed when the compare func is assigned e.g. by\n gtk_tree_sortable_set_sort_func()"
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = 3
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation
        { rawDocText =
            Just
              "A GtkTreeIterCompareFunc should return a negative integer, zero, or a positive\ninteger if @a sorts before @b, @a sorts with @b, or @a sorts after @b\nrespectively. If two iters compare as equal, their order in the sorted model\nis undefined. In order to ensure that the #GtkTreeSortable behaves as\nexpected, the GtkTreeIterCompareFunc must define a partial order on\nthe model, i.e. it must be reflexive, antisymmetric and transitive.\n\nFor example, if @model is a product catalogue, then a compare function\nfor the \8220price\8221 column could be one which returns\n`price_of(@a) - price_of(@b)`."
        , sinceVersion = Nothing
        }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_TreeIterCompareFunc =
    Ptr Gtk.TreeModel.TreeModel ->
    Ptr Gtk.TreeIter.TreeIter ->
    Ptr Gtk.TreeIter.TreeIter ->
    Ptr () ->
    IO Int32

-- Args: [ Arg
--           { argCName = "model"
--           , argType =
--               TInterface Name { namespace = "Gtk" , name = "TreeModel" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "The #GtkTreeModel the comparison is within"
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "a"
--           , argType =
--               TInterface Name { namespace = "Gtk" , name = "TreeIter" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "A #GtkTreeIter in @model"
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "b"
--           , argType =
--               TInterface Name { namespace = "Gtk" , name = "TreeIter" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "Another #GtkTreeIter in @model"
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "user_data"
--           , argType = TBasicType TPtr
--           , direction = DirectionIn
--           , mayBeNull = True
--           , argDoc =
--               Documentation
--                 { rawDocText =
--                     Just
--                       "Data passed when the compare func is assigned e.g. by\n gtk_tree_sortable_set_sort_func()"
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = 3
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Just (TBasicType TInt)
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_TreeIterCompareFunc :: FunPtr C_TreeIterCompareFunc -> C_TreeIterCompareFunc

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_TreeIterCompareFunc ::
    (B.CallStack.HasCallStack, MonadIO m, Gtk.TreeModel.IsTreeModel a) =>
    FunPtr C_TreeIterCompareFunc
    -> a
    -- ^ /@model@/: The t'GI.Gtk.Interfaces.TreeModel.TreeModel' the comparison is within
    -> Gtk.TreeIter.TreeIter
    -- ^ /@a@/: A t'GI.Gtk.Structs.TreeIter.TreeIter' in /@model@/
    -> Gtk.TreeIter.TreeIter
    -- ^ /@b@/: Another t'GI.Gtk.Structs.TreeIter.TreeIter' in /@model@/
    -> Ptr ()
    -- ^ /@userData@/: Data passed when the compare func is assigned e.g. by
    --  'GI.Gtk.Interfaces.TreeSortable.treeSortableSetSortFunc'
    -> m Int32
    -- ^ __Returns:__ a negative integer, zero or a positive integer depending on whether
    --   /@a@/ sorts before, with or after /@b@/
dynamic_TreeIterCompareFunc __funPtr model a b userData = liftIO $ do
    model' <- unsafeManagedPtrCastPtr model
    a' <- unsafeManagedPtrGetPtr a
    b' <- unsafeManagedPtrGetPtr b
    result <- (__dynamic_C_TreeIterCompareFunc __funPtr) model' a' b' userData
    touchManagedPtr model
    touchManagedPtr a
    touchManagedPtr b
    return result

-- | Generate a function pointer callable from C code, from a `C_TreeIterCompareFunc`.
foreign import ccall "wrapper"
    mk_TreeIterCompareFunc :: C_TreeIterCompareFunc -> IO (FunPtr C_TreeIterCompareFunc)

-- | A GtkTreeIterCompareFunc should return a negative integer, zero, or a positive
-- integer if /@a@/ sorts before /@b@/, /@a@/ sorts with /@b@/, or /@a@/ sorts after /@b@/
-- respectively. If two iters compare as equal, their order in the sorted model
-- is undefined. In order to ensure that the t'GI.Gtk.Interfaces.TreeSortable.TreeSortable' behaves as
-- expected, the GtkTreeIterCompareFunc must define a partial order on
-- the model, i.e. it must be reflexive, antisymmetric and transitive.
-- 
-- For example, if /@model@/ is a product catalogue, then a compare function
-- for the “price” column could be one which returns
-- @price_of(\@a) - price_of(\@b)@.
type TreeIterCompareFunc =
    Gtk.TreeModel.TreeModel
    -- ^ /@model@/: The t'GI.Gtk.Interfaces.TreeModel.TreeModel' the comparison is within
    -> Gtk.TreeIter.TreeIter
    -- ^ /@a@/: A t'GI.Gtk.Structs.TreeIter.TreeIter' in /@model@/
    -> Gtk.TreeIter.TreeIter
    -- ^ /@b@/: Another t'GI.Gtk.Structs.TreeIter.TreeIter' in /@model@/
    -> IO Int32
    -- ^ __Returns:__ a negative integer, zero or a positive integer depending on whether
    --   /@a@/ sorts before, with or after /@b@/

-- | A convenience synonym for @`Nothing` :: `Maybe` `TreeIterCompareFunc`@.
noTreeIterCompareFunc :: Maybe TreeIterCompareFunc
noTreeIterCompareFunc = Nothing

-- | A GtkTreeIterCompareFunc should return a negative integer, zero, or a positive
-- integer if /@a@/ sorts before /@b@/, /@a@/ sorts with /@b@/, or /@a@/ sorts after /@b@/
-- respectively. If two iters compare as equal, their order in the sorted model
-- is undefined. In order to ensure that the t'GI.Gtk.Interfaces.TreeSortable.TreeSortable' behaves as
-- expected, the GtkTreeIterCompareFunc must define a partial order on
-- the model, i.e. it must be reflexive, antisymmetric and transitive.
-- 
-- For example, if /@model@/ is a product catalogue, then a compare function
-- for the “price” column could be one which returns
-- @price_of(\@a) - price_of(\@b)@.
type TreeIterCompareFunc_WithClosures =
    Gtk.TreeModel.TreeModel
    -- ^ /@model@/: The t'GI.Gtk.Interfaces.TreeModel.TreeModel' the comparison is within
    -> Gtk.TreeIter.TreeIter
    -- ^ /@a@/: A t'GI.Gtk.Structs.TreeIter.TreeIter' in /@model@/
    -> Gtk.TreeIter.TreeIter
    -- ^ /@b@/: Another t'GI.Gtk.Structs.TreeIter.TreeIter' in /@model@/
    -> Ptr ()
    -- ^ /@userData@/: Data passed when the compare func is assigned e.g. by
    --  'GI.Gtk.Interfaces.TreeSortable.treeSortableSetSortFunc'
    -> IO Int32
    -- ^ __Returns:__ a negative integer, zero or a positive integer depending on whether
    --   /@a@/ sorts before, with or after /@b@/

-- | A convenience synonym for @`Nothing` :: `Maybe` `TreeIterCompareFunc_WithClosures`@.
noTreeIterCompareFunc_WithClosures :: Maybe TreeIterCompareFunc_WithClosures
noTreeIterCompareFunc_WithClosures = Nothing

-- | A simple wrapper that ignores the closure arguments.
drop_closures_TreeIterCompareFunc :: TreeIterCompareFunc -> TreeIterCompareFunc_WithClosures
drop_closures_TreeIterCompareFunc _f model a b _ = _f model a b

-- | Wrap the callback into a `GClosure`.
genClosure_TreeIterCompareFunc :: MonadIO m => TreeIterCompareFunc -> m (GClosure C_TreeIterCompareFunc)
genClosure_TreeIterCompareFunc cb = liftIO $ do
    let cb' = drop_closures_TreeIterCompareFunc cb
    let cb'' = wrap_TreeIterCompareFunc Nothing cb'
    mk_TreeIterCompareFunc cb'' >>= B.GClosure.newGClosure


-- | Wrap a `TreeIterCompareFunc` into a `C_TreeIterCompareFunc`.
wrap_TreeIterCompareFunc :: 
    Maybe (Ptr (FunPtr C_TreeIterCompareFunc)) ->
    TreeIterCompareFunc_WithClosures ->
    C_TreeIterCompareFunc
wrap_TreeIterCompareFunc gi'funptrptr gi'cb model a b userData = do
    model' <- (newObject Gtk.TreeModel.TreeModel) model
    B.ManagedPtr.withTransient  a $ \a' -> do
        B.ManagedPtr.withTransient  b $ \b' -> do
            result <- gi'cb  model' a' b' userData
            maybeReleaseFunPtr gi'funptrptr
            return result


-- callback TreeDestroyCountFunc
{- Callable
  { returnType = Nothing
  , returnMayBeNull = False
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , args =
      [ Arg
          { argCName = "tree_view"
          , argType =
              TInterface Name { namespace = "Gtk" , name = "TreeView" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "path"
          , argType =
              TInterface Name { namespace = "Gtk" , name = "TreePath" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "children"
          , argType = TBasicType TInt
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "user_data"
          , argType = TBasicType TPtr
          , direction = DirectionIn
          , mayBeNull = True
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = 3
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_TreeDestroyCountFunc =
    Ptr Gtk.TreeView.TreeView ->
    Ptr Gtk.TreePath.TreePath ->
    Int32 ->
    Ptr () ->
    IO ()

-- Args: [ Arg
--           { argCName = "tree_view"
--           , argType =
--               TInterface Name { namespace = "Gtk" , name = "TreeView" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "path"
--           , argType =
--               TInterface Name { namespace = "Gtk" , name = "TreePath" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "children"
--           , argType = TBasicType TInt
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "user_data"
--           , argType = TBasicType TPtr
--           , direction = DirectionIn
--           , mayBeNull = True
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = 3
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Nothing
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_TreeDestroyCountFunc :: FunPtr C_TreeDestroyCountFunc -> C_TreeDestroyCountFunc

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_TreeDestroyCountFunc ::
    (B.CallStack.HasCallStack, MonadIO m, Gtk.TreeView.IsTreeView a) =>
    FunPtr C_TreeDestroyCountFunc
    -> a
    -> Gtk.TreePath.TreePath
    -> Int32
    -> Ptr ()
    -> m ()
dynamic_TreeDestroyCountFunc __funPtr treeView path children userData = liftIO $ do
    treeView' <- unsafeManagedPtrCastPtr treeView
    path' <- unsafeManagedPtrGetPtr path
    (__dynamic_C_TreeDestroyCountFunc __funPtr) treeView' path' children userData
    touchManagedPtr treeView
    touchManagedPtr path
    return ()

-- | Generate a function pointer callable from C code, from a `C_TreeDestroyCountFunc`.
foreign import ccall "wrapper"
    mk_TreeDestroyCountFunc :: C_TreeDestroyCountFunc -> IO (FunPtr C_TreeDestroyCountFunc)

-- | /No description available in the introspection data./
type TreeDestroyCountFunc =
    Gtk.TreeView.TreeView
    -> Gtk.TreePath.TreePath
    -> Int32
    -> IO ()

-- | A convenience synonym for @`Nothing` :: `Maybe` `TreeDestroyCountFunc`@.
noTreeDestroyCountFunc :: Maybe TreeDestroyCountFunc
noTreeDestroyCountFunc = Nothing

-- | /No description available in the introspection data./
type TreeDestroyCountFunc_WithClosures =
    Gtk.TreeView.TreeView
    -> Gtk.TreePath.TreePath
    -> Int32
    -> Ptr ()
    -> IO ()

-- | A convenience synonym for @`Nothing` :: `Maybe` `TreeDestroyCountFunc_WithClosures`@.
noTreeDestroyCountFunc_WithClosures :: Maybe TreeDestroyCountFunc_WithClosures
noTreeDestroyCountFunc_WithClosures = Nothing

-- | A simple wrapper that ignores the closure arguments.
drop_closures_TreeDestroyCountFunc :: TreeDestroyCountFunc -> TreeDestroyCountFunc_WithClosures
drop_closures_TreeDestroyCountFunc _f treeView path children _ = _f treeView path children

-- | Wrap the callback into a `GClosure`.
genClosure_TreeDestroyCountFunc :: MonadIO m => TreeDestroyCountFunc -> m (GClosure C_TreeDestroyCountFunc)
genClosure_TreeDestroyCountFunc cb = liftIO $ do
    let cb' = drop_closures_TreeDestroyCountFunc cb
    let cb'' = wrap_TreeDestroyCountFunc Nothing cb'
    mk_TreeDestroyCountFunc cb'' >>= B.GClosure.newGClosure


-- | Wrap a `TreeDestroyCountFunc` into a `C_TreeDestroyCountFunc`.
wrap_TreeDestroyCountFunc :: 
    Maybe (Ptr (FunPtr C_TreeDestroyCountFunc)) ->
    TreeDestroyCountFunc_WithClosures ->
    C_TreeDestroyCountFunc
wrap_TreeDestroyCountFunc gi'funptrptr gi'cb treeView path children userData = do
    treeView' <- (newObject Gtk.TreeView.TreeView) treeView
    B.ManagedPtr.withTransient  path $ \path' -> do
        gi'cb  treeView' path' children userData
        maybeReleaseFunPtr gi'funptrptr


-- callback TreeCellDataFunc
{- Callable
  { returnType = Nothing
  , returnMayBeNull = False
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , args =
      [ Arg
          { argCName = "tree_column"
          , argType =
              TInterface Name { namespace = "Gtk" , name = "TreeViewColumn" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText = Just "A #GtkTreeViewColumn"
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "cell"
          , argType =
              TInterface Name { namespace = "Gtk" , name = "CellRenderer" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText =
                    Just "The #GtkCellRenderer that is being rendered by @tree_column"
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "tree_model"
          , argType =
              TInterface Name { namespace = "Gtk" , name = "TreeModel" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText = Just "The #GtkTreeModel being rendered"
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "iter"
          , argType =
              TInterface Name { namespace = "Gtk" , name = "TreeIter" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText = Just "A #GtkTreeIter of the current row rendered"
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "data"
          , argType = TBasicType TPtr
          , direction = DirectionIn
          , mayBeNull = True
          , argDoc =
              Documentation
                { rawDocText = Just "user data" , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = 4
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation
        { rawDocText =
            Just
              "A function to set the properties of a cell instead of just using the\nstraight mapping between the cell and the model.  This is useful for\ncustomizing the cell renderer.  For example, a function might get an\ninteger from the @tree_model, and render it to the \8220text\8221 attribute of\n\8220cell\8221 by converting it to its written equivalent.  This is set by\ncalling gtk_tree_view_column_set_cell_data_func()"
        , sinceVersion = Nothing
        }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_TreeCellDataFunc =
    Ptr Gtk.TreeViewColumn.TreeViewColumn ->
    Ptr Gtk.CellRenderer.CellRenderer ->
    Ptr Gtk.TreeModel.TreeModel ->
    Ptr Gtk.TreeIter.TreeIter ->
    Ptr () ->
    IO ()

-- Args: [ Arg
--           { argCName = "tree_column"
--           , argType =
--               TInterface Name { namespace = "Gtk" , name = "TreeViewColumn" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "A #GtkTreeViewColumn"
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "cell"
--           , argType =
--               TInterface Name { namespace = "Gtk" , name = "CellRenderer" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText =
--                     Just "The #GtkCellRenderer that is being rendered by @tree_column"
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "tree_model"
--           , argType =
--               TInterface Name { namespace = "Gtk" , name = "TreeModel" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "The #GtkTreeModel being rendered"
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "iter"
--           , argType =
--               TInterface Name { namespace = "Gtk" , name = "TreeIter" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "A #GtkTreeIter of the current row rendered"
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "data"
--           , argType = TBasicType TPtr
--           , direction = DirectionIn
--           , mayBeNull = True
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "user data" , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = 4
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Nothing
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_TreeCellDataFunc :: FunPtr C_TreeCellDataFunc -> C_TreeCellDataFunc

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_TreeCellDataFunc ::
    (B.CallStack.HasCallStack, MonadIO m, Gtk.TreeViewColumn.IsTreeViewColumn a, Gtk.CellRenderer.IsCellRenderer b, Gtk.TreeModel.IsTreeModel c) =>
    FunPtr C_TreeCellDataFunc
    -> a
    -- ^ /@treeColumn@/: A t'GI.Gtk.Objects.TreeViewColumn.TreeViewColumn'
    -> b
    -- ^ /@cell@/: The t'GI.Gtk.Objects.CellRenderer.CellRenderer' that is being rendered by /@treeColumn@/
    -> c
    -- ^ /@treeModel@/: The t'GI.Gtk.Interfaces.TreeModel.TreeModel' being rendered
    -> Gtk.TreeIter.TreeIter
    -- ^ /@iter@/: A t'GI.Gtk.Structs.TreeIter.TreeIter' of the current row rendered
    -> Ptr ()
    -- ^ /@data@/: user data
    -> m ()
dynamic_TreeCellDataFunc __funPtr treeColumn cell treeModel iter data_ = liftIO $ do
    treeColumn' <- unsafeManagedPtrCastPtr treeColumn
    cell' <- unsafeManagedPtrCastPtr cell
    treeModel' <- unsafeManagedPtrCastPtr treeModel
    iter' <- unsafeManagedPtrGetPtr iter
    (__dynamic_C_TreeCellDataFunc __funPtr) treeColumn' cell' treeModel' iter' data_
    touchManagedPtr treeColumn
    touchManagedPtr cell
    touchManagedPtr treeModel
    touchManagedPtr iter
    return ()

-- | Generate a function pointer callable from C code, from a `C_TreeCellDataFunc`.
foreign import ccall "wrapper"
    mk_TreeCellDataFunc :: C_TreeCellDataFunc -> IO (FunPtr C_TreeCellDataFunc)

-- | A function to set the properties of a cell instead of just using the
-- straight mapping between the cell and the model.  This is useful for
-- customizing the cell renderer.  For example, a function might get an
-- integer from the /@treeModel@/, and render it to the “text” attribute of
-- “cell” by converting it to its written equivalent.  This is set by
-- calling 'GI.Gtk.Objects.TreeViewColumn.treeViewColumnSetCellDataFunc'
type TreeCellDataFunc =
    Gtk.TreeViewColumn.TreeViewColumn
    -- ^ /@treeColumn@/: A t'GI.Gtk.Objects.TreeViewColumn.TreeViewColumn'
    -> Gtk.CellRenderer.CellRenderer
    -- ^ /@cell@/: The t'GI.Gtk.Objects.CellRenderer.CellRenderer' that is being rendered by /@treeColumn@/
    -> Gtk.TreeModel.TreeModel
    -- ^ /@treeModel@/: The t'GI.Gtk.Interfaces.TreeModel.TreeModel' being rendered
    -> Gtk.TreeIter.TreeIter
    -- ^ /@iter@/: A t'GI.Gtk.Structs.TreeIter.TreeIter' of the current row rendered
    -> IO ()

-- | A convenience synonym for @`Nothing` :: `Maybe` `TreeCellDataFunc`@.
noTreeCellDataFunc :: Maybe TreeCellDataFunc
noTreeCellDataFunc = Nothing

-- | A function to set the properties of a cell instead of just using the
-- straight mapping between the cell and the model.  This is useful for
-- customizing the cell renderer.  For example, a function might get an
-- integer from the /@treeModel@/, and render it to the “text” attribute of
-- “cell” by converting it to its written equivalent.  This is set by
-- calling 'GI.Gtk.Objects.TreeViewColumn.treeViewColumnSetCellDataFunc'
type TreeCellDataFunc_WithClosures =
    Gtk.TreeViewColumn.TreeViewColumn
    -- ^ /@treeColumn@/: A t'GI.Gtk.Objects.TreeViewColumn.TreeViewColumn'
    -> Gtk.CellRenderer.CellRenderer
    -- ^ /@cell@/: The t'GI.Gtk.Objects.CellRenderer.CellRenderer' that is being rendered by /@treeColumn@/
    -> Gtk.TreeModel.TreeModel
    -- ^ /@treeModel@/: The t'GI.Gtk.Interfaces.TreeModel.TreeModel' being rendered
    -> Gtk.TreeIter.TreeIter
    -- ^ /@iter@/: A t'GI.Gtk.Structs.TreeIter.TreeIter' of the current row rendered
    -> Ptr ()
    -- ^ /@data@/: user data
    -> IO ()

-- | A convenience synonym for @`Nothing` :: `Maybe` `TreeCellDataFunc_WithClosures`@.
noTreeCellDataFunc_WithClosures :: Maybe TreeCellDataFunc_WithClosures
noTreeCellDataFunc_WithClosures = Nothing

-- | A simple wrapper that ignores the closure arguments.
drop_closures_TreeCellDataFunc :: TreeCellDataFunc -> TreeCellDataFunc_WithClosures
drop_closures_TreeCellDataFunc _f treeColumn cell treeModel iter _ = _f treeColumn cell treeModel iter

-- | Wrap the callback into a `GClosure`.
genClosure_TreeCellDataFunc :: MonadIO m => TreeCellDataFunc -> m (GClosure C_TreeCellDataFunc)
genClosure_TreeCellDataFunc cb = liftIO $ do
    let cb' = drop_closures_TreeCellDataFunc cb
    let cb'' = wrap_TreeCellDataFunc Nothing cb'
    mk_TreeCellDataFunc cb'' >>= B.GClosure.newGClosure


-- | Wrap a `TreeCellDataFunc` into a `C_TreeCellDataFunc`.
wrap_TreeCellDataFunc :: 
    Maybe (Ptr (FunPtr C_TreeCellDataFunc)) ->
    TreeCellDataFunc_WithClosures ->
    C_TreeCellDataFunc
wrap_TreeCellDataFunc gi'funptrptr gi'cb treeColumn cell treeModel iter data_ = do
    treeColumn' <- (newObject Gtk.TreeViewColumn.TreeViewColumn) treeColumn
    cell' <- (newObject Gtk.CellRenderer.CellRenderer) cell
    treeModel' <- (newObject Gtk.TreeModel.TreeModel) treeModel
    B.ManagedPtr.withTransient  iter $ \iter' -> do
        gi'cb  treeColumn' cell' treeModel' iter' data_
        maybeReleaseFunPtr gi'funptrptr


-- callback TranslateFunc
{- Callable
  { returnType = Just (TBasicType TUTF8)
  , returnMayBeNull = False
  , returnTransfer = TransferEverything
  , returnDocumentation =
      Documentation
        { rawDocText = Just "the translated message"
        , sinceVersion = Nothing
        }
  , args =
      [ Arg
          { argCName = "path"
          , argType = TBasicType TUTF8
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText =
                    Just
                      "The id of the message. In #GtkActionGroup this will be a label\n  or tooltip from a #GtkActionEntry."
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "func_data"
          , argType = TBasicType TPtr
          , direction = DirectionIn
          , mayBeNull = True
          , argDoc =
              Documentation
                { rawDocText =
                    Just "user data passed in when registering the\n  function"
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = 1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated =
      Just
        DeprecationInfo
          { deprecatedSinceVersion = Just "3.10"
          , deprecationMessage = Nothing
          }
  , callableDocumentation =
      Documentation
        { rawDocText =
            Just
              "The function used to translate messages in e.g. #GtkIconFactory\nand #GtkActionGroup."
        , sinceVersion = Nothing
        }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_TranslateFunc =
    CString ->
    Ptr () ->
    IO CString

-- Args: [ Arg
--           { argCName = "path"
--           , argType = TBasicType TUTF8
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText =
--                     Just
--                       "The id of the message. In #GtkActionGroup this will be a label\n  or tooltip from a #GtkActionEntry."
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "func_data"
--           , argType = TBasicType TPtr
--           , direction = DirectionIn
--           , mayBeNull = True
--           , argDoc =
--               Documentation
--                 { rawDocText =
--                     Just "user data passed in when registering the\n  function"
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = 1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Just (TBasicType TUTF8)
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_TranslateFunc :: FunPtr C_TranslateFunc -> C_TranslateFunc

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_TranslateFunc ::
    (B.CallStack.HasCallStack, MonadIO m) =>
    FunPtr C_TranslateFunc
    -> T.Text
    -- ^ /@path@/: The id of the message. In t'GI.Gtk.Objects.ActionGroup.ActionGroup' this will be a label
    --   or tooltip from a t'GI.Gtk.Structs.ActionEntry.ActionEntry'.
    -> Ptr ()
    -- ^ /@funcData@/: user data passed in when registering the
    --   function
    -> m T.Text
    -- ^ __Returns:__ the translated message
dynamic_TranslateFunc __funPtr path funcData = liftIO $ do
    path' <- textToCString path
    result <- (__dynamic_C_TranslateFunc __funPtr) path' funcData
    checkUnexpectedReturnNULL "translateFunc" result
    result' <- cstringToText result
    freeMem result
    freeMem path'
    return result'

-- | Generate a function pointer callable from C code, from a `C_TranslateFunc`.
foreign import ccall "wrapper"
    mk_TranslateFunc :: C_TranslateFunc -> IO (FunPtr C_TranslateFunc)

{-# DEPRECATED TranslateFunc ["(Since version 3.10)"] #-}
-- | The function used to translate messages in e.g. t'GI.Gtk.Objects.IconFactory.IconFactory'
-- and t'GI.Gtk.Objects.ActionGroup.ActionGroup'.
type TranslateFunc =
    T.Text
    -- ^ /@path@/: The id of the message. In t'GI.Gtk.Objects.ActionGroup.ActionGroup' this will be a label
    --   or tooltip from a t'GI.Gtk.Structs.ActionEntry.ActionEntry'.
    -> IO T.Text
    -- ^ __Returns:__ the translated message

-- | A convenience synonym for @`Nothing` :: `Maybe` `TranslateFunc`@.
noTranslateFunc :: Maybe TranslateFunc
noTranslateFunc = Nothing

-- | The function used to translate messages in e.g. t'GI.Gtk.Objects.IconFactory.IconFactory'
-- and t'GI.Gtk.Objects.ActionGroup.ActionGroup'.
type TranslateFunc_WithClosures =
    T.Text
    -- ^ /@path@/: The id of the message. In t'GI.Gtk.Objects.ActionGroup.ActionGroup' this will be a label
    --   or tooltip from a t'GI.Gtk.Structs.ActionEntry.ActionEntry'.
    -> Ptr ()
    -- ^ /@funcData@/: user data passed in when registering the
    --   function
    -> IO T.Text
    -- ^ __Returns:__ the translated message

-- | A convenience synonym for @`Nothing` :: `Maybe` `TranslateFunc_WithClosures`@.
noTranslateFunc_WithClosures :: Maybe TranslateFunc_WithClosures
noTranslateFunc_WithClosures = Nothing

-- | A simple wrapper that ignores the closure arguments.
drop_closures_TranslateFunc :: TranslateFunc -> TranslateFunc_WithClosures
drop_closures_TranslateFunc _f path _ = _f path

-- | Wrap the callback into a `GClosure`.
genClosure_TranslateFunc :: MonadIO m => TranslateFunc -> m (GClosure C_TranslateFunc)
genClosure_TranslateFunc cb = liftIO $ do
    let cb' = drop_closures_TranslateFunc cb
    let cb'' = wrap_TranslateFunc Nothing cb'
    mk_TranslateFunc cb'' >>= B.GClosure.newGClosure


-- | Wrap a `TranslateFunc` into a `C_TranslateFunc`.
wrap_TranslateFunc :: 
    Maybe (Ptr (FunPtr C_TranslateFunc)) ->
    TranslateFunc_WithClosures ->
    C_TranslateFunc
wrap_TranslateFunc gi'funptrptr gi'cb path funcData = do
    path' <- cstringToText path
    result <- gi'cb  path' funcData
    maybeReleaseFunPtr gi'funptrptr
    result' <- textToCString result
    return result'


-- callback TickCallback
{- Callable
  { returnType = Just (TBasicType TBoolean)
  , returnMayBeNull = False
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation
        { rawDocText =
            Just
              "%G_SOURCE_CONTINUE if the tick callback should continue to be called,\n %G_SOURCE_REMOVE if the tick callback should be removed."
        , sinceVersion = Nothing
        }
  , args =
      [ Arg
          { argCName = "widget"
          , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText = Just "the widget" , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "frame_clock"
          , argType =
              TInterface Name { namespace = "Gdk" , name = "FrameClock" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText =
                    Just
                      "the frame clock for the widget (same as calling gtk_widget_get_frame_clock())"
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "user_data"
          , argType = TBasicType TPtr
          , direction = DirectionIn
          , mayBeNull = True
          , argDoc =
              Documentation
                { rawDocText =
                    Just "user data passed to gtk_widget_add_tick_callback()."
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = 2
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation
        { rawDocText =
            Just
              "Callback type for adding a function to update animations. See gtk_widget_add_tick_callback()."
        , sinceVersion = Just "3.8"
        }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_TickCallback =
    Ptr Gtk.Widget.Widget ->
    Ptr Gdk.FrameClock.FrameClock ->
    Ptr () ->
    IO CInt

-- Args: [ Arg
--           { argCName = "widget"
--           , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "the widget" , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "frame_clock"
--           , argType =
--               TInterface Name { namespace = "Gdk" , name = "FrameClock" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText =
--                     Just
--                       "the frame clock for the widget (same as calling gtk_widget_get_frame_clock())"
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "user_data"
--           , argType = TBasicType TPtr
--           , direction = DirectionIn
--           , mayBeNull = True
--           , argDoc =
--               Documentation
--                 { rawDocText =
--                     Just "user data passed to gtk_widget_add_tick_callback()."
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = 2
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Just (TBasicType TBoolean)
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_TickCallback :: FunPtr C_TickCallback -> C_TickCallback

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_TickCallback ::
    (B.CallStack.HasCallStack, MonadIO m, Gtk.Widget.IsWidget a, Gdk.FrameClock.IsFrameClock b) =>
    FunPtr C_TickCallback
    -> a
    -- ^ /@widget@/: the widget
    -> b
    -- ^ /@frameClock@/: the frame clock for the widget (same as calling 'GI.Gtk.Objects.Widget.widgetGetFrameClock')
    -> Ptr ()
    -- ^ /@userData@/: user data passed to 'GI.Gtk.Objects.Widget.widgetAddTickCallback'.
    -> m Bool
    -- ^ __Returns:__ 'GI.GLib.Constants.SOURCE_CONTINUE' if the tick callback should continue to be called,
    --  'GI.GLib.Constants.SOURCE_REMOVE' if the tick callback should be removed.
dynamic_TickCallback __funPtr widget frameClock userData = liftIO $ do
    widget' <- unsafeManagedPtrCastPtr widget
    frameClock' <- unsafeManagedPtrCastPtr frameClock
    result <- (__dynamic_C_TickCallback __funPtr) widget' frameClock' userData
    let result' = (/= 0) result
    touchManagedPtr widget
    touchManagedPtr frameClock
    return result'

-- | Generate a function pointer callable from C code, from a `C_TickCallback`.
foreign import ccall "wrapper"
    mk_TickCallback :: C_TickCallback -> IO (FunPtr C_TickCallback)

-- | Callback type for adding a function to update animations. See 'GI.Gtk.Objects.Widget.widgetAddTickCallback'.
-- 
-- /Since: 3.8/
type TickCallback =
    Gtk.Widget.Widget
    -- ^ /@widget@/: the widget
    -> Gdk.FrameClock.FrameClock
    -- ^ /@frameClock@/: the frame clock for the widget (same as calling 'GI.Gtk.Objects.Widget.widgetGetFrameClock')
    -> IO Bool
    -- ^ __Returns:__ 'GI.GLib.Constants.SOURCE_CONTINUE' if the tick callback should continue to be called,
    --  'GI.GLib.Constants.SOURCE_REMOVE' if the tick callback should be removed.

-- | A convenience synonym for @`Nothing` :: `Maybe` `TickCallback`@.
noTickCallback :: Maybe TickCallback
noTickCallback = Nothing

-- | Callback type for adding a function to update animations. See 'GI.Gtk.Objects.Widget.widgetAddTickCallback'.
-- 
-- /Since: 3.8/
type TickCallback_WithClosures =
    Gtk.Widget.Widget
    -- ^ /@widget@/: the widget
    -> Gdk.FrameClock.FrameClock
    -- ^ /@frameClock@/: the frame clock for the widget (same as calling 'GI.Gtk.Objects.Widget.widgetGetFrameClock')
    -> Ptr ()
    -- ^ /@userData@/: user data passed to 'GI.Gtk.Objects.Widget.widgetAddTickCallback'.
    -> IO Bool
    -- ^ __Returns:__ 'GI.GLib.Constants.SOURCE_CONTINUE' if the tick callback should continue to be called,
    --  'GI.GLib.Constants.SOURCE_REMOVE' if the tick callback should be removed.

-- | A convenience synonym for @`Nothing` :: `Maybe` `TickCallback_WithClosures`@.
noTickCallback_WithClosures :: Maybe TickCallback_WithClosures
noTickCallback_WithClosures = Nothing

-- | A simple wrapper that ignores the closure arguments.
drop_closures_TickCallback :: TickCallback -> TickCallback_WithClosures
drop_closures_TickCallback _f widget frameClock _ = _f widget frameClock

-- | Wrap the callback into a `GClosure`.
genClosure_TickCallback :: MonadIO m => TickCallback -> m (GClosure C_TickCallback)
genClosure_TickCallback cb = liftIO $ do
    let cb' = drop_closures_TickCallback cb
    let cb'' = wrap_TickCallback Nothing cb'
    mk_TickCallback cb'' >>= B.GClosure.newGClosure


-- | Wrap a `TickCallback` into a `C_TickCallback`.
wrap_TickCallback :: 
    Maybe (Ptr (FunPtr C_TickCallback)) ->
    TickCallback_WithClosures ->
    C_TickCallback
wrap_TickCallback gi'funptrptr gi'cb widget frameClock userData = do
    widget' <- (newObject Gtk.Widget.Widget) widget
    frameClock' <- (newObject Gdk.FrameClock.FrameClock) frameClock
    result <- gi'cb  widget' frameClock' userData
    maybeReleaseFunPtr gi'funptrptr
    let result' = (fromIntegral . fromEnum) result
    return result'


-- callback TextTagTableForeach
{- Callable
  { returnType = Nothing
  , returnMayBeNull = False
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , args =
      [ Arg
          { argCName = "tag"
          , argType =
              TInterface Name { namespace = "Gtk" , name = "TextTag" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText = Just "the #GtkTextTag" , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "data"
          , argType = TBasicType TPtr
          , direction = DirectionIn
          , mayBeNull = True
          , argDoc =
              Documentation
                { rawDocText = Just "data passed to gtk_text_tag_table_foreach()"
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = 1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_TextTagTableForeach =
    Ptr Gtk.TextTag.TextTag ->
    Ptr () ->
    IO ()

-- Args: [ Arg
--           { argCName = "tag"
--           , argType =
--               TInterface Name { namespace = "Gtk" , name = "TextTag" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "the #GtkTextTag" , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "data"
--           , argType = TBasicType TPtr
--           , direction = DirectionIn
--           , mayBeNull = True
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "data passed to gtk_text_tag_table_foreach()"
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = 1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Nothing
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_TextTagTableForeach :: FunPtr C_TextTagTableForeach -> C_TextTagTableForeach

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_TextTagTableForeach ::
    (B.CallStack.HasCallStack, MonadIO m, Gtk.TextTag.IsTextTag a) =>
    FunPtr C_TextTagTableForeach
    -> a
    -- ^ /@tag@/: the t'GI.Gtk.Objects.TextTag.TextTag'
    -> Ptr ()
    -- ^ /@data@/: data passed to 'GI.Gtk.Objects.TextTagTable.textTagTableForeach'
    -> m ()
dynamic_TextTagTableForeach __funPtr tag data_ = liftIO $ do
    tag' <- unsafeManagedPtrCastPtr tag
    (__dynamic_C_TextTagTableForeach __funPtr) tag' data_
    touchManagedPtr tag
    return ()

-- | Generate a function pointer callable from C code, from a `C_TextTagTableForeach`.
foreign import ccall "wrapper"
    mk_TextTagTableForeach :: C_TextTagTableForeach -> IO (FunPtr C_TextTagTableForeach)

-- | /No description available in the introspection data./
type TextTagTableForeach =
    Gtk.TextTag.TextTag
    -- ^ /@tag@/: the t'GI.Gtk.Objects.TextTag.TextTag'
    -> IO ()

-- | A convenience synonym for @`Nothing` :: `Maybe` `TextTagTableForeach`@.
noTextTagTableForeach :: Maybe TextTagTableForeach
noTextTagTableForeach = Nothing

-- | /No description available in the introspection data./
type TextTagTableForeach_WithClosures =
    Gtk.TextTag.TextTag
    -- ^ /@tag@/: the t'GI.Gtk.Objects.TextTag.TextTag'
    -> Ptr ()
    -- ^ /@data@/: data passed to 'GI.Gtk.Objects.TextTagTable.textTagTableForeach'
    -> IO ()

-- | A convenience synonym for @`Nothing` :: `Maybe` `TextTagTableForeach_WithClosures`@.
noTextTagTableForeach_WithClosures :: Maybe TextTagTableForeach_WithClosures
noTextTagTableForeach_WithClosures = Nothing

-- | A simple wrapper that ignores the closure arguments.
drop_closures_TextTagTableForeach :: TextTagTableForeach -> TextTagTableForeach_WithClosures
drop_closures_TextTagTableForeach _f tag _ = _f tag

-- | Wrap the callback into a `GClosure`.
genClosure_TextTagTableForeach :: MonadIO m => TextTagTableForeach -> m (GClosure C_TextTagTableForeach)
genClosure_TextTagTableForeach cb = liftIO $ do
    let cb' = drop_closures_TextTagTableForeach cb
    let cb'' = wrap_TextTagTableForeach Nothing cb'
    mk_TextTagTableForeach cb'' >>= B.GClosure.newGClosure


-- | Wrap a `TextTagTableForeach` into a `C_TextTagTableForeach`.
wrap_TextTagTableForeach :: 
    Maybe (Ptr (FunPtr C_TextTagTableForeach)) ->
    TextTagTableForeach_WithClosures ->
    C_TextTagTableForeach
wrap_TextTagTableForeach gi'funptrptr gi'cb tag data_ = do
    tag' <- (newObject Gtk.TextTag.TextTag) tag
    gi'cb  tag' data_
    maybeReleaseFunPtr gi'funptrptr


-- callback TextCharPredicate
{- Callable
  { returnType = Just (TBasicType TBoolean)
  , returnMayBeNull = False
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , args =
      [ Arg
          { argCName = "ch"
          , argType = TBasicType TUniChar
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "user_data"
          , argType = TBasicType TPtr
          , direction = DirectionIn
          , mayBeNull = True
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = 1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_TextCharPredicate =
    CInt ->
    Ptr () ->
    IO CInt

-- Args: [ Arg
--           { argCName = "ch"
--           , argType = TBasicType TUniChar
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "user_data"
--           , argType = TBasicType TPtr
--           , direction = DirectionIn
--           , mayBeNull = True
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = 1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Just (TBasicType TBoolean)
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_TextCharPredicate :: FunPtr C_TextCharPredicate -> C_TextCharPredicate

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_TextCharPredicate ::
    (B.CallStack.HasCallStack, MonadIO m) =>
    FunPtr C_TextCharPredicate
    -> Char
    -> Ptr ()
    -> m Bool
dynamic_TextCharPredicate __funPtr ch userData = liftIO $ do
    let ch' = (fromIntegral . ord) ch
    result <- (__dynamic_C_TextCharPredicate __funPtr) ch' userData
    let result' = (/= 0) result
    return result'

-- | Generate a function pointer callable from C code, from a `C_TextCharPredicate`.
foreign import ccall "wrapper"
    mk_TextCharPredicate :: C_TextCharPredicate -> IO (FunPtr C_TextCharPredicate)

-- | /No description available in the introspection data./
type TextCharPredicate =
    Char
    -> IO Bool

-- | A convenience synonym for @`Nothing` :: `Maybe` `TextCharPredicate`@.
noTextCharPredicate :: Maybe TextCharPredicate
noTextCharPredicate = Nothing

-- | /No description available in the introspection data./
type TextCharPredicate_WithClosures =
    Char
    -> Ptr ()
    -> IO Bool

-- | A convenience synonym for @`Nothing` :: `Maybe` `TextCharPredicate_WithClosures`@.
noTextCharPredicate_WithClosures :: Maybe TextCharPredicate_WithClosures
noTextCharPredicate_WithClosures = Nothing

-- | A simple wrapper that ignores the closure arguments.
drop_closures_TextCharPredicate :: TextCharPredicate -> TextCharPredicate_WithClosures
drop_closures_TextCharPredicate _f ch _ = _f ch

-- | Wrap the callback into a `GClosure`.
genClosure_TextCharPredicate :: MonadIO m => TextCharPredicate -> m (GClosure C_TextCharPredicate)
genClosure_TextCharPredicate cb = liftIO $ do
    let cb' = drop_closures_TextCharPredicate cb
    let cb'' = wrap_TextCharPredicate Nothing cb'
    mk_TextCharPredicate cb'' >>= B.GClosure.newGClosure


-- | Wrap a `TextCharPredicate` into a `C_TextCharPredicate`.
wrap_TextCharPredicate :: 
    Maybe (Ptr (FunPtr C_TextCharPredicate)) ->
    TextCharPredicate_WithClosures ->
    C_TextCharPredicate
wrap_TextCharPredicate gi'funptrptr gi'cb ch userData = do
    let ch' = (chr . fromIntegral) ch
    result <- gi'cb  ch' userData
    maybeReleaseFunPtr gi'funptrptr
    let result' = (fromIntegral . fromEnum) result
    return result'


-- callback TextBufferSerializeFunc
{- Callable
  { returnType = Just (TCArray False (-1) 4 (TBasicType TUInt8))
  , returnMayBeNull = True
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation
        { rawDocText =
            Just
              "a newly-allocated array of guint8\nwhich contains the serialized data, or %NULL if an error occurred"
        , sinceVersion = Nothing
        }
  , args =
      [ Arg
          { argCName = "register_buffer"
          , argType =
              TInterface Name { namespace = "Gtk" , name = "TextBuffer" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText =
                    Just "the #GtkTextBuffer for which the format is registered"
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "content_buffer"
          , argType =
              TInterface Name { namespace = "Gtk" , name = "TextBuffer" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText = Just "the #GtkTextBuffer to serialize"
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "start"
          , argType =
              TInterface Name { namespace = "Gtk" , name = "TextIter" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText = Just "start of the block of text to serialize"
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "end"
          , argType =
              TInterface Name { namespace = "Gtk" , name = "TextIter" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText = Just "end of the block of text to serialize"
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "length"
          , argType = TBasicType TUInt64
          , direction = DirectionOut
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText =
                    Just "return location for the length of the serialized data"
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferEverything
          }
      , Arg
          { argCName = "user_data"
          , argType = TBasicType TPtr
          , direction = DirectionIn
          , mayBeNull = True
          , argDoc =
              Documentation
                { rawDocText =
                    Just "user data that was specified when registering the format"
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = 5
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation
        { rawDocText =
            Just
              "A function that is called to serialize the content of a text buffer.\nIt must return the serialized form of the content."
        , sinceVersion = Nothing
        }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_TextBufferSerializeFunc =
    Ptr Gtk.TextBuffer.TextBuffer ->
    Ptr Gtk.TextBuffer.TextBuffer ->
    Ptr Gtk.TextIter.TextIter ->
    Ptr Gtk.TextIter.TextIter ->
    Ptr Word64 ->
    Ptr () ->
    IO (Ptr Word8)

-- Args: [ Arg
--           { argCName = "register_buffer"
--           , argType =
--               TInterface Name { namespace = "Gtk" , name = "TextBuffer" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText =
--                     Just "the #GtkTextBuffer for which the format is registered"
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "content_buffer"
--           , argType =
--               TInterface Name { namespace = "Gtk" , name = "TextBuffer" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "the #GtkTextBuffer to serialize"
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "start"
--           , argType =
--               TInterface Name { namespace = "Gtk" , name = "TextIter" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "start of the block of text to serialize"
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "end"
--           , argType =
--               TInterface Name { namespace = "Gtk" , name = "TextIter" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "end of the block of text to serialize"
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "length"
--           , argType = TBasicType TUInt64
--           , direction = DirectionOut
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText =
--                     Just "return location for the length of the serialized data"
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferEverything
--           }
--       , Arg
--           { argCName = "user_data"
--           , argType = TBasicType TPtr
--           , direction = DirectionIn
--           , mayBeNull = True
--           , argDoc =
--               Documentation
--                 { rawDocText =
--                     Just "user data that was specified when registering the format"
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = 5
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: [ Arg
--              { argCName = "length"
--              , argType = TBasicType TUInt64
--              , direction = DirectionOut
--              , mayBeNull = False
--              , argDoc =
--                  Documentation
--                    { rawDocText =
--                        Just "return location for the length of the serialized data"
--                    , sinceVersion = Nothing
--                    }
--              , argScope = ScopeTypeInvalid
--              , argClosure = -1
--              , argDestroy = -1
--              , argCallerAllocates = False
--              , transfer = TransferEverything
--              }
--          ]
-- returnType: Just (TCArray False (-1) 4 (TBasicType TUInt8))
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_TextBufferSerializeFunc :: FunPtr C_TextBufferSerializeFunc -> C_TextBufferSerializeFunc

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_TextBufferSerializeFunc ::
    (B.CallStack.HasCallStack, MonadIO m, Gtk.TextBuffer.IsTextBuffer a, Gtk.TextBuffer.IsTextBuffer b) =>
    FunPtr C_TextBufferSerializeFunc
    -> a
    -- ^ /@registerBuffer@/: the t'GI.Gtk.Objects.TextBuffer.TextBuffer' for which the format is registered
    -> b
    -- ^ /@contentBuffer@/: the t'GI.Gtk.Objects.TextBuffer.TextBuffer' to serialize
    -> Gtk.TextIter.TextIter
    -- ^ /@start@/: start of the block of text to serialize
    -> Gtk.TextIter.TextIter
    -- ^ /@end@/: end of the block of text to serialize
    -> Ptr ()
    -- ^ /@userData@/: user data that was specified when registering the format
    -> m (Maybe ByteString)
    -- ^ __Returns:__ a newly-allocated array of guint8
    -- which contains the serialized data, or 'P.Nothing' if an error occurred
dynamic_TextBufferSerializeFunc __funPtr registerBuffer contentBuffer start end userData = liftIO $ do
    registerBuffer' <- unsafeManagedPtrCastPtr registerBuffer
    contentBuffer' <- unsafeManagedPtrCastPtr contentBuffer
    start' <- unsafeManagedPtrGetPtr start
    end' <- unsafeManagedPtrGetPtr end
    length_ <- allocMem :: IO (Ptr Word64)
    result <- (__dynamic_C_TextBufferSerializeFunc __funPtr) registerBuffer' contentBuffer' start' end' length_ userData
    length_' <- peek length_
    maybeResult <- convertIfNonNull result $ \result' -> do
        result'' <- (unpackByteStringWithLength length_') result'
        return result''
    touchManagedPtr registerBuffer
    touchManagedPtr contentBuffer
    touchManagedPtr start
    touchManagedPtr end
    freeMem length_
    return maybeResult

-- | Generate a function pointer callable from C code, from a `C_TextBufferSerializeFunc`.
foreign import ccall "wrapper"
    mk_TextBufferSerializeFunc :: C_TextBufferSerializeFunc -> IO (FunPtr C_TextBufferSerializeFunc)

-- | A function that is called to serialize the content of a text buffer.
-- It must return the serialized form of the content.
type TextBufferSerializeFunc =
    Gtk.TextBuffer.TextBuffer
    -- ^ /@registerBuffer@/: the t'GI.Gtk.Objects.TextBuffer.TextBuffer' for which the format is registered
    -> Gtk.TextBuffer.TextBuffer
    -- ^ /@contentBuffer@/: the t'GI.Gtk.Objects.TextBuffer.TextBuffer' to serialize
    -> Gtk.TextIter.TextIter
    -- ^ /@start@/: start of the block of text to serialize
    -> Gtk.TextIter.TextIter
    -- ^ /@end@/: end of the block of text to serialize
    -> IO (Maybe ByteString)
    -- ^ __Returns:__ a newly-allocated array of guint8
    -- which contains the serialized data, or 'P.Nothing' if an error occurred

-- | A convenience synonym for @`Nothing` :: `Maybe` `TextBufferSerializeFunc`@.
noTextBufferSerializeFunc :: Maybe TextBufferSerializeFunc
noTextBufferSerializeFunc = Nothing

-- | A function that is called to serialize the content of a text buffer.
-- It must return the serialized form of the content.
type TextBufferSerializeFunc_WithClosures =
    Gtk.TextBuffer.TextBuffer
    -- ^ /@registerBuffer@/: the t'GI.Gtk.Objects.TextBuffer.TextBuffer' for which the format is registered
    -> Gtk.TextBuffer.TextBuffer
    -- ^ /@contentBuffer@/: the t'GI.Gtk.Objects.TextBuffer.TextBuffer' to serialize
    -> Gtk.TextIter.TextIter
    -- ^ /@start@/: start of the block of text to serialize
    -> Gtk.TextIter.TextIter
    -- ^ /@end@/: end of the block of text to serialize
    -> Ptr ()
    -- ^ /@userData@/: user data that was specified when registering the format
    -> IO (Maybe ByteString)
    -- ^ __Returns:__ a newly-allocated array of guint8
    -- which contains the serialized data, or 'P.Nothing' if an error occurred

-- | A convenience synonym for @`Nothing` :: `Maybe` `TextBufferSerializeFunc_WithClosures`@.
noTextBufferSerializeFunc_WithClosures :: Maybe TextBufferSerializeFunc_WithClosures
noTextBufferSerializeFunc_WithClosures = Nothing

-- | A simple wrapper that ignores the closure arguments.
drop_closures_TextBufferSerializeFunc :: TextBufferSerializeFunc -> TextBufferSerializeFunc_WithClosures
drop_closures_TextBufferSerializeFunc _f registerBuffer contentBuffer start end _ = _f registerBuffer contentBuffer start end

-- | Wrap the callback into a `GClosure`.
genClosure_TextBufferSerializeFunc :: MonadIO m => TextBufferSerializeFunc -> m (GClosure C_TextBufferSerializeFunc)
genClosure_TextBufferSerializeFunc cb = liftIO $ do
    let cb' = drop_closures_TextBufferSerializeFunc cb
    let cb'' = wrap_TextBufferSerializeFunc Nothing cb'
    mk_TextBufferSerializeFunc cb'' >>= B.GClosure.newGClosure


-- | Wrap a `TextBufferSerializeFunc` into a `C_TextBufferSerializeFunc`.
wrap_TextBufferSerializeFunc :: 
    Maybe (Ptr (FunPtr C_TextBufferSerializeFunc)) ->
    TextBufferSerializeFunc_WithClosures ->
    C_TextBufferSerializeFunc
wrap_TextBufferSerializeFunc gi'funptrptr gi'cb registerBuffer contentBuffer start end length_ userData = do
    registerBuffer' <- (newObject Gtk.TextBuffer.TextBuffer) registerBuffer
    contentBuffer' <- (newObject Gtk.TextBuffer.TextBuffer) contentBuffer
    B.ManagedPtr.withTransient  start $ \start' -> do
        B.ManagedPtr.withTransient  end $ \end' -> do
            result <- gi'cb  registerBuffer' contentBuffer' start' end' userData
            maybeReleaseFunPtr gi'funptrptr
            maybeM FP.nullPtr result $ \result' -> do
                result'' <- packByteString result'
                return result''


-- callback TextBufferDeserializeFunc
{- Callable
  { returnType = Just (TBasicType TBoolean)
  , returnMayBeNull = False
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation
        { rawDocText = Just "%TRUE on success, %FALSE otherwise"
        , sinceVersion = Nothing
        }
  , args =
      [ Arg
          { argCName = "register_buffer"
          , argType =
              TInterface Name { namespace = "Gtk" , name = "TextBuffer" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText =
                    Just "the #GtkTextBuffer the format is registered with"
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "content_buffer"
          , argType =
              TInterface Name { namespace = "Gtk" , name = "TextBuffer" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText = Just "the #GtkTextBuffer to deserialize into"
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "iter"
          , argType =
              TInterface Name { namespace = "Gtk" , name = "TextIter" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText = Just "insertion point for the deserialized text"
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "data"
          , argType = TCArray False (-1) 4 (TBasicType TUInt8)
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText = Just "data to deserialize"
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "length"
          , argType = TBasicType TUInt64
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText = Just "length of @data" , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "create_tags"
          , argType = TBasicType TBoolean
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText = Just "%TRUE if deserializing may create tags"
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "user_data"
          , argType = TBasicType TPtr
          , direction = DirectionIn
          , mayBeNull = True
          , argDoc =
              Documentation
                { rawDocText =
                    Just "user data that was specified when registering the format"
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = 6
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = True
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation
        { rawDocText =
            Just
              "A function that is called to deserialize rich text that has been\nserialized with gtk_text_buffer_serialize(), and insert it at @iter."
        , sinceVersion = Nothing
        }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_TextBufferDeserializeFunc =
    Ptr Gtk.TextBuffer.TextBuffer ->
    Ptr Gtk.TextBuffer.TextBuffer ->
    Ptr Gtk.TextIter.TextIter ->
    Ptr Word8 ->
    Word64 ->
    CInt ->
    Ptr () ->
    Ptr (Ptr GError) ->
    IO CInt

-- Args: [ Arg
--           { argCName = "register_buffer"
--           , argType =
--               TInterface Name { namespace = "Gtk" , name = "TextBuffer" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText =
--                     Just "the #GtkTextBuffer the format is registered with"
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "content_buffer"
--           , argType =
--               TInterface Name { namespace = "Gtk" , name = "TextBuffer" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "the #GtkTextBuffer to deserialize into"
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "iter"
--           , argType =
--               TInterface Name { namespace = "Gtk" , name = "TextIter" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "insertion point for the deserialized text"
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "data"
--           , argType = TCArray False (-1) 4 (TBasicType TUInt8)
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "data to deserialize"
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "length"
--           , argType = TBasicType TUInt64
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "length of @data" , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "create_tags"
--           , argType = TBasicType TBoolean
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "%TRUE if deserializing may create tags"
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "user_data"
--           , argType = TBasicType TPtr
--           , direction = DirectionIn
--           , mayBeNull = True
--           , argDoc =
--               Documentation
--                 { rawDocText =
--                     Just "user data that was specified when registering the format"
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = 6
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: [ Arg
--              { argCName = "length"
--              , argType = TBasicType TUInt64
--              , direction = DirectionIn
--              , mayBeNull = False
--              , argDoc =
--                  Documentation
--                    { rawDocText = Just "length of @data" , sinceVersion = Nothing }
--              , argScope = ScopeTypeInvalid
--              , argClosure = -1
--              , argDestroy = -1
--              , argCallerAllocates = False
--              , transfer = TransferNothing
--              }
--          ]
-- returnType: Just (TBasicType TBoolean)
-- throws : True
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_TextBufferDeserializeFunc :: FunPtr C_TextBufferDeserializeFunc -> C_TextBufferDeserializeFunc

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_TextBufferDeserializeFunc ::
    (B.CallStack.HasCallStack, MonadIO m, Gtk.TextBuffer.IsTextBuffer a, Gtk.TextBuffer.IsTextBuffer b) =>
    FunPtr C_TextBufferDeserializeFunc
    -> a
    -- ^ /@registerBuffer@/: the t'GI.Gtk.Objects.TextBuffer.TextBuffer' the format is registered with
    -> b
    -- ^ /@contentBuffer@/: the t'GI.Gtk.Objects.TextBuffer.TextBuffer' to deserialize into
    -> Gtk.TextIter.TextIter
    -- ^ /@iter@/: insertion point for the deserialized text
    -> ByteString
    -- ^ /@data@/: data to deserialize
    -> Bool
    -- ^ /@createTags@/: 'P.True' if deserializing may create tags
    -> Ptr ()
    -- ^ /@userData@/: user data that was specified when registering the format
    -> m ()
    -- ^ /(Can throw 'Data.GI.Base.GError.GError')/
dynamic_TextBufferDeserializeFunc __funPtr registerBuffer contentBuffer iter data_ createTags userData = liftIO $ do
    let length_ = fromIntegral $ B.length data_
    registerBuffer' <- unsafeManagedPtrCastPtr registerBuffer
    contentBuffer' <- unsafeManagedPtrCastPtr contentBuffer
    iter' <- unsafeManagedPtrGetPtr iter
    data_' <- packByteString data_
    let createTags' = (fromIntegral . fromEnum) createTags
    onException (do
        _ <- propagateGError $ (__dynamic_C_TextBufferDeserializeFunc __funPtr) registerBuffer' contentBuffer' iter' data_' length_ createTags' userData
        touchManagedPtr registerBuffer
        touchManagedPtr contentBuffer
        touchManagedPtr iter
        freeMem data_'
        return ()
     ) (do
        freeMem data_'
     )

-- | Generate a function pointer callable from C code, from a `C_TextBufferDeserializeFunc`.
foreign import ccall "wrapper"
    mk_TextBufferDeserializeFunc :: C_TextBufferDeserializeFunc -> IO (FunPtr C_TextBufferDeserializeFunc)

-- | A function that is called to deserialize rich text that has been
-- serialized with 'GI.Gtk.Objects.TextBuffer.textBufferSerialize', and insert it at /@iter@/.
type TextBufferDeserializeFunc =
    Gtk.TextBuffer.TextBuffer
    -- ^ /@registerBuffer@/: the t'GI.Gtk.Objects.TextBuffer.TextBuffer' the format is registered with
    -> Gtk.TextBuffer.TextBuffer
    -- ^ /@contentBuffer@/: the t'GI.Gtk.Objects.TextBuffer.TextBuffer' to deserialize into
    -> Gtk.TextIter.TextIter
    -- ^ /@iter@/: insertion point for the deserialized text
    -> ByteString
    -- ^ /@data@/: data to deserialize
    -> Bool
    -- ^ /@createTags@/: 'P.True' if deserializing may create tags
    -> IO ()
    -- ^ __Returns:__ 'P.True' on success, 'P.False' otherwise /(Can throw 'Data.GI.Base.GError.GError')/

-- | A convenience synonym for @`Nothing` :: `Maybe` `TextBufferDeserializeFunc`@.
noTextBufferDeserializeFunc :: Maybe TextBufferDeserializeFunc
noTextBufferDeserializeFunc = Nothing

-- | A function that is called to deserialize rich text that has been
-- serialized with 'GI.Gtk.Objects.TextBuffer.textBufferSerialize', and insert it at /@iter@/.
type TextBufferDeserializeFunc_WithClosures =
    Gtk.TextBuffer.TextBuffer
    -- ^ /@registerBuffer@/: the t'GI.Gtk.Objects.TextBuffer.TextBuffer' the format is registered with
    -> Gtk.TextBuffer.TextBuffer
    -- ^ /@contentBuffer@/: the t'GI.Gtk.Objects.TextBuffer.TextBuffer' to deserialize into
    -> Gtk.TextIter.TextIter
    -- ^ /@iter@/: insertion point for the deserialized text
    -> ByteString
    -- ^ /@data@/: data to deserialize
    -> Bool
    -- ^ /@createTags@/: 'P.True' if deserializing may create tags
    -> Ptr ()
    -- ^ /@userData@/: user data that was specified when registering the format
    -> IO ()
    -- ^ __Returns:__ 'P.True' on success, 'P.False' otherwise /(Can throw 'Data.GI.Base.GError.GError')/

-- | A convenience synonym for @`Nothing` :: `Maybe` `TextBufferDeserializeFunc_WithClosures`@.
noTextBufferDeserializeFunc_WithClosures :: Maybe TextBufferDeserializeFunc_WithClosures
noTextBufferDeserializeFunc_WithClosures = Nothing

-- | A simple wrapper that ignores the closure arguments.
drop_closures_TextBufferDeserializeFunc :: TextBufferDeserializeFunc -> TextBufferDeserializeFunc_WithClosures
drop_closures_TextBufferDeserializeFunc _f registerBuffer contentBuffer iter data_ createTags _ = _f registerBuffer contentBuffer iter data_ createTags

-- No Haskell->C wrapper generated since the function throws.

-- callback StylePropertyParser
{- Callable
  { returnType = Just (TBasicType TBoolean)
  , returnMayBeNull = False
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , args =
      [ Arg
          { argCName = "string"
          , argType = TBasicType TUTF8
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "value"
          , argType = TGValue
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = True
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_StylePropertyParser =
    CString ->
    Ptr GValue ->
    Ptr (Ptr GError) ->
    IO CInt

-- Args: [ Arg
--           { argCName = "string"
--           , argType = TBasicType TUTF8
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "value"
--           , argType = TGValue
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Just (TBasicType TBoolean)
-- throws : True
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_StylePropertyParser :: FunPtr C_StylePropertyParser -> C_StylePropertyParser

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_StylePropertyParser ::
    (B.CallStack.HasCallStack, MonadIO m) =>
    FunPtr C_StylePropertyParser
    -> T.Text
    -> GValue
    -> m ()
    -- ^ /(Can throw 'Data.GI.Base.GError.GError')/
dynamic_StylePropertyParser __funPtr string value = liftIO $ do
    string' <- textToCString string
    value' <- unsafeManagedPtrGetPtr value
    onException (do
        _ <- propagateGError $ (__dynamic_C_StylePropertyParser __funPtr) string' value'
        touchManagedPtr value
        freeMem string'
        return ()
     ) (do
        freeMem string'
     )

-- | Generate a function pointer callable from C code, from a `C_StylePropertyParser`.
foreign import ccall "wrapper"
    mk_StylePropertyParser :: C_StylePropertyParser -> IO (FunPtr C_StylePropertyParser)

-- | /No description available in the introspection data./
type StylePropertyParser =
    T.Text
    -> GValue
    -> IO ()
    -- ^ /(Can throw 'Data.GI.Base.GError.GError')/

-- | A convenience synonym for @`Nothing` :: `Maybe` `StylePropertyParser`@.
noStylePropertyParser :: Maybe StylePropertyParser
noStylePropertyParser = Nothing

-- No Haskell->C wrapper generated since the function throws.

-- callback RecentSortFunc
{- Callable
  { returnType = Just (TBasicType TInt)
  , returnMayBeNull = False
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , args =
      [ Arg
          { argCName = "a"
          , argType =
              TInterface Name { namespace = "Gtk" , name = "RecentInfo" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "b"
          , argType =
              TInterface Name { namespace = "Gtk" , name = "RecentInfo" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "user_data"
          , argType = TBasicType TPtr
          , direction = DirectionIn
          , mayBeNull = True
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = 2
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_RecentSortFunc =
    Ptr Gtk.RecentInfo.RecentInfo ->
    Ptr Gtk.RecentInfo.RecentInfo ->
    Ptr () ->
    IO Int32

-- Args: [ Arg
--           { argCName = "a"
--           , argType =
--               TInterface Name { namespace = "Gtk" , name = "RecentInfo" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "b"
--           , argType =
--               TInterface Name { namespace = "Gtk" , name = "RecentInfo" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "user_data"
--           , argType = TBasicType TPtr
--           , direction = DirectionIn
--           , mayBeNull = True
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = 2
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Just (TBasicType TInt)
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_RecentSortFunc :: FunPtr C_RecentSortFunc -> C_RecentSortFunc

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_RecentSortFunc ::
    (B.CallStack.HasCallStack, MonadIO m) =>
    FunPtr C_RecentSortFunc
    -> Gtk.RecentInfo.RecentInfo
    -> Gtk.RecentInfo.RecentInfo
    -> Ptr ()
    -> m Int32
dynamic_RecentSortFunc __funPtr a b userData = liftIO $ do
    a' <- unsafeManagedPtrGetPtr a
    b' <- unsafeManagedPtrGetPtr b
    result <- (__dynamic_C_RecentSortFunc __funPtr) a' b' userData
    touchManagedPtr a
    touchManagedPtr b
    return result

-- | Generate a function pointer callable from C code, from a `C_RecentSortFunc`.
foreign import ccall "wrapper"
    mk_RecentSortFunc :: C_RecentSortFunc -> IO (FunPtr C_RecentSortFunc)

-- | /No description available in the introspection data./
type RecentSortFunc =
    Gtk.RecentInfo.RecentInfo
    -> Gtk.RecentInfo.RecentInfo
    -> IO Int32

-- | A convenience synonym for @`Nothing` :: `Maybe` `RecentSortFunc`@.
noRecentSortFunc :: Maybe RecentSortFunc
noRecentSortFunc = Nothing

-- | /No description available in the introspection data./
type RecentSortFunc_WithClosures =
    Gtk.RecentInfo.RecentInfo
    -> Gtk.RecentInfo.RecentInfo
    -> Ptr ()
    -> IO Int32

-- | A convenience synonym for @`Nothing` :: `Maybe` `RecentSortFunc_WithClosures`@.
noRecentSortFunc_WithClosures :: Maybe RecentSortFunc_WithClosures
noRecentSortFunc_WithClosures = Nothing

-- | A simple wrapper that ignores the closure arguments.
drop_closures_RecentSortFunc :: RecentSortFunc -> RecentSortFunc_WithClosures
drop_closures_RecentSortFunc _f a b _ = _f a b

-- | Wrap the callback into a `GClosure`.
genClosure_RecentSortFunc :: MonadIO m => RecentSortFunc -> m (GClosure C_RecentSortFunc)
genClosure_RecentSortFunc cb = liftIO $ do
    let cb' = drop_closures_RecentSortFunc cb
    let cb'' = wrap_RecentSortFunc Nothing cb'
    mk_RecentSortFunc cb'' >>= B.GClosure.newGClosure


-- | Wrap a `RecentSortFunc` into a `C_RecentSortFunc`.
wrap_RecentSortFunc :: 
    Maybe (Ptr (FunPtr C_RecentSortFunc)) ->
    RecentSortFunc_WithClosures ->
    C_RecentSortFunc
wrap_RecentSortFunc gi'funptrptr gi'cb a b userData = do
    B.ManagedPtr.withTransient  a $ \a' -> do
        B.ManagedPtr.withTransient  b $ \b' -> do
            result <- gi'cb  a' b' userData
            maybeReleaseFunPtr gi'funptrptr
            return result


-- callback RecentFilterFunc
{- Callable
  { returnType = Just (TBasicType TBoolean)
  , returnMayBeNull = False
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation
        { rawDocText = Just "%TRUE if the file should be displayed"
        , sinceVersion = Nothing
        }
  , args =
      [ Arg
          { argCName = "filter_info"
          , argType =
              TInterface Name { namespace = "Gtk" , name = "RecentFilterInfo" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText =
                    Just
                      "a #GtkRecentFilterInfo that is filled according\n to the @needed flags passed to gtk_recent_filter_add_custom()"
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "user_data"
          , argType = TBasicType TPtr
          , direction = DirectionIn
          , mayBeNull = True
          , argDoc =
              Documentation
                { rawDocText =
                    Just "user data passed to gtk_recent_filter_add_custom()"
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = 1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation
        { rawDocText =
            Just
              "The type of function that is used with custom filters,\nsee gtk_recent_filter_add_custom()."
        , sinceVersion = Nothing
        }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_RecentFilterFunc =
    Ptr Gtk.RecentFilterInfo.RecentFilterInfo ->
    Ptr () ->
    IO CInt

-- Args: [ Arg
--           { argCName = "filter_info"
--           , argType =
--               TInterface Name { namespace = "Gtk" , name = "RecentFilterInfo" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText =
--                     Just
--                       "a #GtkRecentFilterInfo that is filled according\n to the @needed flags passed to gtk_recent_filter_add_custom()"
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "user_data"
--           , argType = TBasicType TPtr
--           , direction = DirectionIn
--           , mayBeNull = True
--           , argDoc =
--               Documentation
--                 { rawDocText =
--                     Just "user data passed to gtk_recent_filter_add_custom()"
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = 1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Just (TBasicType TBoolean)
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_RecentFilterFunc :: FunPtr C_RecentFilterFunc -> C_RecentFilterFunc

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_RecentFilterFunc ::
    (B.CallStack.HasCallStack, MonadIO m) =>
    FunPtr C_RecentFilterFunc
    -> Gtk.RecentFilterInfo.RecentFilterInfo
    -- ^ /@filterInfo@/: a t'GI.Gtk.Structs.RecentFilterInfo.RecentFilterInfo' that is filled according
    --  to the /@needed@/ flags passed to 'GI.Gtk.Objects.RecentFilter.recentFilterAddCustom'
    -> Ptr ()
    -- ^ /@userData@/: user data passed to 'GI.Gtk.Objects.RecentFilter.recentFilterAddCustom'
    -> m Bool
    -- ^ __Returns:__ 'P.True' if the file should be displayed
dynamic_RecentFilterFunc __funPtr filterInfo userData = liftIO $ do
    filterInfo' <- unsafeManagedPtrGetPtr filterInfo
    result <- (__dynamic_C_RecentFilterFunc __funPtr) filterInfo' userData
    let result' = (/= 0) result
    touchManagedPtr filterInfo
    return result'

-- | Generate a function pointer callable from C code, from a `C_RecentFilterFunc`.
foreign import ccall "wrapper"
    mk_RecentFilterFunc :: C_RecentFilterFunc -> IO (FunPtr C_RecentFilterFunc)

-- | The type of function that is used with custom filters,
-- see 'GI.Gtk.Objects.RecentFilter.recentFilterAddCustom'.
type RecentFilterFunc =
    Gtk.RecentFilterInfo.RecentFilterInfo
    -- ^ /@filterInfo@/: a t'GI.Gtk.Structs.RecentFilterInfo.RecentFilterInfo' that is filled according
    --  to the /@needed@/ flags passed to 'GI.Gtk.Objects.RecentFilter.recentFilterAddCustom'
    -> IO Bool
    -- ^ __Returns:__ 'P.True' if the file should be displayed

-- | A convenience synonym for @`Nothing` :: `Maybe` `RecentFilterFunc`@.
noRecentFilterFunc :: Maybe RecentFilterFunc
noRecentFilterFunc = Nothing

-- | The type of function that is used with custom filters,
-- see 'GI.Gtk.Objects.RecentFilter.recentFilterAddCustom'.
type RecentFilterFunc_WithClosures =
    Gtk.RecentFilterInfo.RecentFilterInfo
    -- ^ /@filterInfo@/: a t'GI.Gtk.Structs.RecentFilterInfo.RecentFilterInfo' that is filled according
    --  to the /@needed@/ flags passed to 'GI.Gtk.Objects.RecentFilter.recentFilterAddCustom'
    -> Ptr ()
    -- ^ /@userData@/: user data passed to 'GI.Gtk.Objects.RecentFilter.recentFilterAddCustom'
    -> IO Bool
    -- ^ __Returns:__ 'P.True' if the file should be displayed

-- | A convenience synonym for @`Nothing` :: `Maybe` `RecentFilterFunc_WithClosures`@.
noRecentFilterFunc_WithClosures :: Maybe RecentFilterFunc_WithClosures
noRecentFilterFunc_WithClosures = Nothing

-- | A simple wrapper that ignores the closure arguments.
drop_closures_RecentFilterFunc :: RecentFilterFunc -> RecentFilterFunc_WithClosures
drop_closures_RecentFilterFunc _f filterInfo _ = _f filterInfo

-- | Wrap the callback into a `GClosure`.
genClosure_RecentFilterFunc :: MonadIO m => RecentFilterFunc -> m (GClosure C_RecentFilterFunc)
genClosure_RecentFilterFunc cb = liftIO $ do
    let cb' = drop_closures_RecentFilterFunc cb
    let cb'' = wrap_RecentFilterFunc Nothing cb'
    mk_RecentFilterFunc cb'' >>= B.GClosure.newGClosure


-- | Wrap a `RecentFilterFunc` into a `C_RecentFilterFunc`.
wrap_RecentFilterFunc :: 
    Maybe (Ptr (FunPtr C_RecentFilterFunc)) ->
    RecentFilterFunc_WithClosures ->
    C_RecentFilterFunc
wrap_RecentFilterFunc gi'funptrptr gi'cb filterInfo userData = do
    filterInfo' <- (newPtr Gtk.RecentFilterInfo.RecentFilterInfo) filterInfo
    result <- gi'cb  filterInfo' userData
    maybeReleaseFunPtr gi'funptrptr
    let result' = (fromIntegral . fromEnum) result
    return result'


-- callback RcPropertyParser
{- Callable
  { returnType = Just (TBasicType TBoolean)
  , returnMayBeNull = False
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , args =
      [ Arg
          { argCName = "pspec"
          , argType = TParamSpec
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "rc_string"
          , argType =
              TInterface Name { namespace = "GLib" , name = "String" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "property_value"
          , argType = TGValue
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_RcPropertyParser =
    Ptr GParamSpec ->
    Ptr GLib.String.String ->
    Ptr GValue ->
    IO CInt

-- Args: [ Arg
--           { argCName = "pspec"
--           , argType = TParamSpec
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "rc_string"
--           , argType =
--               TInterface Name { namespace = "GLib" , name = "String" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "property_value"
--           , argType = TGValue
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Just (TBasicType TBoolean)
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_RcPropertyParser :: FunPtr C_RcPropertyParser -> C_RcPropertyParser

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_RcPropertyParser ::
    (B.CallStack.HasCallStack, MonadIO m) =>
    FunPtr C_RcPropertyParser
    -> GParamSpec
    -> GLib.String.String
    -> GValue
    -> m Bool
dynamic_RcPropertyParser __funPtr pspec rcString propertyValue = liftIO $ do
    pspec' <- unsafeManagedPtrGetPtr pspec
    rcString' <- unsafeManagedPtrGetPtr rcString
    propertyValue' <- unsafeManagedPtrGetPtr propertyValue
    result <- (__dynamic_C_RcPropertyParser __funPtr) pspec' rcString' propertyValue'
    let result' = (/= 0) result
    touchManagedPtr pspec
    touchManagedPtr rcString
    touchManagedPtr propertyValue
    return result'

-- | Generate a function pointer callable from C code, from a `C_RcPropertyParser`.
foreign import ccall "wrapper"
    mk_RcPropertyParser :: C_RcPropertyParser -> IO (FunPtr C_RcPropertyParser)

-- | /No description available in the introspection data./
type RcPropertyParser =
    GParamSpec
    -> GLib.String.String
    -> GValue
    -> IO Bool

-- | A convenience synonym for @`Nothing` :: `Maybe` `RcPropertyParser`@.
noRcPropertyParser :: Maybe RcPropertyParser
noRcPropertyParser = Nothing

-- | Wrap the callback into a `GClosure`.
genClosure_RcPropertyParser :: MonadIO m => RcPropertyParser -> m (GClosure C_RcPropertyParser)
genClosure_RcPropertyParser cb = liftIO $ do
    let cb' = wrap_RcPropertyParser Nothing cb
    mk_RcPropertyParser cb' >>= B.GClosure.newGClosure


-- | Wrap a `RcPropertyParser` into a `C_RcPropertyParser`.
wrap_RcPropertyParser :: 
    Maybe (Ptr (FunPtr C_RcPropertyParser)) ->
    RcPropertyParser ->
    C_RcPropertyParser
wrap_RcPropertyParser gi'funptrptr gi'cb pspec rcString propertyValue = do
    pspec' <- B.GParamSpec.newGParamSpecFromPtr pspec
    B.ManagedPtr.withTransient  rcString $ \rcString' -> do
        propertyValue' <- B.GValue.newGValueFromPtr propertyValue
        result <- gi'cb  pspec' rcString' propertyValue'
        maybeReleaseFunPtr gi'funptrptr
        let result' = (fromIntegral . fromEnum) result
        return result'


-- callback PrintSettingsFunc
{- Callable
  { returnType = Nothing
  , returnMayBeNull = False
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , args =
      [ Arg
          { argCName = "key"
          , argType = TBasicType TUTF8
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "value"
          , argType = TBasicType TUTF8
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "user_data"
          , argType = TBasicType TPtr
          , direction = DirectionIn
          , mayBeNull = True
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = 2
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_PrintSettingsFunc =
    CString ->
    CString ->
    Ptr () ->
    IO ()

-- Args: [ Arg
--           { argCName = "key"
--           , argType = TBasicType TUTF8
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "value"
--           , argType = TBasicType TUTF8
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "user_data"
--           , argType = TBasicType TPtr
--           , direction = DirectionIn
--           , mayBeNull = True
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = 2
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Nothing
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_PrintSettingsFunc :: FunPtr C_PrintSettingsFunc -> C_PrintSettingsFunc

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_PrintSettingsFunc ::
    (B.CallStack.HasCallStack, MonadIO m) =>
    FunPtr C_PrintSettingsFunc
    -> T.Text
    -> T.Text
    -> Ptr ()
    -> m ()
dynamic_PrintSettingsFunc __funPtr key value userData = liftIO $ do
    key' <- textToCString key
    value' <- textToCString value
    (__dynamic_C_PrintSettingsFunc __funPtr) key' value' userData
    freeMem key'
    freeMem value'
    return ()

-- | Generate a function pointer callable from C code, from a `C_PrintSettingsFunc`.
foreign import ccall "wrapper"
    mk_PrintSettingsFunc :: C_PrintSettingsFunc -> IO (FunPtr C_PrintSettingsFunc)

-- | /No description available in the introspection data./
type PrintSettingsFunc =
    T.Text
    -> T.Text
    -> IO ()

-- | A convenience synonym for @`Nothing` :: `Maybe` `PrintSettingsFunc`@.
noPrintSettingsFunc :: Maybe PrintSettingsFunc
noPrintSettingsFunc = Nothing

-- | /No description available in the introspection data./
type PrintSettingsFunc_WithClosures =
    T.Text
    -> T.Text
    -> Ptr ()
    -> IO ()

-- | A convenience synonym for @`Nothing` :: `Maybe` `PrintSettingsFunc_WithClosures`@.
noPrintSettingsFunc_WithClosures :: Maybe PrintSettingsFunc_WithClosures
noPrintSettingsFunc_WithClosures = Nothing

-- | A simple wrapper that ignores the closure arguments.
drop_closures_PrintSettingsFunc :: PrintSettingsFunc -> PrintSettingsFunc_WithClosures
drop_closures_PrintSettingsFunc _f key value _ = _f key value

-- | Wrap the callback into a `GClosure`.
genClosure_PrintSettingsFunc :: MonadIO m => PrintSettingsFunc -> m (GClosure C_PrintSettingsFunc)
genClosure_PrintSettingsFunc cb = liftIO $ do
    let cb' = drop_closures_PrintSettingsFunc cb
    let cb'' = wrap_PrintSettingsFunc Nothing cb'
    mk_PrintSettingsFunc cb'' >>= B.GClosure.newGClosure


-- | Wrap a `PrintSettingsFunc` into a `C_PrintSettingsFunc`.
wrap_PrintSettingsFunc :: 
    Maybe (Ptr (FunPtr C_PrintSettingsFunc)) ->
    PrintSettingsFunc_WithClosures ->
    C_PrintSettingsFunc
wrap_PrintSettingsFunc gi'funptrptr gi'cb key value userData = do
    key' <- cstringToText key
    value' <- cstringToText value
    gi'cb  key' value' userData
    maybeReleaseFunPtr gi'funptrptr


-- callback PageSetupDoneFunc
{- Callable
  { returnType = Nothing
  , returnMayBeNull = False
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , args =
      [ Arg
          { argCName = "page_setup"
          , argType =
              TInterface Name { namespace = "Gtk" , name = "PageSetup" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText = Just "the #GtkPageSetup that has been"
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "data"
          , argType = TBasicType TPtr
          , direction = DirectionIn
          , mayBeNull = True
          , argDoc =
              Documentation
                { rawDocText =
                    Just
                      "user data that has been passed to\n    gtk_print_run_page_setup_dialog_async()"
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = 1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation
        { rawDocText =
            Just
              "The type of function that is passed to\ngtk_print_run_page_setup_dialog_async().\n\nThis function will be called when the page setup dialog\nis dismissed, and also serves as destroy notify for @data."
        , sinceVersion = Nothing
        }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_PageSetupDoneFunc =
    Ptr Gtk.PageSetup.PageSetup ->
    Ptr () ->
    IO ()

-- Args: [ Arg
--           { argCName = "page_setup"
--           , argType =
--               TInterface Name { namespace = "Gtk" , name = "PageSetup" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "the #GtkPageSetup that has been"
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "data"
--           , argType = TBasicType TPtr
--           , direction = DirectionIn
--           , mayBeNull = True
--           , argDoc =
--               Documentation
--                 { rawDocText =
--                     Just
--                       "user data that has been passed to\n    gtk_print_run_page_setup_dialog_async()"
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = 1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Nothing
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_PageSetupDoneFunc :: FunPtr C_PageSetupDoneFunc -> C_PageSetupDoneFunc

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_PageSetupDoneFunc ::
    (B.CallStack.HasCallStack, MonadIO m, Gtk.PageSetup.IsPageSetup a) =>
    FunPtr C_PageSetupDoneFunc
    -> a
    -- ^ /@pageSetup@/: the t'GI.Gtk.Objects.PageSetup.PageSetup' that has been
    -> Ptr ()
    -- ^ /@data@/: user data that has been passed to
    --     'GI.Gtk.Functions.printRunPageSetupDialogAsync'
    -> m ()
dynamic_PageSetupDoneFunc __funPtr pageSetup data_ = liftIO $ do
    pageSetup' <- unsafeManagedPtrCastPtr pageSetup
    (__dynamic_C_PageSetupDoneFunc __funPtr) pageSetup' data_
    touchManagedPtr pageSetup
    return ()

-- | Generate a function pointer callable from C code, from a `C_PageSetupDoneFunc`.
foreign import ccall "wrapper"
    mk_PageSetupDoneFunc :: C_PageSetupDoneFunc -> IO (FunPtr C_PageSetupDoneFunc)

-- | The type of function that is passed to
-- 'GI.Gtk.Functions.printRunPageSetupDialogAsync'.
-- 
-- This function will be called when the page setup dialog
-- is dismissed, and also serves as destroy notify for /@data@/.
type PageSetupDoneFunc =
    Gtk.PageSetup.PageSetup
    -- ^ /@pageSetup@/: the t'GI.Gtk.Objects.PageSetup.PageSetup' that has been
    -> IO ()

-- | A convenience synonym for @`Nothing` :: `Maybe` `PageSetupDoneFunc`@.
noPageSetupDoneFunc :: Maybe PageSetupDoneFunc
noPageSetupDoneFunc = Nothing

-- | The type of function that is passed to
-- 'GI.Gtk.Functions.printRunPageSetupDialogAsync'.
-- 
-- This function will be called when the page setup dialog
-- is dismissed, and also serves as destroy notify for /@data@/.
type PageSetupDoneFunc_WithClosures =
    Gtk.PageSetup.PageSetup
    -- ^ /@pageSetup@/: the t'GI.Gtk.Objects.PageSetup.PageSetup' that has been
    -> Ptr ()
    -- ^ /@data@/: user data that has been passed to
    --     'GI.Gtk.Functions.printRunPageSetupDialogAsync'
    -> IO ()

-- | A convenience synonym for @`Nothing` :: `Maybe` `PageSetupDoneFunc_WithClosures`@.
noPageSetupDoneFunc_WithClosures :: Maybe PageSetupDoneFunc_WithClosures
noPageSetupDoneFunc_WithClosures = Nothing

-- | A simple wrapper that ignores the closure arguments.
drop_closures_PageSetupDoneFunc :: PageSetupDoneFunc -> PageSetupDoneFunc_WithClosures
drop_closures_PageSetupDoneFunc _f pageSetup _ = _f pageSetup

-- | Wrap the callback into a `GClosure`.
genClosure_PageSetupDoneFunc :: MonadIO m => PageSetupDoneFunc -> m (GClosure C_PageSetupDoneFunc)
genClosure_PageSetupDoneFunc cb = liftIO $ do
    let cb' = drop_closures_PageSetupDoneFunc cb
    let cb'' = wrap_PageSetupDoneFunc Nothing cb'
    mk_PageSetupDoneFunc cb'' >>= B.GClosure.newGClosure


-- | Wrap a `PageSetupDoneFunc` into a `C_PageSetupDoneFunc`.
wrap_PageSetupDoneFunc :: 
    Maybe (Ptr (FunPtr C_PageSetupDoneFunc)) ->
    PageSetupDoneFunc_WithClosures ->
    C_PageSetupDoneFunc
wrap_PageSetupDoneFunc gi'funptrptr gi'cb pageSetup data_ = do
    pageSetup' <- (newObject Gtk.PageSetup.PageSetup) pageSetup
    gi'cb  pageSetup' data_
    maybeReleaseFunPtr gi'funptrptr


-- callback ModuleInitFunc
{- Callable
  { returnType = Nothing
  , returnMayBeNull = False
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , args =
      [ Arg
          { argCName = "argc"
          , argType = TBasicType TInt
          , direction = DirectionIn
          , mayBeNull = True
          , argDoc =
              Documentation
                { rawDocText = Just "GTK+ always passes %NULL for this argument"
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "argv"
          , argType = TCArray False (-1) 0 (TBasicType TUTF8)
          , direction = DirectionIn
          , mayBeNull = True
          , argDoc =
              Documentation
                { rawDocText = Just "GTK+ always passes %NULL for this argument"
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation
        { rawDocText =
            Just
              "Each GTK+ module must have a function gtk_module_init() with this prototype.\nThis function is called after loading the module."
        , sinceVersion = Nothing
        }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_ModuleInitFunc =
    Int32 ->
    Ptr CString ->
    IO ()

-- Args: [ Arg
--           { argCName = "argc"
--           , argType = TBasicType TInt
--           , direction = DirectionIn
--           , mayBeNull = True
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "GTK+ always passes %NULL for this argument"
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "argv"
--           , argType = TCArray False (-1) 0 (TBasicType TUTF8)
--           , direction = DirectionIn
--           , mayBeNull = True
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "GTK+ always passes %NULL for this argument"
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: [ Arg
--              { argCName = "argc"
--              , argType = TBasicType TInt
--              , direction = DirectionIn
--              , mayBeNull = True
--              , argDoc =
--                  Documentation
--                    { rawDocText = Just "GTK+ always passes %NULL for this argument"
--                    , sinceVersion = Nothing
--                    }
--              , argScope = ScopeTypeInvalid
--              , argClosure = -1
--              , argDestroy = -1
--              , argCallerAllocates = False
--              , transfer = TransferNothing
--              }
--          ]
-- returnType: Nothing
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_ModuleInitFunc :: FunPtr C_ModuleInitFunc -> C_ModuleInitFunc

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_ModuleInitFunc ::
    (B.CallStack.HasCallStack, MonadIO m) =>
    FunPtr C_ModuleInitFunc
    -> Maybe ([T.Text])
    -- ^ /@argv@/: GTK+ always passes 'P.Nothing' for this argument
    -> m ()
dynamic_ModuleInitFunc __funPtr argv = liftIO $ do
    let argc = case argv of
            Nothing -> 0
            Just jArgv -> fromIntegral $ P.length jArgv
    maybeArgv <- case argv of
        Nothing -> return nullPtr
        Just jArgv -> do
            jArgv' <- packUTF8CArray jArgv
            return jArgv'
    (__dynamic_C_ModuleInitFunc __funPtr) argc maybeArgv
    (mapCArrayWithLength argc) freeMem maybeArgv
    freeMem maybeArgv
    return ()

-- | Generate a function pointer callable from C code, from a `C_ModuleInitFunc`.
foreign import ccall "wrapper"
    mk_ModuleInitFunc :: C_ModuleInitFunc -> IO (FunPtr C_ModuleInitFunc)

-- | Each GTK+ module must have a function @/gtk_module_init()/@ with this prototype.
-- This function is called after loading the module.
type ModuleInitFunc =
    Maybe [T.Text]
    -- ^ /@argv@/: GTK+ always passes 'P.Nothing' for this argument
    -> IO ()

-- | A convenience synonym for @`Nothing` :: `Maybe` `ModuleInitFunc`@.
noModuleInitFunc :: Maybe ModuleInitFunc
noModuleInitFunc = Nothing

-- | Wrap the callback into a `GClosure`.
genClosure_ModuleInitFunc :: MonadIO m => ModuleInitFunc -> m (GClosure C_ModuleInitFunc)
genClosure_ModuleInitFunc cb = liftIO $ do
    let cb' = wrap_ModuleInitFunc Nothing cb
    mk_ModuleInitFunc cb' >>= B.GClosure.newGClosure


-- | Wrap a `ModuleInitFunc` into a `C_ModuleInitFunc`.
wrap_ModuleInitFunc :: 
    Maybe (Ptr (FunPtr C_ModuleInitFunc)) ->
    ModuleInitFunc ->
    C_ModuleInitFunc
wrap_ModuleInitFunc gi'funptrptr gi'cb argc argv = do
    maybeArgv <-
        if argv == nullPtr
        then return Nothing
        else do
            argv' <- (unpackUTF8CArrayWithLength argc) argv
            return $ Just argv'
    gi'cb  maybeArgv
    maybeReleaseFunPtr gi'funptrptr


-- callback ModuleDisplayInitFunc
{- Callable
  { returnType = Nothing
  , returnMayBeNull = False
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , args =
      [ Arg
          { argCName = "display"
          , argType =
              TInterface Name { namespace = "Gdk" , name = "Display" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText = Just "an open #GdkDisplay"
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation
        { rawDocText =
            Just
              "A multihead-aware GTK+ module may have a gtk_module_display_init() function\nwith this prototype. GTK+ calls this function for each opened display."
        , sinceVersion = Just "2.2"
        }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_ModuleDisplayInitFunc =
    Ptr Gdk.Display.Display ->
    IO ()

-- Args: [ Arg
--           { argCName = "display"
--           , argType =
--               TInterface Name { namespace = "Gdk" , name = "Display" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "an open #GdkDisplay"
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Nothing
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_ModuleDisplayInitFunc :: FunPtr C_ModuleDisplayInitFunc -> C_ModuleDisplayInitFunc

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_ModuleDisplayInitFunc ::
    (B.CallStack.HasCallStack, MonadIO m, Gdk.Display.IsDisplay a) =>
    FunPtr C_ModuleDisplayInitFunc
    -> a
    -- ^ /@display@/: an open t'GI.Gdk.Objects.Display.Display'
    -> m ()
dynamic_ModuleDisplayInitFunc __funPtr display = liftIO $ do
    display' <- unsafeManagedPtrCastPtr display
    (__dynamic_C_ModuleDisplayInitFunc __funPtr) display'
    touchManagedPtr display
    return ()

-- | Generate a function pointer callable from C code, from a `C_ModuleDisplayInitFunc`.
foreign import ccall "wrapper"
    mk_ModuleDisplayInitFunc :: C_ModuleDisplayInitFunc -> IO (FunPtr C_ModuleDisplayInitFunc)

-- | A multihead-aware GTK+ module may have a @/gtk_module_display_init()/@ function
-- with this prototype. GTK+ calls this function for each opened display.
-- 
-- /Since: 2.2/
type ModuleDisplayInitFunc =
    Gdk.Display.Display
    -- ^ /@display@/: an open t'GI.Gdk.Objects.Display.Display'
    -> IO ()

-- | A convenience synonym for @`Nothing` :: `Maybe` `ModuleDisplayInitFunc`@.
noModuleDisplayInitFunc :: Maybe ModuleDisplayInitFunc
noModuleDisplayInitFunc = Nothing

-- | Wrap the callback into a `GClosure`.
genClosure_ModuleDisplayInitFunc :: MonadIO m => ModuleDisplayInitFunc -> m (GClosure C_ModuleDisplayInitFunc)
genClosure_ModuleDisplayInitFunc cb = liftIO $ do
    let cb' = wrap_ModuleDisplayInitFunc Nothing cb
    mk_ModuleDisplayInitFunc cb' >>= B.GClosure.newGClosure


-- | Wrap a `ModuleDisplayInitFunc` into a `C_ModuleDisplayInitFunc`.
wrap_ModuleDisplayInitFunc :: 
    Maybe (Ptr (FunPtr C_ModuleDisplayInitFunc)) ->
    ModuleDisplayInitFunc ->
    C_ModuleDisplayInitFunc
wrap_ModuleDisplayInitFunc gi'funptrptr gi'cb display = do
    display' <- (newObject Gdk.Display.Display) display
    gi'cb  display'
    maybeReleaseFunPtr gi'funptrptr


-- callback MenuPositionFunc
{- Callable
  { returnType = Nothing
  , returnMayBeNull = False
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , args =
      [ Arg
          { argCName = "menu"
          , argType = TInterface Name { namespace = "Gtk" , name = "Menu" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText = Just "a #GtkMenu." , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "x"
          , argType = TBasicType TInt
          , direction = DirectionInout
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText =
                    Just
                      "address of the #gint representing the horizontal\n    position where the menu shall be drawn."
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferEverything
          }
      , Arg
          { argCName = "y"
          , argType = TBasicType TInt
          , direction = DirectionInout
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText =
                    Just
                      "address of the #gint representing the vertical position\n    where the menu shall be drawn.  This is an output parameter."
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferEverything
          }
      , Arg
          { argCName = "push_in"
          , argType = TBasicType TBoolean
          , direction = DirectionOut
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText =
                    Just
                      "This parameter controls how menus placed outside\n    the monitor are handled.  If this is set to %TRUE and part of\n    the menu is outside the monitor then GTK+ pushes the window\n    into the visible area, effectively modifying the popup\n    position.  Note that moving and possibly resizing the menu\n    around will alter the scroll position to keep the menu items\n    \8220in place\8221, i.e. at the same monitor position they would have\n    been without resizing.  In practice, this behavior is only\n    useful for combobox popups or option menus and cannot be used\n    to simply confine a menu to monitor boundaries.  In that case,\n    changing the scroll offset is not desirable."
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferEverything
          }
      , Arg
          { argCName = "user_data"
          , argType = TBasicType TPtr
          , direction = DirectionIn
          , mayBeNull = True
          , argDoc =
              Documentation
                { rawDocText =
                    Just
                      "the data supplied by the user in the gtk_menu_popup()\n    @data parameter."
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = 4
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation
        { rawDocText =
            Just
              "A user function supplied when calling gtk_menu_popup() which\ncontrols the positioning of the menu when it is displayed.  The\nfunction sets the @x and @y parameters to the coordinates where the\nmenu is to be drawn.  To make the menu appear on a different\nmonitor than the mouse pointer, gtk_menu_set_monitor() must be\ncalled."
        , sinceVersion = Nothing
        }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_MenuPositionFunc =
    Ptr Gtk.Menu.Menu ->
    Ptr Int32 ->
    Ptr Int32 ->
    Ptr CInt ->
    Ptr () ->
    IO ()

-- Args: [ Arg
--           { argCName = "menu"
--           , argType = TInterface Name { namespace = "Gtk" , name = "Menu" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "a #GtkMenu." , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "x"
--           , argType = TBasicType TInt
--           , direction = DirectionInout
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText =
--                     Just
--                       "address of the #gint representing the horizontal\n    position where the menu shall be drawn."
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferEverything
--           }
--       , Arg
--           { argCName = "y"
--           , argType = TBasicType TInt
--           , direction = DirectionInout
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText =
--                     Just
--                       "address of the #gint representing the vertical position\n    where the menu shall be drawn.  This is an output parameter."
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferEverything
--           }
--       , Arg
--           { argCName = "push_in"
--           , argType = TBasicType TBoolean
--           , direction = DirectionOut
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText =
--                     Just
--                       "This parameter controls how menus placed outside\n    the monitor are handled.  If this is set to %TRUE and part of\n    the menu is outside the monitor then GTK+ pushes the window\n    into the visible area, effectively modifying the popup\n    position.  Note that moving and possibly resizing the menu\n    around will alter the scroll position to keep the menu items\n    \8220in place\8221, i.e. at the same monitor position they would have\n    been without resizing.  In practice, this behavior is only\n    useful for combobox popups or option menus and cannot be used\n    to simply confine a menu to monitor boundaries.  In that case,\n    changing the scroll offset is not desirable."
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferEverything
--           }
--       , Arg
--           { argCName = "user_data"
--           , argType = TBasicType TPtr
--           , direction = DirectionIn
--           , mayBeNull = True
--           , argDoc =
--               Documentation
--                 { rawDocText =
--                     Just
--                       "the data supplied by the user in the gtk_menu_popup()\n    @data parameter."
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = 4
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Nothing
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_MenuPositionFunc :: FunPtr C_MenuPositionFunc -> C_MenuPositionFunc

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_MenuPositionFunc ::
    (B.CallStack.HasCallStack, MonadIO m, Gtk.Menu.IsMenu a) =>
    FunPtr C_MenuPositionFunc
    -> a
    -- ^ /@menu@/: a t'GI.Gtk.Objects.Menu.Menu'.
    -> Int32
    -- ^ /@x@/: address of the @/gint/@ representing the horizontal
    --     position where the menu shall be drawn.
    -> Int32
    -- ^ /@y@/: address of the @/gint/@ representing the vertical position
    --     where the menu shall be drawn.  This is an output parameter.
    -> Ptr ()
    -- ^ /@userData@/: the data supplied by the user in the 'GI.Gtk.Objects.Menu.menuPopup'
    --     /@data@/ parameter.
    -> m ((Int32, Int32, Bool))
dynamic_MenuPositionFunc __funPtr menu x y userData = liftIO $ do
    menu' <- unsafeManagedPtrCastPtr menu
    x' <- allocMem :: IO (Ptr Int32)
    poke x' x
    y' <- allocMem :: IO (Ptr Int32)
    poke y' y
    pushIn <- allocMem :: IO (Ptr CInt)
    (__dynamic_C_MenuPositionFunc __funPtr) menu' x' y' pushIn userData
    x'' <- peek x'
    y'' <- peek y'
    pushIn' <- peek pushIn
    let pushIn'' = (/= 0) pushIn'
    touchManagedPtr menu
    freeMem x'
    freeMem y'
    freeMem pushIn
    return (x'', y'', pushIn'')

-- | Generate a function pointer callable from C code, from a `C_MenuPositionFunc`.
foreign import ccall "wrapper"
    mk_MenuPositionFunc :: C_MenuPositionFunc -> IO (FunPtr C_MenuPositionFunc)

-- | A user function supplied when calling 'GI.Gtk.Objects.Menu.menuPopup' which
-- controls the positioning of the menu when it is displayed.  The
-- function sets the /@x@/ and /@y@/ parameters to the coordinates where the
-- menu is to be drawn.  To make the menu appear on a different
-- monitor than the mouse pointer, 'GI.Gtk.Objects.Menu.menuSetMonitor' must be
-- called.
type MenuPositionFunc =
    Gtk.Menu.Menu
    -- ^ /@menu@/: a t'GI.Gtk.Objects.Menu.Menu'.
    -> Int32
    -- ^ /@x@/: address of the @/gint/@ representing the horizontal
    --     position where the menu shall be drawn.
    -> Int32
    -- ^ /@y@/: address of the @/gint/@ representing the vertical position
    --     where the menu shall be drawn.  This is an output parameter.
    -> IO ((Int32, Int32, Bool))

-- | A convenience synonym for @`Nothing` :: `Maybe` `MenuPositionFunc`@.
noMenuPositionFunc :: Maybe MenuPositionFunc
noMenuPositionFunc = Nothing

-- | A user function supplied when calling 'GI.Gtk.Objects.Menu.menuPopup' which
-- controls the positioning of the menu when it is displayed.  The
-- function sets the /@x@/ and /@y@/ parameters to the coordinates where the
-- menu is to be drawn.  To make the menu appear on a different
-- monitor than the mouse pointer, 'GI.Gtk.Objects.Menu.menuSetMonitor' must be
-- called.
type MenuPositionFunc_WithClosures =
    Gtk.Menu.Menu
    -- ^ /@menu@/: a t'GI.Gtk.Objects.Menu.Menu'.
    -> Int32
    -- ^ /@x@/: address of the @/gint/@ representing the horizontal
    --     position where the menu shall be drawn.
    -> Int32
    -- ^ /@y@/: address of the @/gint/@ representing the vertical position
    --     where the menu shall be drawn.  This is an output parameter.
    -> Ptr ()
    -- ^ /@userData@/: the data supplied by the user in the 'GI.Gtk.Objects.Menu.menuPopup'
    --     /@data@/ parameter.
    -> IO ((Int32, Int32, Bool))

-- | A convenience synonym for @`Nothing` :: `Maybe` `MenuPositionFunc_WithClosures`@.
noMenuPositionFunc_WithClosures :: Maybe MenuPositionFunc_WithClosures
noMenuPositionFunc_WithClosures = Nothing

-- | A simple wrapper that ignores the closure arguments.
drop_closures_MenuPositionFunc :: MenuPositionFunc -> MenuPositionFunc_WithClosures
drop_closures_MenuPositionFunc _f menu x y _ = _f menu x y

-- | Wrap the callback into a `GClosure`.
genClosure_MenuPositionFunc :: MonadIO m => MenuPositionFunc -> m (GClosure C_MenuPositionFunc)
genClosure_MenuPositionFunc cb = liftIO $ do
    let cb' = drop_closures_MenuPositionFunc cb
    let cb'' = wrap_MenuPositionFunc Nothing cb'
    mk_MenuPositionFunc cb'' >>= B.GClosure.newGClosure


-- | Wrap a `MenuPositionFunc` into a `C_MenuPositionFunc`.
wrap_MenuPositionFunc :: 
    Maybe (Ptr (FunPtr C_MenuPositionFunc)) ->
    MenuPositionFunc_WithClosures ->
    C_MenuPositionFunc
wrap_MenuPositionFunc gi'funptrptr gi'cb menu x y pushIn userData = do
    menu' <- (newObject Gtk.Menu.Menu) menu
    x' <- peek x
    y' <- peek y
    (outx, outy, outpushIn) <- gi'cb  menu' x' y' userData
    poke x outx
    poke y outy
    let outpushIn' = (fromIntegral . fromEnum) outpushIn
    poke pushIn outpushIn'
    maybeReleaseFunPtr gi'funptrptr


-- callback MenuDetachFunc
{- Callable
  { returnType = Nothing
  , returnMayBeNull = False
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , args =
      [ Arg
          { argCName = "attach_widget"
          , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText =
                    Just "the #GtkWidget that the menu is being detached from."
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "menu"
          , argType = TInterface Name { namespace = "Gtk" , name = "Menu" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText = Just "the #GtkMenu being detached."
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation
        { rawDocText =
            Just
              "A user function supplied when calling gtk_menu_attach_to_widget() which\nwill be called when the menu is later detached from the widget."
        , sinceVersion = Nothing
        }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_MenuDetachFunc =
    Ptr Gtk.Widget.Widget ->
    Ptr Gtk.Menu.Menu ->
    IO ()

-- Args: [ Arg
--           { argCName = "attach_widget"
--           , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText =
--                     Just "the #GtkWidget that the menu is being detached from."
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "menu"
--           , argType = TInterface Name { namespace = "Gtk" , name = "Menu" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "the #GtkMenu being detached."
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Nothing
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_MenuDetachFunc :: FunPtr C_MenuDetachFunc -> C_MenuDetachFunc

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_MenuDetachFunc ::
    (B.CallStack.HasCallStack, MonadIO m, Gtk.Widget.IsWidget a, Gtk.Menu.IsMenu b) =>
    FunPtr C_MenuDetachFunc
    -> a
    -- ^ /@attachWidget@/: the t'GI.Gtk.Objects.Widget.Widget' that the menu is being detached from.
    -> b
    -- ^ /@menu@/: the t'GI.Gtk.Objects.Menu.Menu' being detached.
    -> m ()
dynamic_MenuDetachFunc __funPtr attachWidget menu = liftIO $ do
    attachWidget' <- unsafeManagedPtrCastPtr attachWidget
    menu' <- unsafeManagedPtrCastPtr menu
    (__dynamic_C_MenuDetachFunc __funPtr) attachWidget' menu'
    touchManagedPtr attachWidget
    touchManagedPtr menu
    return ()

-- | Generate a function pointer callable from C code, from a `C_MenuDetachFunc`.
foreign import ccall "wrapper"
    mk_MenuDetachFunc :: C_MenuDetachFunc -> IO (FunPtr C_MenuDetachFunc)

-- | A user function supplied when calling 'GI.Gtk.Objects.Menu.menuAttachToWidget' which
-- will be called when the menu is later detached from the widget.
type MenuDetachFunc =
    Gtk.Widget.Widget
    -- ^ /@attachWidget@/: the t'GI.Gtk.Objects.Widget.Widget' that the menu is being detached from.
    -> Gtk.Menu.Menu
    -- ^ /@menu@/: the t'GI.Gtk.Objects.Menu.Menu' being detached.
    -> IO ()

-- | A convenience synonym for @`Nothing` :: `Maybe` `MenuDetachFunc`@.
noMenuDetachFunc :: Maybe MenuDetachFunc
noMenuDetachFunc = Nothing

-- | Wrap the callback into a `GClosure`.
genClosure_MenuDetachFunc :: MonadIO m => MenuDetachFunc -> m (GClosure C_MenuDetachFunc)
genClosure_MenuDetachFunc cb = liftIO $ do
    let cb' = wrap_MenuDetachFunc Nothing cb
    mk_MenuDetachFunc cb' >>= B.GClosure.newGClosure


-- | Wrap a `MenuDetachFunc` into a `C_MenuDetachFunc`.
wrap_MenuDetachFunc :: 
    Maybe (Ptr (FunPtr C_MenuDetachFunc)) ->
    MenuDetachFunc ->
    C_MenuDetachFunc
wrap_MenuDetachFunc gi'funptrptr gi'cb attachWidget menu = do
    attachWidget' <- (newObject Gtk.Widget.Widget) attachWidget
    menu' <- (newObject Gtk.Menu.Menu) menu
    gi'cb  attachWidget' menu'
    maybeReleaseFunPtr gi'funptrptr


-- callback ListBoxUpdateHeaderFunc
{- Callable
  { returnType = Nothing
  , returnMayBeNull = False
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , args =
      [ Arg
          { argCName = "row"
          , argType =
              TInterface Name { namespace = "Gtk" , name = "ListBoxRow" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText = Just "the row to update" , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "before"
          , argType =
              TInterface Name { namespace = "Gtk" , name = "ListBoxRow" }
          , direction = DirectionIn
          , mayBeNull = True
          , argDoc =
              Documentation
                { rawDocText = Just "the row before @row, or %NULL if it is first"
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "user_data"
          , argType = TBasicType TPtr
          , direction = DirectionIn
          , mayBeNull = True
          , argDoc =
              Documentation
                { rawDocText = Just "user data" , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = 2
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation
        { rawDocText =
            Just
              "Whenever @row changes or which row is before @row changes this\nis called, which lets you update the header on @row. You may\nremove or set a new one via gtk_list_box_row_set_header() or\njust change the state of the current header widget."
        , sinceVersion = Just "3.10"
        }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_ListBoxUpdateHeaderFunc =
    Ptr Gtk.ListBoxRow.ListBoxRow ->
    Ptr Gtk.ListBoxRow.ListBoxRow ->
    Ptr () ->
    IO ()

-- Args: [ Arg
--           { argCName = "row"
--           , argType =
--               TInterface Name { namespace = "Gtk" , name = "ListBoxRow" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "the row to update" , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "before"
--           , argType =
--               TInterface Name { namespace = "Gtk" , name = "ListBoxRow" }
--           , direction = DirectionIn
--           , mayBeNull = True
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "the row before @row, or %NULL if it is first"
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "user_data"
--           , argType = TBasicType TPtr
--           , direction = DirectionIn
--           , mayBeNull = True
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "user data" , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = 2
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Nothing
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_ListBoxUpdateHeaderFunc :: FunPtr C_ListBoxUpdateHeaderFunc -> C_ListBoxUpdateHeaderFunc

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_ListBoxUpdateHeaderFunc ::
    (B.CallStack.HasCallStack, MonadIO m, Gtk.ListBoxRow.IsListBoxRow a, Gtk.ListBoxRow.IsListBoxRow b) =>
    FunPtr C_ListBoxUpdateHeaderFunc
    -> a
    -- ^ /@row@/: the row to update
    -> Maybe (b)
    -- ^ /@before@/: the row before /@row@/, or 'P.Nothing' if it is first
    -> Ptr ()
    -- ^ /@userData@/: user data
    -> m ()
dynamic_ListBoxUpdateHeaderFunc __funPtr row before userData = liftIO $ do
    row' <- unsafeManagedPtrCastPtr row
    maybeBefore <- case before of
        Nothing -> return nullPtr
        Just jBefore -> do
            jBefore' <- unsafeManagedPtrCastPtr jBefore
            return jBefore'
    (__dynamic_C_ListBoxUpdateHeaderFunc __funPtr) row' maybeBefore userData
    touchManagedPtr row
    whenJust before touchManagedPtr
    return ()

-- | Generate a function pointer callable from C code, from a `C_ListBoxUpdateHeaderFunc`.
foreign import ccall "wrapper"
    mk_ListBoxUpdateHeaderFunc :: C_ListBoxUpdateHeaderFunc -> IO (FunPtr C_ListBoxUpdateHeaderFunc)

-- | Whenever /@row@/ changes or which row is before /@row@/ changes this
-- is called, which lets you update the header on /@row@/. You may
-- remove or set a new one via 'GI.Gtk.Objects.ListBoxRow.listBoxRowSetHeader' or
-- just change the state of the current header widget.
-- 
-- /Since: 3.10/
type ListBoxUpdateHeaderFunc =
    Gtk.ListBoxRow.ListBoxRow
    -- ^ /@row@/: the row to update
    -> Maybe Gtk.ListBoxRow.ListBoxRow
    -- ^ /@before@/: the row before /@row@/, or 'P.Nothing' if it is first
    -> IO ()

-- | A convenience synonym for @`Nothing` :: `Maybe` `ListBoxUpdateHeaderFunc`@.
noListBoxUpdateHeaderFunc :: Maybe ListBoxUpdateHeaderFunc
noListBoxUpdateHeaderFunc = Nothing

-- | Whenever /@row@/ changes or which row is before /@row@/ changes this
-- is called, which lets you update the header on /@row@/. You may
-- remove or set a new one via 'GI.Gtk.Objects.ListBoxRow.listBoxRowSetHeader' or
-- just change the state of the current header widget.
-- 
-- /Since: 3.10/
type ListBoxUpdateHeaderFunc_WithClosures =
    Gtk.ListBoxRow.ListBoxRow
    -- ^ /@row@/: the row to update
    -> Maybe Gtk.ListBoxRow.ListBoxRow
    -- ^ /@before@/: the row before /@row@/, or 'P.Nothing' if it is first
    -> Ptr ()
    -- ^ /@userData@/: user data
    -> IO ()

-- | A convenience synonym for @`Nothing` :: `Maybe` `ListBoxUpdateHeaderFunc_WithClosures`@.
noListBoxUpdateHeaderFunc_WithClosures :: Maybe ListBoxUpdateHeaderFunc_WithClosures
noListBoxUpdateHeaderFunc_WithClosures = Nothing

-- | A simple wrapper that ignores the closure arguments.
drop_closures_ListBoxUpdateHeaderFunc :: ListBoxUpdateHeaderFunc -> ListBoxUpdateHeaderFunc_WithClosures
drop_closures_ListBoxUpdateHeaderFunc _f row before _ = _f row before

-- | Wrap the callback into a `GClosure`.
genClosure_ListBoxUpdateHeaderFunc :: MonadIO m => ListBoxUpdateHeaderFunc -> m (GClosure C_ListBoxUpdateHeaderFunc)
genClosure_ListBoxUpdateHeaderFunc cb = liftIO $ do
    let cb' = drop_closures_ListBoxUpdateHeaderFunc cb
    let cb'' = wrap_ListBoxUpdateHeaderFunc Nothing cb'
    mk_ListBoxUpdateHeaderFunc cb'' >>= B.GClosure.newGClosure


-- | Wrap a `ListBoxUpdateHeaderFunc` into a `C_ListBoxUpdateHeaderFunc`.
wrap_ListBoxUpdateHeaderFunc :: 
    Maybe (Ptr (FunPtr C_ListBoxUpdateHeaderFunc)) ->
    ListBoxUpdateHeaderFunc_WithClosures ->
    C_ListBoxUpdateHeaderFunc
wrap_ListBoxUpdateHeaderFunc gi'funptrptr gi'cb row before userData = do
    row' <- (newObject Gtk.ListBoxRow.ListBoxRow) row
    maybeBefore <-
        if before == nullPtr
        then return Nothing
        else do
            before' <- (newObject Gtk.ListBoxRow.ListBoxRow) before
            return $ Just before'
    gi'cb  row' maybeBefore userData
    maybeReleaseFunPtr gi'funptrptr


-- callback ListBoxSortFunc
{- Callable
  { returnType = Just (TBasicType TInt)
  , returnMayBeNull = False
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation
        { rawDocText =
            Just
              "< 0 if @row1 should be before @row2, 0 if they are\n    equal and > 0 otherwise"
        , sinceVersion = Nothing
        }
  , args =
      [ Arg
          { argCName = "row1"
          , argType =
              TInterface Name { namespace = "Gtk" , name = "ListBoxRow" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText = Just "the first row" , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "row2"
          , argType =
              TInterface Name { namespace = "Gtk" , name = "ListBoxRow" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText = Just "the second row" , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "user_data"
          , argType = TBasicType TPtr
          , direction = DirectionIn
          , mayBeNull = True
          , argDoc =
              Documentation
                { rawDocText = Just "user data" , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = 2
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation
        { rawDocText =
            Just "Compare two rows to determine which should be first."
        , sinceVersion = Just "3.10"
        }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_ListBoxSortFunc =
    Ptr Gtk.ListBoxRow.ListBoxRow ->
    Ptr Gtk.ListBoxRow.ListBoxRow ->
    Ptr () ->
    IO Int32

-- Args: [ Arg
--           { argCName = "row1"
--           , argType =
--               TInterface Name { namespace = "Gtk" , name = "ListBoxRow" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "the first row" , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "row2"
--           , argType =
--               TInterface Name { namespace = "Gtk" , name = "ListBoxRow" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "the second row" , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "user_data"
--           , argType = TBasicType TPtr
--           , direction = DirectionIn
--           , mayBeNull = True
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "user data" , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = 2
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Just (TBasicType TInt)
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_ListBoxSortFunc :: FunPtr C_ListBoxSortFunc -> C_ListBoxSortFunc

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_ListBoxSortFunc ::
    (B.CallStack.HasCallStack, MonadIO m, Gtk.ListBoxRow.IsListBoxRow a, Gtk.ListBoxRow.IsListBoxRow b) =>
    FunPtr C_ListBoxSortFunc
    -> a
    -- ^ /@row1@/: the first row
    -> b
    -- ^ /@row2@/: the second row
    -> Ptr ()
    -- ^ /@userData@/: user data
    -> m Int32
    -- ^ __Returns:__ \< 0 if /@row1@/ should be before /@row2@/, 0 if they are
    --     equal and > 0 otherwise
dynamic_ListBoxSortFunc __funPtr row1 row2 userData = liftIO $ do
    row1' <- unsafeManagedPtrCastPtr row1
    row2' <- unsafeManagedPtrCastPtr row2
    result <- (__dynamic_C_ListBoxSortFunc __funPtr) row1' row2' userData
    touchManagedPtr row1
    touchManagedPtr row2
    return result

-- | Generate a function pointer callable from C code, from a `C_ListBoxSortFunc`.
foreign import ccall "wrapper"
    mk_ListBoxSortFunc :: C_ListBoxSortFunc -> IO (FunPtr C_ListBoxSortFunc)

-- | Compare two rows to determine which should be first.
-- 
-- /Since: 3.10/
type ListBoxSortFunc =
    Gtk.ListBoxRow.ListBoxRow
    -- ^ /@row1@/: the first row
    -> Gtk.ListBoxRow.ListBoxRow
    -- ^ /@row2@/: the second row
    -> IO Int32
    -- ^ __Returns:__ \< 0 if /@row1@/ should be before /@row2@/, 0 if they are
    --     equal and > 0 otherwise

-- | A convenience synonym for @`Nothing` :: `Maybe` `ListBoxSortFunc`@.
noListBoxSortFunc :: Maybe ListBoxSortFunc
noListBoxSortFunc = Nothing

-- | Compare two rows to determine which should be first.
-- 
-- /Since: 3.10/
type ListBoxSortFunc_WithClosures =
    Gtk.ListBoxRow.ListBoxRow
    -- ^ /@row1@/: the first row
    -> Gtk.ListBoxRow.ListBoxRow
    -- ^ /@row2@/: the second row
    -> Ptr ()
    -- ^ /@userData@/: user data
    -> IO Int32
    -- ^ __Returns:__ \< 0 if /@row1@/ should be before /@row2@/, 0 if they are
    --     equal and > 0 otherwise

-- | A convenience synonym for @`Nothing` :: `Maybe` `ListBoxSortFunc_WithClosures`@.
noListBoxSortFunc_WithClosures :: Maybe ListBoxSortFunc_WithClosures
noListBoxSortFunc_WithClosures = Nothing

-- | A simple wrapper that ignores the closure arguments.
drop_closures_ListBoxSortFunc :: ListBoxSortFunc -> ListBoxSortFunc_WithClosures
drop_closures_ListBoxSortFunc _f row1 row2 _ = _f row1 row2

-- | Wrap the callback into a `GClosure`.
genClosure_ListBoxSortFunc :: MonadIO m => ListBoxSortFunc -> m (GClosure C_ListBoxSortFunc)
genClosure_ListBoxSortFunc cb = liftIO $ do
    let cb' = drop_closures_ListBoxSortFunc cb
    let cb'' = wrap_ListBoxSortFunc Nothing cb'
    mk_ListBoxSortFunc cb'' >>= B.GClosure.newGClosure


-- | Wrap a `ListBoxSortFunc` into a `C_ListBoxSortFunc`.
wrap_ListBoxSortFunc :: 
    Maybe (Ptr (FunPtr C_ListBoxSortFunc)) ->
    ListBoxSortFunc_WithClosures ->
    C_ListBoxSortFunc
wrap_ListBoxSortFunc gi'funptrptr gi'cb row1 row2 userData = do
    row1' <- (newObject Gtk.ListBoxRow.ListBoxRow) row1
    row2' <- (newObject Gtk.ListBoxRow.ListBoxRow) row2
    result <- gi'cb  row1' row2' userData
    maybeReleaseFunPtr gi'funptrptr
    return result


-- callback ListBoxForeachFunc
{- Callable
  { returnType = Nothing
  , returnMayBeNull = False
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , args =
      [ Arg
          { argCName = "box"
          , argType =
              TInterface Name { namespace = "Gtk" , name = "ListBox" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText = Just "a #GtkListBox" , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "row"
          , argType =
              TInterface Name { namespace = "Gtk" , name = "ListBoxRow" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText = Just "a #GtkListBoxRow" , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "user_data"
          , argType = TBasicType TPtr
          , direction = DirectionIn
          , mayBeNull = True
          , argDoc =
              Documentation
                { rawDocText = Just "user data" , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = 2
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation
        { rawDocText =
            Just
              "A function used by gtk_list_box_selected_foreach().\nIt will be called on every selected child of the @box."
        , sinceVersion = Just "3.14"
        }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_ListBoxForeachFunc =
    Ptr Gtk.ListBox.ListBox ->
    Ptr Gtk.ListBoxRow.ListBoxRow ->
    Ptr () ->
    IO ()

-- Args: [ Arg
--           { argCName = "box"
--           , argType =
--               TInterface Name { namespace = "Gtk" , name = "ListBox" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "a #GtkListBox" , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "row"
--           , argType =
--               TInterface Name { namespace = "Gtk" , name = "ListBoxRow" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "a #GtkListBoxRow" , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "user_data"
--           , argType = TBasicType TPtr
--           , direction = DirectionIn
--           , mayBeNull = True
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "user data" , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = 2
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Nothing
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_ListBoxForeachFunc :: FunPtr C_ListBoxForeachFunc -> C_ListBoxForeachFunc

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_ListBoxForeachFunc ::
    (B.CallStack.HasCallStack, MonadIO m, Gtk.ListBox.IsListBox a, Gtk.ListBoxRow.IsListBoxRow b) =>
    FunPtr C_ListBoxForeachFunc
    -> a
    -- ^ /@box@/: a t'GI.Gtk.Objects.ListBox.ListBox'
    -> b
    -- ^ /@row@/: a t'GI.Gtk.Objects.ListBoxRow.ListBoxRow'
    -> Ptr ()
    -- ^ /@userData@/: user data
    -> m ()
dynamic_ListBoxForeachFunc __funPtr box row userData = liftIO $ do
    box' <- unsafeManagedPtrCastPtr box
    row' <- unsafeManagedPtrCastPtr row
    (__dynamic_C_ListBoxForeachFunc __funPtr) box' row' userData
    touchManagedPtr box
    touchManagedPtr row
    return ()

-- | Generate a function pointer callable from C code, from a `C_ListBoxForeachFunc`.
foreign import ccall "wrapper"
    mk_ListBoxForeachFunc :: C_ListBoxForeachFunc -> IO (FunPtr C_ListBoxForeachFunc)

-- | A function used by 'GI.Gtk.Objects.ListBox.listBoxSelectedForeach'.
-- It will be called on every selected child of the /@box@/.
-- 
-- /Since: 3.14/
type ListBoxForeachFunc =
    Gtk.ListBox.ListBox
    -- ^ /@box@/: a t'GI.Gtk.Objects.ListBox.ListBox'
    -> Gtk.ListBoxRow.ListBoxRow
    -- ^ /@row@/: a t'GI.Gtk.Objects.ListBoxRow.ListBoxRow'
    -> IO ()

-- | A convenience synonym for @`Nothing` :: `Maybe` `ListBoxForeachFunc`@.
noListBoxForeachFunc :: Maybe ListBoxForeachFunc
noListBoxForeachFunc = Nothing

-- | A function used by 'GI.Gtk.Objects.ListBox.listBoxSelectedForeach'.
-- It will be called on every selected child of the /@box@/.
-- 
-- /Since: 3.14/
type ListBoxForeachFunc_WithClosures =
    Gtk.ListBox.ListBox
    -- ^ /@box@/: a t'GI.Gtk.Objects.ListBox.ListBox'
    -> Gtk.ListBoxRow.ListBoxRow
    -- ^ /@row@/: a t'GI.Gtk.Objects.ListBoxRow.ListBoxRow'
    -> Ptr ()
    -- ^ /@userData@/: user data
    -> IO ()

-- | A convenience synonym for @`Nothing` :: `Maybe` `ListBoxForeachFunc_WithClosures`@.
noListBoxForeachFunc_WithClosures :: Maybe ListBoxForeachFunc_WithClosures
noListBoxForeachFunc_WithClosures = Nothing

-- | A simple wrapper that ignores the closure arguments.
drop_closures_ListBoxForeachFunc :: ListBoxForeachFunc -> ListBoxForeachFunc_WithClosures
drop_closures_ListBoxForeachFunc _f box row _ = _f box row

-- | Wrap the callback into a `GClosure`.
genClosure_ListBoxForeachFunc :: MonadIO m => ListBoxForeachFunc -> m (GClosure C_ListBoxForeachFunc)
genClosure_ListBoxForeachFunc cb = liftIO $ do
    let cb' = drop_closures_ListBoxForeachFunc cb
    let cb'' = wrap_ListBoxForeachFunc Nothing cb'
    mk_ListBoxForeachFunc cb'' >>= B.GClosure.newGClosure


-- | Wrap a `ListBoxForeachFunc` into a `C_ListBoxForeachFunc`.
wrap_ListBoxForeachFunc :: 
    Maybe (Ptr (FunPtr C_ListBoxForeachFunc)) ->
    ListBoxForeachFunc_WithClosures ->
    C_ListBoxForeachFunc
wrap_ListBoxForeachFunc gi'funptrptr gi'cb box row userData = do
    box' <- (newObject Gtk.ListBox.ListBox) box
    row' <- (newObject Gtk.ListBoxRow.ListBoxRow) row
    gi'cb  box' row' userData
    maybeReleaseFunPtr gi'funptrptr


-- callback ListBoxFilterFunc
{- Callable
  { returnType = Just (TBasicType TBoolean)
  , returnMayBeNull = False
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation
        { rawDocText =
            Just "%TRUE if the row should be visible, %FALSE otherwise"
        , sinceVersion = Nothing
        }
  , args =
      [ Arg
          { argCName = "row"
          , argType =
              TInterface Name { namespace = "Gtk" , name = "ListBoxRow" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText = Just "the row that may be filtered"
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "user_data"
          , argType = TBasicType TPtr
          , direction = DirectionIn
          , mayBeNull = True
          , argDoc =
              Documentation
                { rawDocText = Just "user data" , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = 1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation
        { rawDocText =
            Just
              "Will be called whenever the row changes or is added and lets you control\nif the row should be visible or not."
        , sinceVersion = Just "3.10"
        }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_ListBoxFilterFunc =
    Ptr Gtk.ListBoxRow.ListBoxRow ->
    Ptr () ->
    IO CInt

-- Args: [ Arg
--           { argCName = "row"
--           , argType =
--               TInterface Name { namespace = "Gtk" , name = "ListBoxRow" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "the row that may be filtered"
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "user_data"
--           , argType = TBasicType TPtr
--           , direction = DirectionIn
--           , mayBeNull = True
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "user data" , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = 1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Just (TBasicType TBoolean)
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_ListBoxFilterFunc :: FunPtr C_ListBoxFilterFunc -> C_ListBoxFilterFunc

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_ListBoxFilterFunc ::
    (B.CallStack.HasCallStack, MonadIO m, Gtk.ListBoxRow.IsListBoxRow a) =>
    FunPtr C_ListBoxFilterFunc
    -> a
    -- ^ /@row@/: the row that may be filtered
    -> Ptr ()
    -- ^ /@userData@/: user data
    -> m Bool
    -- ^ __Returns:__ 'P.True' if the row should be visible, 'P.False' otherwise
dynamic_ListBoxFilterFunc __funPtr row userData = liftIO $ do
    row' <- unsafeManagedPtrCastPtr row
    result <- (__dynamic_C_ListBoxFilterFunc __funPtr) row' userData
    let result' = (/= 0) result
    touchManagedPtr row
    return result'

-- | Generate a function pointer callable from C code, from a `C_ListBoxFilterFunc`.
foreign import ccall "wrapper"
    mk_ListBoxFilterFunc :: C_ListBoxFilterFunc -> IO (FunPtr C_ListBoxFilterFunc)

-- | Will be called whenever the row changes or is added and lets you control
-- if the row should be visible or not.
-- 
-- /Since: 3.10/
type ListBoxFilterFunc =
    Gtk.ListBoxRow.ListBoxRow
    -- ^ /@row@/: the row that may be filtered
    -> IO Bool
    -- ^ __Returns:__ 'P.True' if the row should be visible, 'P.False' otherwise

-- | A convenience synonym for @`Nothing` :: `Maybe` `ListBoxFilterFunc`@.
noListBoxFilterFunc :: Maybe ListBoxFilterFunc
noListBoxFilterFunc = Nothing

-- | Will be called whenever the row changes or is added and lets you control
-- if the row should be visible or not.
-- 
-- /Since: 3.10/
type ListBoxFilterFunc_WithClosures =
    Gtk.ListBoxRow.ListBoxRow
    -- ^ /@row@/: the row that may be filtered
    -> Ptr ()
    -- ^ /@userData@/: user data
    -> IO Bool
    -- ^ __Returns:__ 'P.True' if the row should be visible, 'P.False' otherwise

-- | A convenience synonym for @`Nothing` :: `Maybe` `ListBoxFilterFunc_WithClosures`@.
noListBoxFilterFunc_WithClosures :: Maybe ListBoxFilterFunc_WithClosures
noListBoxFilterFunc_WithClosures = Nothing

-- | A simple wrapper that ignores the closure arguments.
drop_closures_ListBoxFilterFunc :: ListBoxFilterFunc -> ListBoxFilterFunc_WithClosures
drop_closures_ListBoxFilterFunc _f row _ = _f row

-- | Wrap the callback into a `GClosure`.
genClosure_ListBoxFilterFunc :: MonadIO m => ListBoxFilterFunc -> m (GClosure C_ListBoxFilterFunc)
genClosure_ListBoxFilterFunc cb = liftIO $ do
    let cb' = drop_closures_ListBoxFilterFunc cb
    let cb'' = wrap_ListBoxFilterFunc Nothing cb'
    mk_ListBoxFilterFunc cb'' >>= B.GClosure.newGClosure


-- | Wrap a `ListBoxFilterFunc` into a `C_ListBoxFilterFunc`.
wrap_ListBoxFilterFunc :: 
    Maybe (Ptr (FunPtr C_ListBoxFilterFunc)) ->
    ListBoxFilterFunc_WithClosures ->
    C_ListBoxFilterFunc
wrap_ListBoxFilterFunc gi'funptrptr gi'cb row userData = do
    row' <- (newObject Gtk.ListBoxRow.ListBoxRow) row
    result <- gi'cb  row' userData
    maybeReleaseFunPtr gi'funptrptr
    let result' = (fromIntegral . fromEnum) result
    return result'


-- callback ListBoxCreateWidgetFunc
{- Callable
  { returnType =
      Just (TInterface Name { namespace = "Gtk" , name = "Widget" })
  , returnMayBeNull = False
  , returnTransfer = TransferEverything
  , returnDocumentation =
      Documentation
        { rawDocText = Just "a #GtkWidget that represents @item"
        , sinceVersion = Nothing
        }
  , args =
      [ Arg
          { argCName = "item"
          , argType =
              TInterface Name { namespace = "GObject" , name = "Object" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText =
                    Just "the item from the model for which to create a widget for"
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "user_data"
          , argType = TBasicType TPtr
          , direction = DirectionIn
          , mayBeNull = True
          , argDoc =
              Documentation
                { rawDocText = Just "user data" , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = 1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation
        { rawDocText =
            Just
              "Called for list boxes that are bound to a #GListModel with\ngtk_list_box_bind_model() for each item that gets added to the model.\n\nVersions of GTK+ prior to 3.18 called gtk_widget_show_all() on the rows\ncreated by the GtkListBoxCreateWidgetFunc, but this forced all widgets\ninside the row to be shown, and is no longer the case. Applications should\nbe updated to show the desired row widgets."
        , sinceVersion = Just "3.16"
        }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_ListBoxCreateWidgetFunc =
    Ptr GObject.Object.Object ->
    Ptr () ->
    IO (Ptr Gtk.Widget.Widget)

-- Args: [ Arg
--           { argCName = "item"
--           , argType =
--               TInterface Name { namespace = "GObject" , name = "Object" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText =
--                     Just "the item from the model for which to create a widget for"
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "user_data"
--           , argType = TBasicType TPtr
--           , direction = DirectionIn
--           , mayBeNull = True
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "user data" , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = 1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Just (TInterface Name { namespace = "Gtk" , name = "Widget" })
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_ListBoxCreateWidgetFunc :: FunPtr C_ListBoxCreateWidgetFunc -> C_ListBoxCreateWidgetFunc

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_ListBoxCreateWidgetFunc ::
    (B.CallStack.HasCallStack, MonadIO m, GObject.Object.IsObject a) =>
    FunPtr C_ListBoxCreateWidgetFunc
    -> a
    -- ^ /@item@/: the item from the model for which to create a widget for
    -> Ptr ()
    -- ^ /@userData@/: user data
    -> m Gtk.Widget.Widget
    -- ^ __Returns:__ a t'GI.Gtk.Objects.Widget.Widget' that represents /@item@/
dynamic_ListBoxCreateWidgetFunc __funPtr item userData = liftIO $ do
    item' <- unsafeManagedPtrCastPtr item
    result <- (__dynamic_C_ListBoxCreateWidgetFunc __funPtr) item' userData
    checkUnexpectedReturnNULL "listBoxCreateWidgetFunc" result
    result' <- (wrapObject Gtk.Widget.Widget) result
    touchManagedPtr item
    return result'

-- | Generate a function pointer callable from C code, from a `C_ListBoxCreateWidgetFunc`.
foreign import ccall "wrapper"
    mk_ListBoxCreateWidgetFunc :: C_ListBoxCreateWidgetFunc -> IO (FunPtr C_ListBoxCreateWidgetFunc)

-- | Called for list boxes that are bound to a t'GI.Gio.Interfaces.ListModel.ListModel' with
-- 'GI.Gtk.Objects.ListBox.listBoxBindModel' for each item that gets added to the model.
-- 
-- Versions of GTK+ prior to 3.18 called 'GI.Gtk.Objects.Widget.widgetShowAll' on the rows
-- created by the GtkListBoxCreateWidgetFunc, but this forced all widgets
-- inside the row to be shown, and is no longer the case. Applications should
-- be updated to show the desired row widgets.
-- 
-- /Since: 3.16/
type ListBoxCreateWidgetFunc =
    GObject.Object.Object
    -- ^ /@item@/: the item from the model for which to create a widget for
    -> IO Gtk.Widget.Widget
    -- ^ __Returns:__ a t'GI.Gtk.Objects.Widget.Widget' that represents /@item@/

-- | A convenience synonym for @`Nothing` :: `Maybe` `ListBoxCreateWidgetFunc`@.
noListBoxCreateWidgetFunc :: Maybe ListBoxCreateWidgetFunc
noListBoxCreateWidgetFunc = Nothing

-- | Called for list boxes that are bound to a t'GI.Gio.Interfaces.ListModel.ListModel' with
-- 'GI.Gtk.Objects.ListBox.listBoxBindModel' for each item that gets added to the model.
-- 
-- Versions of GTK+ prior to 3.18 called 'GI.Gtk.Objects.Widget.widgetShowAll' on the rows
-- created by the GtkListBoxCreateWidgetFunc, but this forced all widgets
-- inside the row to be shown, and is no longer the case. Applications should
-- be updated to show the desired row widgets.
-- 
-- /Since: 3.16/
type ListBoxCreateWidgetFunc_WithClosures =
    GObject.Object.Object
    -- ^ /@item@/: the item from the model for which to create a widget for
    -> Ptr ()
    -- ^ /@userData@/: user data
    -> IO Gtk.Widget.Widget
    -- ^ __Returns:__ a t'GI.Gtk.Objects.Widget.Widget' that represents /@item@/

-- | A convenience synonym for @`Nothing` :: `Maybe` `ListBoxCreateWidgetFunc_WithClosures`@.
noListBoxCreateWidgetFunc_WithClosures :: Maybe ListBoxCreateWidgetFunc_WithClosures
noListBoxCreateWidgetFunc_WithClosures = Nothing

-- | A simple wrapper that ignores the closure arguments.
drop_closures_ListBoxCreateWidgetFunc :: ListBoxCreateWidgetFunc -> ListBoxCreateWidgetFunc_WithClosures
drop_closures_ListBoxCreateWidgetFunc _f item _ = _f item

-- | Wrap the callback into a `GClosure`.
genClosure_ListBoxCreateWidgetFunc :: MonadIO m => ListBoxCreateWidgetFunc -> m (GClosure C_ListBoxCreateWidgetFunc)
genClosure_ListBoxCreateWidgetFunc cb = liftIO $ do
    let cb' = drop_closures_ListBoxCreateWidgetFunc cb
    let cb'' = wrap_ListBoxCreateWidgetFunc Nothing cb'
    mk_ListBoxCreateWidgetFunc cb'' >>= B.GClosure.newGClosure


-- | Wrap a `ListBoxCreateWidgetFunc` into a `C_ListBoxCreateWidgetFunc`.
wrap_ListBoxCreateWidgetFunc :: 
    Maybe (Ptr (FunPtr C_ListBoxCreateWidgetFunc)) ->
    ListBoxCreateWidgetFunc_WithClosures ->
    C_ListBoxCreateWidgetFunc
wrap_ListBoxCreateWidgetFunc gi'funptrptr gi'cb item userData = do
    item' <- (newObject GObject.Object.Object) item
    result <- gi'cb  item' userData
    maybeReleaseFunPtr gi'funptrptr
    result' <- B.ManagedPtr.disownObject result
    return result'


-- callback KeySnoopFunc
{- Callable
  { returnType = Just (TBasicType TInt)
  , returnMayBeNull = False
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation
        { rawDocText =
            Just
              "%TRUE to stop further processing of @event, %FALSE to continue."
        , sinceVersion = Nothing
        }
  , args =
      [ Arg
          { argCName = "grab_widget"
          , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText =
                    Just "the widget to which the event will be delivered"
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "event"
          , argType =
              TInterface Name { namespace = "Gdk" , name = "EventKey" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText = Just "the key event" , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "func_data"
          , argType = TBasicType TPtr
          , direction = DirectionIn
          , mayBeNull = True
          , argDoc =
              Documentation
                { rawDocText = Just "data supplied to gtk_key_snooper_install()"
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = 2
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation
        { rawDocText =
            Just
              "Key snooper functions are called before normal event delivery.\nThey can be used to implement custom key event handling."
        , sinceVersion = Nothing
        }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_KeySnoopFunc =
    Ptr Gtk.Widget.Widget ->
    Ptr Gdk.EventKey.EventKey ->
    Ptr () ->
    IO Int32

-- Args: [ Arg
--           { argCName = "grab_widget"
--           , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText =
--                     Just "the widget to which the event will be delivered"
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "event"
--           , argType =
--               TInterface Name { namespace = "Gdk" , name = "EventKey" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "the key event" , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "func_data"
--           , argType = TBasicType TPtr
--           , direction = DirectionIn
--           , mayBeNull = True
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "data supplied to gtk_key_snooper_install()"
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = 2
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Just (TBasicType TInt)
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_KeySnoopFunc :: FunPtr C_KeySnoopFunc -> C_KeySnoopFunc

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_KeySnoopFunc ::
    (B.CallStack.HasCallStack, MonadIO m, Gtk.Widget.IsWidget a) =>
    FunPtr C_KeySnoopFunc
    -> a
    -- ^ /@grabWidget@/: the widget to which the event will be delivered
    -> Gdk.EventKey.EventKey
    -- ^ /@event@/: the key event
    -> Ptr ()
    -- ^ /@funcData@/: data supplied to @/gtk_key_snooper_install()/@
    -> m Int32
    -- ^ __Returns:__ 'P.True' to stop further processing of /@event@/, 'P.False' to continue.
dynamic_KeySnoopFunc __funPtr grabWidget event funcData = liftIO $ do
    grabWidget' <- unsafeManagedPtrCastPtr grabWidget
    event' <- unsafeManagedPtrGetPtr event
    result <- (__dynamic_C_KeySnoopFunc __funPtr) grabWidget' event' funcData
    touchManagedPtr grabWidget
    touchManagedPtr event
    return result

-- | Generate a function pointer callable from C code, from a `C_KeySnoopFunc`.
foreign import ccall "wrapper"
    mk_KeySnoopFunc :: C_KeySnoopFunc -> IO (FunPtr C_KeySnoopFunc)

-- | Key snooper functions are called before normal event delivery.
-- They can be used to implement custom key event handling.
type KeySnoopFunc =
    Gtk.Widget.Widget
    -- ^ /@grabWidget@/: the widget to which the event will be delivered
    -> Gdk.EventKey.EventKey
    -- ^ /@event@/: the key event
    -> IO Int32
    -- ^ __Returns:__ 'P.True' to stop further processing of /@event@/, 'P.False' to continue.

-- | A convenience synonym for @`Nothing` :: `Maybe` `KeySnoopFunc`@.
noKeySnoopFunc :: Maybe KeySnoopFunc
noKeySnoopFunc = Nothing

-- | Key snooper functions are called before normal event delivery.
-- They can be used to implement custom key event handling.
type KeySnoopFunc_WithClosures =
    Gtk.Widget.Widget
    -- ^ /@grabWidget@/: the widget to which the event will be delivered
    -> Gdk.EventKey.EventKey
    -- ^ /@event@/: the key event
    -> Ptr ()
    -- ^ /@funcData@/: data supplied to @/gtk_key_snooper_install()/@
    -> IO Int32
    -- ^ __Returns:__ 'P.True' to stop further processing of /@event@/, 'P.False' to continue.

-- | A convenience synonym for @`Nothing` :: `Maybe` `KeySnoopFunc_WithClosures`@.
noKeySnoopFunc_WithClosures :: Maybe KeySnoopFunc_WithClosures
noKeySnoopFunc_WithClosures = Nothing

-- | A simple wrapper that ignores the closure arguments.
drop_closures_KeySnoopFunc :: KeySnoopFunc -> KeySnoopFunc_WithClosures
drop_closures_KeySnoopFunc _f grabWidget event _ = _f grabWidget event

-- | Wrap the callback into a `GClosure`.
genClosure_KeySnoopFunc :: MonadIO m => KeySnoopFunc -> m (GClosure C_KeySnoopFunc)
genClosure_KeySnoopFunc cb = liftIO $ do
    let cb' = drop_closures_KeySnoopFunc cb
    let cb'' = wrap_KeySnoopFunc Nothing cb'
    mk_KeySnoopFunc cb'' >>= B.GClosure.newGClosure


-- | Wrap a `KeySnoopFunc` into a `C_KeySnoopFunc`.
wrap_KeySnoopFunc :: 
    Maybe (Ptr (FunPtr C_KeySnoopFunc)) ->
    KeySnoopFunc_WithClosures ->
    C_KeySnoopFunc
wrap_KeySnoopFunc gi'funptrptr gi'cb grabWidget event funcData = do
    grabWidget' <- (newObject Gtk.Widget.Widget) grabWidget
    event' <- (newPtr Gdk.EventKey.EventKey) event
    result <- gi'cb  grabWidget' event' funcData
    maybeReleaseFunPtr gi'funptrptr
    return result


-- callback IconViewForeachFunc
{- Callable
  { returnType = Nothing
  , returnMayBeNull = False
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , args =
      [ Arg
          { argCName = "icon_view"
          , argType =
              TInterface Name { namespace = "Gtk" , name = "IconView" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText = Just "a #GtkIconView" , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "path"
          , argType =
              TInterface Name { namespace = "Gtk" , name = "TreePath" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText = Just "The #GtkTreePath of a selected row"
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "data"
          , argType = TBasicType TPtr
          , direction = DirectionIn
          , mayBeNull = True
          , argDoc =
              Documentation
                { rawDocText = Just "user data" , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = 2
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation
        { rawDocText =
            Just
              "A function used by gtk_icon_view_selected_foreach() to map all\nselected rows.  It will be called on every selected row in the view."
        , sinceVersion = Nothing
        }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_IconViewForeachFunc =
    Ptr Gtk.IconView.IconView ->
    Ptr Gtk.TreePath.TreePath ->
    Ptr () ->
    IO ()

-- Args: [ Arg
--           { argCName = "icon_view"
--           , argType =
--               TInterface Name { namespace = "Gtk" , name = "IconView" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "a #GtkIconView" , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "path"
--           , argType =
--               TInterface Name { namespace = "Gtk" , name = "TreePath" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "The #GtkTreePath of a selected row"
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "data"
--           , argType = TBasicType TPtr
--           , direction = DirectionIn
--           , mayBeNull = True
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "user data" , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = 2
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Nothing
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_IconViewForeachFunc :: FunPtr C_IconViewForeachFunc -> C_IconViewForeachFunc

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_IconViewForeachFunc ::
    (B.CallStack.HasCallStack, MonadIO m, Gtk.IconView.IsIconView a) =>
    FunPtr C_IconViewForeachFunc
    -> a
    -- ^ /@iconView@/: a t'GI.Gtk.Objects.IconView.IconView'
    -> Gtk.TreePath.TreePath
    -- ^ /@path@/: The t'GI.Gtk.Structs.TreePath.TreePath' of a selected row
    -> Ptr ()
    -- ^ /@data@/: user data
    -> m ()
dynamic_IconViewForeachFunc __funPtr iconView path data_ = liftIO $ do
    iconView' <- unsafeManagedPtrCastPtr iconView
    path' <- unsafeManagedPtrGetPtr path
    (__dynamic_C_IconViewForeachFunc __funPtr) iconView' path' data_
    touchManagedPtr iconView
    touchManagedPtr path
    return ()

-- | Generate a function pointer callable from C code, from a `C_IconViewForeachFunc`.
foreign import ccall "wrapper"
    mk_IconViewForeachFunc :: C_IconViewForeachFunc -> IO (FunPtr C_IconViewForeachFunc)

-- | A function used by 'GI.Gtk.Objects.IconView.iconViewSelectedForeach' to map all
-- selected rows.  It will be called on every selected row in the view.
type IconViewForeachFunc =
    Gtk.IconView.IconView
    -- ^ /@iconView@/: a t'GI.Gtk.Objects.IconView.IconView'
    -> Gtk.TreePath.TreePath
    -- ^ /@path@/: The t'GI.Gtk.Structs.TreePath.TreePath' of a selected row
    -> IO ()

-- | A convenience synonym for @`Nothing` :: `Maybe` `IconViewForeachFunc`@.
noIconViewForeachFunc :: Maybe IconViewForeachFunc
noIconViewForeachFunc = Nothing

-- | A function used by 'GI.Gtk.Objects.IconView.iconViewSelectedForeach' to map all
-- selected rows.  It will be called on every selected row in the view.
type IconViewForeachFunc_WithClosures =
    Gtk.IconView.IconView
    -- ^ /@iconView@/: a t'GI.Gtk.Objects.IconView.IconView'
    -> Gtk.TreePath.TreePath
    -- ^ /@path@/: The t'GI.Gtk.Structs.TreePath.TreePath' of a selected row
    -> Ptr ()
    -- ^ /@data@/: user data
    -> IO ()

-- | A convenience synonym for @`Nothing` :: `Maybe` `IconViewForeachFunc_WithClosures`@.
noIconViewForeachFunc_WithClosures :: Maybe IconViewForeachFunc_WithClosures
noIconViewForeachFunc_WithClosures = Nothing

-- | A simple wrapper that ignores the closure arguments.
drop_closures_IconViewForeachFunc :: IconViewForeachFunc -> IconViewForeachFunc_WithClosures
drop_closures_IconViewForeachFunc _f iconView path _ = _f iconView path

-- | Wrap the callback into a `GClosure`.
genClosure_IconViewForeachFunc :: MonadIO m => IconViewForeachFunc -> m (GClosure C_IconViewForeachFunc)
genClosure_IconViewForeachFunc cb = liftIO $ do
    let cb' = drop_closures_IconViewForeachFunc cb
    let cb'' = wrap_IconViewForeachFunc Nothing cb'
    mk_IconViewForeachFunc cb'' >>= B.GClosure.newGClosure


-- | Wrap a `IconViewForeachFunc` into a `C_IconViewForeachFunc`.
wrap_IconViewForeachFunc :: 
    Maybe (Ptr (FunPtr C_IconViewForeachFunc)) ->
    IconViewForeachFunc_WithClosures ->
    C_IconViewForeachFunc
wrap_IconViewForeachFunc gi'funptrptr gi'cb iconView path data_ = do
    iconView' <- (newObject Gtk.IconView.IconView) iconView
    B.ManagedPtr.withTransient  path $ \path' -> do
        gi'cb  iconView' path' data_
        maybeReleaseFunPtr gi'funptrptr


-- callback FontFilterFunc
{- Callable
  { returnType = Just (TBasicType TBoolean)
  , returnMayBeNull = False
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation
        { rawDocText = Just "%TRUE if the font should be displayed"
        , sinceVersion = Nothing
        }
  , args =
      [ Arg
          { argCName = "family"
          , argType =
              TInterface Name { namespace = "Pango" , name = "FontFamily" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText = Just "a #PangoFontFamily" , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "face"
          , argType =
              TInterface Name { namespace = "Pango" , name = "FontFace" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText = Just "a #PangoFontFace belonging to @family"
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "data"
          , argType = TBasicType TPtr
          , direction = DirectionIn
          , mayBeNull = True
          , argDoc =
              Documentation
                { rawDocText =
                    Just "user data passed to gtk_font_chooser_set_filter_func()"
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = 2
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation
        { rawDocText =
            Just
              "The type of function that is used for deciding what fonts get\nshown in a #GtkFontChooser. See gtk_font_chooser_set_filter_func()."
        , sinceVersion = Nothing
        }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_FontFilterFunc =
    Ptr Pango.FontFamily.FontFamily ->
    Ptr Pango.FontFace.FontFace ->
    Ptr () ->
    IO CInt

-- Args: [ Arg
--           { argCName = "family"
--           , argType =
--               TInterface Name { namespace = "Pango" , name = "FontFamily" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "a #PangoFontFamily" , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "face"
--           , argType =
--               TInterface Name { namespace = "Pango" , name = "FontFace" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "a #PangoFontFace belonging to @family"
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "data"
--           , argType = TBasicType TPtr
--           , direction = DirectionIn
--           , mayBeNull = True
--           , argDoc =
--               Documentation
--                 { rawDocText =
--                     Just "user data passed to gtk_font_chooser_set_filter_func()"
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = 2
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Just (TBasicType TBoolean)
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_FontFilterFunc :: FunPtr C_FontFilterFunc -> C_FontFilterFunc

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_FontFilterFunc ::
    (B.CallStack.HasCallStack, MonadIO m, Pango.FontFamily.IsFontFamily a, Pango.FontFace.IsFontFace b) =>
    FunPtr C_FontFilterFunc
    -> a
    -- ^ /@family@/: a t'GI.Pango.Objects.FontFamily.FontFamily'
    -> b
    -- ^ /@face@/: a t'GI.Pango.Objects.FontFace.FontFace' belonging to /@family@/
    -> Ptr ()
    -- ^ /@data@/: user data passed to 'GI.Gtk.Interfaces.FontChooser.fontChooserSetFilterFunc'
    -> m Bool
    -- ^ __Returns:__ 'P.True' if the font should be displayed
dynamic_FontFilterFunc __funPtr family face data_ = liftIO $ do
    family' <- unsafeManagedPtrCastPtr family
    face' <- unsafeManagedPtrCastPtr face
    result <- (__dynamic_C_FontFilterFunc __funPtr) family' face' data_
    let result' = (/= 0) result
    touchManagedPtr family
    touchManagedPtr face
    return result'

-- | Generate a function pointer callable from C code, from a `C_FontFilterFunc`.
foreign import ccall "wrapper"
    mk_FontFilterFunc :: C_FontFilterFunc -> IO (FunPtr C_FontFilterFunc)

-- | The type of function that is used for deciding what fonts get
-- shown in a t'GI.Gtk.Interfaces.FontChooser.FontChooser'. See 'GI.Gtk.Interfaces.FontChooser.fontChooserSetFilterFunc'.
type FontFilterFunc =
    Pango.FontFamily.FontFamily
    -- ^ /@family@/: a t'GI.Pango.Objects.FontFamily.FontFamily'
    -> Pango.FontFace.FontFace
    -- ^ /@face@/: a t'GI.Pango.Objects.FontFace.FontFace' belonging to /@family@/
    -> IO Bool
    -- ^ __Returns:__ 'P.True' if the font should be displayed

-- | A convenience synonym for @`Nothing` :: `Maybe` `FontFilterFunc`@.
noFontFilterFunc :: Maybe FontFilterFunc
noFontFilterFunc = Nothing

-- | The type of function that is used for deciding what fonts get
-- shown in a t'GI.Gtk.Interfaces.FontChooser.FontChooser'. See 'GI.Gtk.Interfaces.FontChooser.fontChooserSetFilterFunc'.
type FontFilterFunc_WithClosures =
    Pango.FontFamily.FontFamily
    -- ^ /@family@/: a t'GI.Pango.Objects.FontFamily.FontFamily'
    -> Pango.FontFace.FontFace
    -- ^ /@face@/: a t'GI.Pango.Objects.FontFace.FontFace' belonging to /@family@/
    -> Ptr ()
    -- ^ /@data@/: user data passed to 'GI.Gtk.Interfaces.FontChooser.fontChooserSetFilterFunc'
    -> IO Bool
    -- ^ __Returns:__ 'P.True' if the font should be displayed

-- | A convenience synonym for @`Nothing` :: `Maybe` `FontFilterFunc_WithClosures`@.
noFontFilterFunc_WithClosures :: Maybe FontFilterFunc_WithClosures
noFontFilterFunc_WithClosures = Nothing

-- | A simple wrapper that ignores the closure arguments.
drop_closures_FontFilterFunc :: FontFilterFunc -> FontFilterFunc_WithClosures
drop_closures_FontFilterFunc _f family face _ = _f family face

-- | Wrap the callback into a `GClosure`.
genClosure_FontFilterFunc :: MonadIO m => FontFilterFunc -> m (GClosure C_FontFilterFunc)
genClosure_FontFilterFunc cb = liftIO $ do
    let cb' = drop_closures_FontFilterFunc cb
    let cb'' = wrap_FontFilterFunc Nothing cb'
    mk_FontFilterFunc cb'' >>= B.GClosure.newGClosure


-- | Wrap a `FontFilterFunc` into a `C_FontFilterFunc`.
wrap_FontFilterFunc :: 
    Maybe (Ptr (FunPtr C_FontFilterFunc)) ->
    FontFilterFunc_WithClosures ->
    C_FontFilterFunc
wrap_FontFilterFunc gi'funptrptr gi'cb family face data_ = do
    family' <- (newObject Pango.FontFamily.FontFamily) family
    face' <- (newObject Pango.FontFace.FontFace) face
    result <- gi'cb  family' face' data_
    maybeReleaseFunPtr gi'funptrptr
    let result' = (fromIntegral . fromEnum) result
    return result'


-- callback FlowBoxSortFunc
{- Callable
  { returnType = Just (TBasicType TInt)
  , returnMayBeNull = False
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation
        { rawDocText =
            Just
              "< 0 if @child1 should be before @child2, 0 if\n    the are equal, and > 0 otherwise"
        , sinceVersion = Nothing
        }
  , args =
      [ Arg
          { argCName = "child1"
          , argType =
              TInterface Name { namespace = "Gtk" , name = "FlowBoxChild" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText = Just "the first child" , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "child2"
          , argType =
              TInterface Name { namespace = "Gtk" , name = "FlowBoxChild" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText = Just "the second child" , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "user_data"
          , argType = TBasicType TPtr
          , direction = DirectionIn
          , mayBeNull = True
          , argDoc =
              Documentation
                { rawDocText = Just "user data" , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = 2
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation
        { rawDocText =
            Just
              "A function to compare two children to determine which\nshould come first."
        , sinceVersion = Just "3.12"
        }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_FlowBoxSortFunc =
    Ptr Gtk.FlowBoxChild.FlowBoxChild ->
    Ptr Gtk.FlowBoxChild.FlowBoxChild ->
    Ptr () ->
    IO Int32

-- Args: [ Arg
--           { argCName = "child1"
--           , argType =
--               TInterface Name { namespace = "Gtk" , name = "FlowBoxChild" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "the first child" , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "child2"
--           , argType =
--               TInterface Name { namespace = "Gtk" , name = "FlowBoxChild" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "the second child" , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "user_data"
--           , argType = TBasicType TPtr
--           , direction = DirectionIn
--           , mayBeNull = True
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "user data" , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = 2
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Just (TBasicType TInt)
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_FlowBoxSortFunc :: FunPtr C_FlowBoxSortFunc -> C_FlowBoxSortFunc

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_FlowBoxSortFunc ::
    (B.CallStack.HasCallStack, MonadIO m, Gtk.FlowBoxChild.IsFlowBoxChild a, Gtk.FlowBoxChild.IsFlowBoxChild b) =>
    FunPtr C_FlowBoxSortFunc
    -> a
    -- ^ /@child1@/: the first child
    -> b
    -- ^ /@child2@/: the second child
    -> Ptr ()
    -- ^ /@userData@/: user data
    -> m Int32
    -- ^ __Returns:__ \< 0 if /@child1@/ should be before /@child2@/, 0 if
    --     the are equal, and > 0 otherwise
dynamic_FlowBoxSortFunc __funPtr child1 child2 userData = liftIO $ do
    child1' <- unsafeManagedPtrCastPtr child1
    child2' <- unsafeManagedPtrCastPtr child2
    result <- (__dynamic_C_FlowBoxSortFunc __funPtr) child1' child2' userData
    touchManagedPtr child1
    touchManagedPtr child2
    return result

-- | Generate a function pointer callable from C code, from a `C_FlowBoxSortFunc`.
foreign import ccall "wrapper"
    mk_FlowBoxSortFunc :: C_FlowBoxSortFunc -> IO (FunPtr C_FlowBoxSortFunc)

-- | A function to compare two children to determine which
-- should come first.
-- 
-- /Since: 3.12/
type FlowBoxSortFunc =
    Gtk.FlowBoxChild.FlowBoxChild
    -- ^ /@child1@/: the first child
    -> Gtk.FlowBoxChild.FlowBoxChild
    -- ^ /@child2@/: the second child
    -> IO Int32
    -- ^ __Returns:__ \< 0 if /@child1@/ should be before /@child2@/, 0 if
    --     the are equal, and > 0 otherwise

-- | A convenience synonym for @`Nothing` :: `Maybe` `FlowBoxSortFunc`@.
noFlowBoxSortFunc :: Maybe FlowBoxSortFunc
noFlowBoxSortFunc = Nothing

-- | A function to compare two children to determine which
-- should come first.
-- 
-- /Since: 3.12/
type FlowBoxSortFunc_WithClosures =
    Gtk.FlowBoxChild.FlowBoxChild
    -- ^ /@child1@/: the first child
    -> Gtk.FlowBoxChild.FlowBoxChild
    -- ^ /@child2@/: the second child
    -> Ptr ()
    -- ^ /@userData@/: user data
    -> IO Int32
    -- ^ __Returns:__ \< 0 if /@child1@/ should be before /@child2@/, 0 if
    --     the are equal, and > 0 otherwise

-- | A convenience synonym for @`Nothing` :: `Maybe` `FlowBoxSortFunc_WithClosures`@.
noFlowBoxSortFunc_WithClosures :: Maybe FlowBoxSortFunc_WithClosures
noFlowBoxSortFunc_WithClosures = Nothing

-- | A simple wrapper that ignores the closure arguments.
drop_closures_FlowBoxSortFunc :: FlowBoxSortFunc -> FlowBoxSortFunc_WithClosures
drop_closures_FlowBoxSortFunc _f child1 child2 _ = _f child1 child2

-- | Wrap the callback into a `GClosure`.
genClosure_FlowBoxSortFunc :: MonadIO m => FlowBoxSortFunc -> m (GClosure C_FlowBoxSortFunc)
genClosure_FlowBoxSortFunc cb = liftIO $ do
    let cb' = drop_closures_FlowBoxSortFunc cb
    let cb'' = wrap_FlowBoxSortFunc Nothing cb'
    mk_FlowBoxSortFunc cb'' >>= B.GClosure.newGClosure


-- | Wrap a `FlowBoxSortFunc` into a `C_FlowBoxSortFunc`.
wrap_FlowBoxSortFunc :: 
    Maybe (Ptr (FunPtr C_FlowBoxSortFunc)) ->
    FlowBoxSortFunc_WithClosures ->
    C_FlowBoxSortFunc
wrap_FlowBoxSortFunc gi'funptrptr gi'cb child1 child2 userData = do
    child1' <- (newObject Gtk.FlowBoxChild.FlowBoxChild) child1
    child2' <- (newObject Gtk.FlowBoxChild.FlowBoxChild) child2
    result <- gi'cb  child1' child2' userData
    maybeReleaseFunPtr gi'funptrptr
    return result


-- callback FlowBoxForeachFunc
{- Callable
  { returnType = Nothing
  , returnMayBeNull = False
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , args =
      [ Arg
          { argCName = "box"
          , argType =
              TInterface Name { namespace = "Gtk" , name = "FlowBox" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText = Just "a #GtkFlowBox" , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "child"
          , argType =
              TInterface Name { namespace = "Gtk" , name = "FlowBoxChild" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText = Just "a #GtkFlowBoxChild" , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "user_data"
          , argType = TBasicType TPtr
          , direction = DirectionIn
          , mayBeNull = True
          , argDoc =
              Documentation
                { rawDocText = Just "user data" , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = 2
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation
        { rawDocText =
            Just
              "A function used by gtk_flow_box_selected_foreach().\nIt will be called on every selected child of the @box."
        , sinceVersion = Just "3.12"
        }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_FlowBoxForeachFunc =
    Ptr Gtk.FlowBox.FlowBox ->
    Ptr Gtk.FlowBoxChild.FlowBoxChild ->
    Ptr () ->
    IO ()

-- Args: [ Arg
--           { argCName = "box"
--           , argType =
--               TInterface Name { namespace = "Gtk" , name = "FlowBox" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "a #GtkFlowBox" , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "child"
--           , argType =
--               TInterface Name { namespace = "Gtk" , name = "FlowBoxChild" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "a #GtkFlowBoxChild" , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "user_data"
--           , argType = TBasicType TPtr
--           , direction = DirectionIn
--           , mayBeNull = True
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "user data" , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = 2
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Nothing
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_FlowBoxForeachFunc :: FunPtr C_FlowBoxForeachFunc -> C_FlowBoxForeachFunc

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_FlowBoxForeachFunc ::
    (B.CallStack.HasCallStack, MonadIO m, Gtk.FlowBox.IsFlowBox a, Gtk.FlowBoxChild.IsFlowBoxChild b) =>
    FunPtr C_FlowBoxForeachFunc
    -> a
    -- ^ /@box@/: a t'GI.Gtk.Objects.FlowBox.FlowBox'
    -> b
    -- ^ /@child@/: a t'GI.Gtk.Objects.FlowBoxChild.FlowBoxChild'
    -> Ptr ()
    -- ^ /@userData@/: user data
    -> m ()
dynamic_FlowBoxForeachFunc __funPtr box child userData = liftIO $ do
    box' <- unsafeManagedPtrCastPtr box
    child' <- unsafeManagedPtrCastPtr child
    (__dynamic_C_FlowBoxForeachFunc __funPtr) box' child' userData
    touchManagedPtr box
    touchManagedPtr child
    return ()

-- | Generate a function pointer callable from C code, from a `C_FlowBoxForeachFunc`.
foreign import ccall "wrapper"
    mk_FlowBoxForeachFunc :: C_FlowBoxForeachFunc -> IO (FunPtr C_FlowBoxForeachFunc)

-- | A function used by 'GI.Gtk.Objects.FlowBox.flowBoxSelectedForeach'.
-- It will be called on every selected child of the /@box@/.
-- 
-- /Since: 3.12/
type FlowBoxForeachFunc =
    Gtk.FlowBox.FlowBox
    -- ^ /@box@/: a t'GI.Gtk.Objects.FlowBox.FlowBox'
    -> Gtk.FlowBoxChild.FlowBoxChild
    -- ^ /@child@/: a t'GI.Gtk.Objects.FlowBoxChild.FlowBoxChild'
    -> IO ()

-- | A convenience synonym for @`Nothing` :: `Maybe` `FlowBoxForeachFunc`@.
noFlowBoxForeachFunc :: Maybe FlowBoxForeachFunc
noFlowBoxForeachFunc = Nothing

-- | A function used by 'GI.Gtk.Objects.FlowBox.flowBoxSelectedForeach'.
-- It will be called on every selected child of the /@box@/.
-- 
-- /Since: 3.12/
type FlowBoxForeachFunc_WithClosures =
    Gtk.FlowBox.FlowBox
    -- ^ /@box@/: a t'GI.Gtk.Objects.FlowBox.FlowBox'
    -> Gtk.FlowBoxChild.FlowBoxChild
    -- ^ /@child@/: a t'GI.Gtk.Objects.FlowBoxChild.FlowBoxChild'
    -> Ptr ()
    -- ^ /@userData@/: user data
    -> IO ()

-- | A convenience synonym for @`Nothing` :: `Maybe` `FlowBoxForeachFunc_WithClosures`@.
noFlowBoxForeachFunc_WithClosures :: Maybe FlowBoxForeachFunc_WithClosures
noFlowBoxForeachFunc_WithClosures = Nothing

-- | A simple wrapper that ignores the closure arguments.
drop_closures_FlowBoxForeachFunc :: FlowBoxForeachFunc -> FlowBoxForeachFunc_WithClosures
drop_closures_FlowBoxForeachFunc _f box child _ = _f box child

-- | Wrap the callback into a `GClosure`.
genClosure_FlowBoxForeachFunc :: MonadIO m => FlowBoxForeachFunc -> m (GClosure C_FlowBoxForeachFunc)
genClosure_FlowBoxForeachFunc cb = liftIO $ do
    let cb' = drop_closures_FlowBoxForeachFunc cb
    let cb'' = wrap_FlowBoxForeachFunc Nothing cb'
    mk_FlowBoxForeachFunc cb'' >>= B.GClosure.newGClosure


-- | Wrap a `FlowBoxForeachFunc` into a `C_FlowBoxForeachFunc`.
wrap_FlowBoxForeachFunc :: 
    Maybe (Ptr (FunPtr C_FlowBoxForeachFunc)) ->
    FlowBoxForeachFunc_WithClosures ->
    C_FlowBoxForeachFunc
wrap_FlowBoxForeachFunc gi'funptrptr gi'cb box child userData = do
    box' <- (newObject Gtk.FlowBox.FlowBox) box
    child' <- (newObject Gtk.FlowBoxChild.FlowBoxChild) child
    gi'cb  box' child' userData
    maybeReleaseFunPtr gi'funptrptr


-- callback FlowBoxFilterFunc
{- Callable
  { returnType = Just (TBasicType TBoolean)
  , returnMayBeNull = False
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation
        { rawDocText =
            Just "%TRUE if the row should be visible, %FALSE otherwise"
        , sinceVersion = Nothing
        }
  , args =
      [ Arg
          { argCName = "child"
          , argType =
              TInterface Name { namespace = "Gtk" , name = "FlowBoxChild" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText = Just "a #GtkFlowBoxChild that may be filtered"
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "user_data"
          , argType = TBasicType TPtr
          , direction = DirectionIn
          , mayBeNull = True
          , argDoc =
              Documentation
                { rawDocText = Just "user data" , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = 1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation
        { rawDocText =
            Just
              "A function that will be called whenrever a child changes\nor is added. It lets you control if the child should be\nvisible or not."
        , sinceVersion = Just "3.12"
        }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_FlowBoxFilterFunc =
    Ptr Gtk.FlowBoxChild.FlowBoxChild ->
    Ptr () ->
    IO CInt

-- Args: [ Arg
--           { argCName = "child"
--           , argType =
--               TInterface Name { namespace = "Gtk" , name = "FlowBoxChild" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "a #GtkFlowBoxChild that may be filtered"
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "user_data"
--           , argType = TBasicType TPtr
--           , direction = DirectionIn
--           , mayBeNull = True
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "user data" , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = 1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Just (TBasicType TBoolean)
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_FlowBoxFilterFunc :: FunPtr C_FlowBoxFilterFunc -> C_FlowBoxFilterFunc

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_FlowBoxFilterFunc ::
    (B.CallStack.HasCallStack, MonadIO m, Gtk.FlowBoxChild.IsFlowBoxChild a) =>
    FunPtr C_FlowBoxFilterFunc
    -> a
    -- ^ /@child@/: a t'GI.Gtk.Objects.FlowBoxChild.FlowBoxChild' that may be filtered
    -> Ptr ()
    -- ^ /@userData@/: user data
    -> m Bool
    -- ^ __Returns:__ 'P.True' if the row should be visible, 'P.False' otherwise
dynamic_FlowBoxFilterFunc __funPtr child userData = liftIO $ do
    child' <- unsafeManagedPtrCastPtr child
    result <- (__dynamic_C_FlowBoxFilterFunc __funPtr) child' userData
    let result' = (/= 0) result
    touchManagedPtr child
    return result'

-- | Generate a function pointer callable from C code, from a `C_FlowBoxFilterFunc`.
foreign import ccall "wrapper"
    mk_FlowBoxFilterFunc :: C_FlowBoxFilterFunc -> IO (FunPtr C_FlowBoxFilterFunc)

-- | A function that will be called whenrever a child changes
-- or is added. It lets you control if the child should be
-- visible or not.
-- 
-- /Since: 3.12/
type FlowBoxFilterFunc =
    Gtk.FlowBoxChild.FlowBoxChild
    -- ^ /@child@/: a t'GI.Gtk.Objects.FlowBoxChild.FlowBoxChild' that may be filtered
    -> IO Bool
    -- ^ __Returns:__ 'P.True' if the row should be visible, 'P.False' otherwise

-- | A convenience synonym for @`Nothing` :: `Maybe` `FlowBoxFilterFunc`@.
noFlowBoxFilterFunc :: Maybe FlowBoxFilterFunc
noFlowBoxFilterFunc = Nothing

-- | A function that will be called whenrever a child changes
-- or is added. It lets you control if the child should be
-- visible or not.
-- 
-- /Since: 3.12/
type FlowBoxFilterFunc_WithClosures =
    Gtk.FlowBoxChild.FlowBoxChild
    -- ^ /@child@/: a t'GI.Gtk.Objects.FlowBoxChild.FlowBoxChild' that may be filtered
    -> Ptr ()
    -- ^ /@userData@/: user data
    -> IO Bool
    -- ^ __Returns:__ 'P.True' if the row should be visible, 'P.False' otherwise

-- | A convenience synonym for @`Nothing` :: `Maybe` `FlowBoxFilterFunc_WithClosures`@.
noFlowBoxFilterFunc_WithClosures :: Maybe FlowBoxFilterFunc_WithClosures
noFlowBoxFilterFunc_WithClosures = Nothing

-- | A simple wrapper that ignores the closure arguments.
drop_closures_FlowBoxFilterFunc :: FlowBoxFilterFunc -> FlowBoxFilterFunc_WithClosures
drop_closures_FlowBoxFilterFunc _f child _ = _f child

-- | Wrap the callback into a `GClosure`.
genClosure_FlowBoxFilterFunc :: MonadIO m => FlowBoxFilterFunc -> m (GClosure C_FlowBoxFilterFunc)
genClosure_FlowBoxFilterFunc cb = liftIO $ do
    let cb' = drop_closures_FlowBoxFilterFunc cb
    let cb'' = wrap_FlowBoxFilterFunc Nothing cb'
    mk_FlowBoxFilterFunc cb'' >>= B.GClosure.newGClosure


-- | Wrap a `FlowBoxFilterFunc` into a `C_FlowBoxFilterFunc`.
wrap_FlowBoxFilterFunc :: 
    Maybe (Ptr (FunPtr C_FlowBoxFilterFunc)) ->
    FlowBoxFilterFunc_WithClosures ->
    C_FlowBoxFilterFunc
wrap_FlowBoxFilterFunc gi'funptrptr gi'cb child userData = do
    child' <- (newObject Gtk.FlowBoxChild.FlowBoxChild) child
    result <- gi'cb  child' userData
    maybeReleaseFunPtr gi'funptrptr
    let result' = (fromIntegral . fromEnum) result
    return result'


-- callback FlowBoxCreateWidgetFunc
{- Callable
  { returnType =
      Just (TInterface Name { namespace = "Gtk" , name = "Widget" })
  , returnMayBeNull = False
  , returnTransfer = TransferEverything
  , returnDocumentation =
      Documentation
        { rawDocText = Just "a #GtkWidget that represents @item"
        , sinceVersion = Nothing
        }
  , args =
      [ Arg
          { argCName = "item"
          , argType =
              TInterface Name { namespace = "GObject" , name = "Object" }
          , direction = DirectionIn
          , mayBeNull = True
          , argDoc =
              Documentation
                { rawDocText =
                    Just "the item from the model for which to create a widget for"
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "user_data"
          , argType = TBasicType TPtr
          , direction = DirectionIn
          , mayBeNull = True
          , argDoc =
              Documentation
                { rawDocText = Just "user data from gtk_flow_box_bind_model()"
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = 1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation
        { rawDocText =
            Just
              "Called for flow boxes that are bound to a #GListModel with\ngtk_flow_box_bind_model() for each item that gets added to the model."
        , sinceVersion = Just "3.18"
        }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_FlowBoxCreateWidgetFunc =
    Ptr GObject.Object.Object ->
    Ptr () ->
    IO (Ptr Gtk.Widget.Widget)

-- Args: [ Arg
--           { argCName = "item"
--           , argType =
--               TInterface Name { namespace = "GObject" , name = "Object" }
--           , direction = DirectionIn
--           , mayBeNull = True
--           , argDoc =
--               Documentation
--                 { rawDocText =
--                     Just "the item from the model for which to create a widget for"
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "user_data"
--           , argType = TBasicType TPtr
--           , direction = DirectionIn
--           , mayBeNull = True
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "user data from gtk_flow_box_bind_model()"
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = 1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Just (TInterface Name { namespace = "Gtk" , name = "Widget" })
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_FlowBoxCreateWidgetFunc :: FunPtr C_FlowBoxCreateWidgetFunc -> C_FlowBoxCreateWidgetFunc

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_FlowBoxCreateWidgetFunc ::
    (B.CallStack.HasCallStack, MonadIO m, GObject.Object.IsObject a) =>
    FunPtr C_FlowBoxCreateWidgetFunc
    -> Maybe (a)
    -- ^ /@item@/: the item from the model for which to create a widget for
    -> Ptr ()
    -- ^ /@userData@/: user data from 'GI.Gtk.Objects.FlowBox.flowBoxBindModel'
    -> m Gtk.Widget.Widget
    -- ^ __Returns:__ a t'GI.Gtk.Objects.Widget.Widget' that represents /@item@/
dynamic_FlowBoxCreateWidgetFunc __funPtr item userData = liftIO $ do
    maybeItem <- case item of
        Nothing -> return nullPtr
        Just jItem -> do
            jItem' <- unsafeManagedPtrCastPtr jItem
            return jItem'
    result <- (__dynamic_C_FlowBoxCreateWidgetFunc __funPtr) maybeItem userData
    checkUnexpectedReturnNULL "flowBoxCreateWidgetFunc" result
    result' <- (wrapObject Gtk.Widget.Widget) result
    whenJust item touchManagedPtr
    return result'

-- | Generate a function pointer callable from C code, from a `C_FlowBoxCreateWidgetFunc`.
foreign import ccall "wrapper"
    mk_FlowBoxCreateWidgetFunc :: C_FlowBoxCreateWidgetFunc -> IO (FunPtr C_FlowBoxCreateWidgetFunc)

-- | Called for flow boxes that are bound to a t'GI.Gio.Interfaces.ListModel.ListModel' with
-- 'GI.Gtk.Objects.FlowBox.flowBoxBindModel' for each item that gets added to the model.
-- 
-- /Since: 3.18/
type FlowBoxCreateWidgetFunc =
    Maybe GObject.Object.Object
    -- ^ /@item@/: the item from the model for which to create a widget for
    -> IO Gtk.Widget.Widget
    -- ^ __Returns:__ a t'GI.Gtk.Objects.Widget.Widget' that represents /@item@/

-- | A convenience synonym for @`Nothing` :: `Maybe` `FlowBoxCreateWidgetFunc`@.
noFlowBoxCreateWidgetFunc :: Maybe FlowBoxCreateWidgetFunc
noFlowBoxCreateWidgetFunc = Nothing

-- | Called for flow boxes that are bound to a t'GI.Gio.Interfaces.ListModel.ListModel' with
-- 'GI.Gtk.Objects.FlowBox.flowBoxBindModel' for each item that gets added to the model.
-- 
-- /Since: 3.18/
type FlowBoxCreateWidgetFunc_WithClosures =
    Maybe GObject.Object.Object
    -- ^ /@item@/: the item from the model for which to create a widget for
    -> Ptr ()
    -- ^ /@userData@/: user data from 'GI.Gtk.Objects.FlowBox.flowBoxBindModel'
    -> IO Gtk.Widget.Widget
    -- ^ __Returns:__ a t'GI.Gtk.Objects.Widget.Widget' that represents /@item@/

-- | A convenience synonym for @`Nothing` :: `Maybe` `FlowBoxCreateWidgetFunc_WithClosures`@.
noFlowBoxCreateWidgetFunc_WithClosures :: Maybe FlowBoxCreateWidgetFunc_WithClosures
noFlowBoxCreateWidgetFunc_WithClosures = Nothing

-- | A simple wrapper that ignores the closure arguments.
drop_closures_FlowBoxCreateWidgetFunc :: FlowBoxCreateWidgetFunc -> FlowBoxCreateWidgetFunc_WithClosures
drop_closures_FlowBoxCreateWidgetFunc _f item _ = _f item

-- | Wrap the callback into a `GClosure`.
genClosure_FlowBoxCreateWidgetFunc :: MonadIO m => FlowBoxCreateWidgetFunc -> m (GClosure C_FlowBoxCreateWidgetFunc)
genClosure_FlowBoxCreateWidgetFunc cb = liftIO $ do
    let cb' = drop_closures_FlowBoxCreateWidgetFunc cb
    let cb'' = wrap_FlowBoxCreateWidgetFunc Nothing cb'
    mk_FlowBoxCreateWidgetFunc cb'' >>= B.GClosure.newGClosure


-- | Wrap a `FlowBoxCreateWidgetFunc` into a `C_FlowBoxCreateWidgetFunc`.
wrap_FlowBoxCreateWidgetFunc :: 
    Maybe (Ptr (FunPtr C_FlowBoxCreateWidgetFunc)) ->
    FlowBoxCreateWidgetFunc_WithClosures ->
    C_FlowBoxCreateWidgetFunc
wrap_FlowBoxCreateWidgetFunc gi'funptrptr gi'cb item userData = do
    maybeItem <-
        if item == nullPtr
        then return Nothing
        else do
            item' <- (newObject GObject.Object.Object) item
            return $ Just item'
    result <- gi'cb  maybeItem userData
    maybeReleaseFunPtr gi'funptrptr
    result' <- B.ManagedPtr.disownObject result
    return result'


-- callback FileFilterFunc
{- Callable
  { returnType = Just (TBasicType TBoolean)
  , returnMayBeNull = False
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation
        { rawDocText = Just "%TRUE if the file should be displayed"
        , sinceVersion = Nothing
        }
  , args =
      [ Arg
          { argCName = "filter_info"
          , argType =
              TInterface Name { namespace = "Gtk" , name = "FileFilterInfo" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText =
                    Just
                      "a #GtkFileFilterInfo that is filled according\n  to the @needed flags passed to gtk_file_filter_add_custom()"
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "data"
          , argType = TBasicType TPtr
          , direction = DirectionIn
          , mayBeNull = True
          , argDoc =
              Documentation
                { rawDocText =
                    Just "user data passed to gtk_file_filter_add_custom()"
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = 1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation
        { rawDocText =
            Just
              "The type of function that is used with custom filters, see\ngtk_file_filter_add_custom()."
        , sinceVersion = Nothing
        }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_FileFilterFunc =
    Ptr Gtk.FileFilterInfo.FileFilterInfo ->
    Ptr () ->
    IO CInt

-- Args: [ Arg
--           { argCName = "filter_info"
--           , argType =
--               TInterface Name { namespace = "Gtk" , name = "FileFilterInfo" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText =
--                     Just
--                       "a #GtkFileFilterInfo that is filled according\n  to the @needed flags passed to gtk_file_filter_add_custom()"
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "data"
--           , argType = TBasicType TPtr
--           , direction = DirectionIn
--           , mayBeNull = True
--           , argDoc =
--               Documentation
--                 { rawDocText =
--                     Just "user data passed to gtk_file_filter_add_custom()"
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = 1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Just (TBasicType TBoolean)
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_FileFilterFunc :: FunPtr C_FileFilterFunc -> C_FileFilterFunc

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_FileFilterFunc ::
    (B.CallStack.HasCallStack, MonadIO m) =>
    FunPtr C_FileFilterFunc
    -> Gtk.FileFilterInfo.FileFilterInfo
    -- ^ /@filterInfo@/: a t'GI.Gtk.Structs.FileFilterInfo.FileFilterInfo' that is filled according
    --   to the /@needed@/ flags passed to 'GI.Gtk.Objects.FileFilter.fileFilterAddCustom'
    -> Ptr ()
    -- ^ /@data@/: user data passed to 'GI.Gtk.Objects.FileFilter.fileFilterAddCustom'
    -> m Bool
    -- ^ __Returns:__ 'P.True' if the file should be displayed
dynamic_FileFilterFunc __funPtr filterInfo data_ = liftIO $ do
    filterInfo' <- unsafeManagedPtrGetPtr filterInfo
    result <- (__dynamic_C_FileFilterFunc __funPtr) filterInfo' data_
    let result' = (/= 0) result
    touchManagedPtr filterInfo
    return result'

-- | Generate a function pointer callable from C code, from a `C_FileFilterFunc`.
foreign import ccall "wrapper"
    mk_FileFilterFunc :: C_FileFilterFunc -> IO (FunPtr C_FileFilterFunc)

-- | The type of function that is used with custom filters, see
-- 'GI.Gtk.Objects.FileFilter.fileFilterAddCustom'.
type FileFilterFunc =
    Gtk.FileFilterInfo.FileFilterInfo
    -- ^ /@filterInfo@/: a t'GI.Gtk.Structs.FileFilterInfo.FileFilterInfo' that is filled according
    --   to the /@needed@/ flags passed to 'GI.Gtk.Objects.FileFilter.fileFilterAddCustom'
    -> IO Bool
    -- ^ __Returns:__ 'P.True' if the file should be displayed

-- | A convenience synonym for @`Nothing` :: `Maybe` `FileFilterFunc`@.
noFileFilterFunc :: Maybe FileFilterFunc
noFileFilterFunc = Nothing

-- | The type of function that is used with custom filters, see
-- 'GI.Gtk.Objects.FileFilter.fileFilterAddCustom'.
type FileFilterFunc_WithClosures =
    Gtk.FileFilterInfo.FileFilterInfo
    -- ^ /@filterInfo@/: a t'GI.Gtk.Structs.FileFilterInfo.FileFilterInfo' that is filled according
    --   to the /@needed@/ flags passed to 'GI.Gtk.Objects.FileFilter.fileFilterAddCustom'
    -> Ptr ()
    -- ^ /@data@/: user data passed to 'GI.Gtk.Objects.FileFilter.fileFilterAddCustom'
    -> IO Bool
    -- ^ __Returns:__ 'P.True' if the file should be displayed

-- | A convenience synonym for @`Nothing` :: `Maybe` `FileFilterFunc_WithClosures`@.
noFileFilterFunc_WithClosures :: Maybe FileFilterFunc_WithClosures
noFileFilterFunc_WithClosures = Nothing

-- | A simple wrapper that ignores the closure arguments.
drop_closures_FileFilterFunc :: FileFilterFunc -> FileFilterFunc_WithClosures
drop_closures_FileFilterFunc _f filterInfo _ = _f filterInfo

-- | Wrap the callback into a `GClosure`.
genClosure_FileFilterFunc :: MonadIO m => FileFilterFunc -> m (GClosure C_FileFilterFunc)
genClosure_FileFilterFunc cb = liftIO $ do
    let cb' = drop_closures_FileFilterFunc cb
    let cb'' = wrap_FileFilterFunc Nothing cb'
    mk_FileFilterFunc cb'' >>= B.GClosure.newGClosure


-- | Wrap a `FileFilterFunc` into a `C_FileFilterFunc`.
wrap_FileFilterFunc :: 
    Maybe (Ptr (FunPtr C_FileFilterFunc)) ->
    FileFilterFunc_WithClosures ->
    C_FileFilterFunc
wrap_FileFilterFunc gi'funptrptr gi'cb filterInfo data_ = do
    filterInfo' <- (newPtr Gtk.FileFilterInfo.FileFilterInfo) filterInfo
    result <- gi'cb  filterInfo' data_
    maybeReleaseFunPtr gi'funptrptr
    let result' = (fromIntegral . fromEnum) result
    return result'


-- callback EntryCompletionMatchFunc
{- Callable
  { returnType = Just (TBasicType TBoolean)
  , returnMayBeNull = False
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation
        { rawDocText =
            Just
              "%TRUE if @iter should be displayed as a possible completion\n    for @key"
        , sinceVersion = Nothing
        }
  , args =
      [ Arg
          { argCName = "completion"
          , argType =
              TInterface Name { namespace = "Gtk" , name = "EntryCompletion" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText = Just "the #GtkEntryCompletion"
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "key"
          , argType = TBasicType TUTF8
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText =
                    Just "the string to match, normalized and case-folded"
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "iter"
          , argType =
              TInterface Name { namespace = "Gtk" , name = "TreeIter" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText = Just "a #GtkTreeIter indicating the row to match"
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "user_data"
          , argType = TBasicType TPtr
          , direction = DirectionIn
          , mayBeNull = True
          , argDoc =
              Documentation
                { rawDocText =
                    Just "user data given to gtk_entry_completion_set_match_func()"
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = 3
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation
        { rawDocText =
            Just
              "A function which decides whether the row indicated by @iter matches\na given @key, and should be displayed as a possible completion for @key.\nNote that @key is normalized and case-folded (see g_utf8_normalize()\nand g_utf8_casefold()). If this is not appropriate, match functions\nhave access to the unmodified key via\n`gtk_entry_get_text (GTK_ENTRY (gtk_entry_completion_get_entry ()))`."
        , sinceVersion = Nothing
        }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_EntryCompletionMatchFunc =
    Ptr Gtk.EntryCompletion.EntryCompletion ->
    CString ->
    Ptr Gtk.TreeIter.TreeIter ->
    Ptr () ->
    IO CInt

-- Args: [ Arg
--           { argCName = "completion"
--           , argType =
--               TInterface Name { namespace = "Gtk" , name = "EntryCompletion" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "the #GtkEntryCompletion"
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "key"
--           , argType = TBasicType TUTF8
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText =
--                     Just "the string to match, normalized and case-folded"
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "iter"
--           , argType =
--               TInterface Name { namespace = "Gtk" , name = "TreeIter" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "a #GtkTreeIter indicating the row to match"
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "user_data"
--           , argType = TBasicType TPtr
--           , direction = DirectionIn
--           , mayBeNull = True
--           , argDoc =
--               Documentation
--                 { rawDocText =
--                     Just "user data given to gtk_entry_completion_set_match_func()"
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = 3
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Just (TBasicType TBoolean)
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_EntryCompletionMatchFunc :: FunPtr C_EntryCompletionMatchFunc -> C_EntryCompletionMatchFunc

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_EntryCompletionMatchFunc ::
    (B.CallStack.HasCallStack, MonadIO m, Gtk.EntryCompletion.IsEntryCompletion a) =>
    FunPtr C_EntryCompletionMatchFunc
    -> a
    -- ^ /@completion@/: the t'GI.Gtk.Objects.EntryCompletion.EntryCompletion'
    -> T.Text
    -- ^ /@key@/: the string to match, normalized and case-folded
    -> Gtk.TreeIter.TreeIter
    -- ^ /@iter@/: a t'GI.Gtk.Structs.TreeIter.TreeIter' indicating the row to match
    -> Ptr ()
    -- ^ /@userData@/: user data given to 'GI.Gtk.Objects.EntryCompletion.entryCompletionSetMatchFunc'
    -> m Bool
    -- ^ __Returns:__ 'P.True' if /@iter@/ should be displayed as a possible completion
    --     for /@key@/
dynamic_EntryCompletionMatchFunc __funPtr completion key iter userData = liftIO $ do
    completion' <- unsafeManagedPtrCastPtr completion
    key' <- textToCString key
    iter' <- unsafeManagedPtrGetPtr iter
    result <- (__dynamic_C_EntryCompletionMatchFunc __funPtr) completion' key' iter' userData
    let result' = (/= 0) result
    touchManagedPtr completion
    touchManagedPtr iter
    freeMem key'
    return result'

-- | Generate a function pointer callable from C code, from a `C_EntryCompletionMatchFunc`.
foreign import ccall "wrapper"
    mk_EntryCompletionMatchFunc :: C_EntryCompletionMatchFunc -> IO (FunPtr C_EntryCompletionMatchFunc)

-- | A function which decides whether the row indicated by /@iter@/ matches
-- a given /@key@/, and should be displayed as a possible completion for /@key@/.
-- Note that /@key@/ is normalized and case-folded (see 'GI.GLib.Functions.utf8Normalize'
-- and 'GI.GLib.Functions.utf8Casefold'). If this is not appropriate, match functions
-- have access to the unmodified key via
-- @gtk_entry_get_text (GTK_ENTRY (gtk_entry_completion_get_entry ()))@.
type EntryCompletionMatchFunc =
    Gtk.EntryCompletion.EntryCompletion
    -- ^ /@completion@/: the t'GI.Gtk.Objects.EntryCompletion.EntryCompletion'
    -> T.Text
    -- ^ /@key@/: the string to match, normalized and case-folded
    -> Gtk.TreeIter.TreeIter
    -- ^ /@iter@/: a t'GI.Gtk.Structs.TreeIter.TreeIter' indicating the row to match
    -> IO Bool
    -- ^ __Returns:__ 'P.True' if /@iter@/ should be displayed as a possible completion
    --     for /@key@/

-- | A convenience synonym for @`Nothing` :: `Maybe` `EntryCompletionMatchFunc`@.
noEntryCompletionMatchFunc :: Maybe EntryCompletionMatchFunc
noEntryCompletionMatchFunc = Nothing

-- | A function which decides whether the row indicated by /@iter@/ matches
-- a given /@key@/, and should be displayed as a possible completion for /@key@/.
-- Note that /@key@/ is normalized and case-folded (see 'GI.GLib.Functions.utf8Normalize'
-- and 'GI.GLib.Functions.utf8Casefold'). If this is not appropriate, match functions
-- have access to the unmodified key via
-- @gtk_entry_get_text (GTK_ENTRY (gtk_entry_completion_get_entry ()))@.
type EntryCompletionMatchFunc_WithClosures =
    Gtk.EntryCompletion.EntryCompletion
    -- ^ /@completion@/: the t'GI.Gtk.Objects.EntryCompletion.EntryCompletion'
    -> T.Text
    -- ^ /@key@/: the string to match, normalized and case-folded
    -> Gtk.TreeIter.TreeIter
    -- ^ /@iter@/: a t'GI.Gtk.Structs.TreeIter.TreeIter' indicating the row to match
    -> Ptr ()
    -- ^ /@userData@/: user data given to 'GI.Gtk.Objects.EntryCompletion.entryCompletionSetMatchFunc'
    -> IO Bool
    -- ^ __Returns:__ 'P.True' if /@iter@/ should be displayed as a possible completion
    --     for /@key@/

-- | A convenience synonym for @`Nothing` :: `Maybe` `EntryCompletionMatchFunc_WithClosures`@.
noEntryCompletionMatchFunc_WithClosures :: Maybe EntryCompletionMatchFunc_WithClosures
noEntryCompletionMatchFunc_WithClosures = Nothing

-- | A simple wrapper that ignores the closure arguments.
drop_closures_EntryCompletionMatchFunc :: EntryCompletionMatchFunc -> EntryCompletionMatchFunc_WithClosures
drop_closures_EntryCompletionMatchFunc _f completion key iter _ = _f completion key iter

-- | Wrap the callback into a `GClosure`.
genClosure_EntryCompletionMatchFunc :: MonadIO m => EntryCompletionMatchFunc -> m (GClosure C_EntryCompletionMatchFunc)
genClosure_EntryCompletionMatchFunc cb = liftIO $ do
    let cb' = drop_closures_EntryCompletionMatchFunc cb
    let cb'' = wrap_EntryCompletionMatchFunc Nothing cb'
    mk_EntryCompletionMatchFunc cb'' >>= B.GClosure.newGClosure


-- | Wrap a `EntryCompletionMatchFunc` into a `C_EntryCompletionMatchFunc`.
wrap_EntryCompletionMatchFunc :: 
    Maybe (Ptr (FunPtr C_EntryCompletionMatchFunc)) ->
    EntryCompletionMatchFunc_WithClosures ->
    C_EntryCompletionMatchFunc
wrap_EntryCompletionMatchFunc gi'funptrptr gi'cb completion key iter userData = do
    completion' <- (newObject Gtk.EntryCompletion.EntryCompletion) completion
    key' <- cstringToText key
    B.ManagedPtr.withTransient  iter $ \iter' -> do
        result <- gi'cb  completion' key' iter' userData
        maybeReleaseFunPtr gi'funptrptr
        let result' = (fromIntegral . fromEnum) result
        return result'


-- callback ContainerClassSetFocusChildFieldCallback
{- Callable
  { returnType = Nothing
  , returnMayBeNull = False
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , args =
      [ Arg
          { argCName = "container"
          , argType =
              TInterface Name { namespace = "Gtk" , name = "Container" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText = Just "a #GtkContainer" , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "child"
          , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
          , direction = DirectionIn
          , mayBeNull = True
          , argDoc =
              Documentation
                { rawDocText = Just "a #GtkWidget, or %NULL"
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_ContainerClassSetFocusChildFieldCallback =
    Ptr Gtk.Container.Container ->
    Ptr Gtk.Widget.Widget ->
    IO ()

-- Args: [ Arg
--           { argCName = "container"
--           , argType =
--               TInterface Name { namespace = "Gtk" , name = "Container" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "a #GtkContainer" , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "child"
--           , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
--           , direction = DirectionIn
--           , mayBeNull = True
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "a #GtkWidget, or %NULL"
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Nothing
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_ContainerClassSetFocusChildFieldCallback :: FunPtr C_ContainerClassSetFocusChildFieldCallback -> C_ContainerClassSetFocusChildFieldCallback

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_ContainerClassSetFocusChildFieldCallback ::
    (B.CallStack.HasCallStack, MonadIO m, Gtk.Container.IsContainer a, Gtk.Widget.IsWidget b) =>
    FunPtr C_ContainerClassSetFocusChildFieldCallback
    -> a
    -- ^ /@container@/: a t'GI.Gtk.Objects.Container.Container'
    -> Maybe (b)
    -- ^ /@child@/: a t'GI.Gtk.Objects.Widget.Widget', or 'P.Nothing'
    -> m ()
dynamic_ContainerClassSetFocusChildFieldCallback __funPtr container child = liftIO $ do
    container' <- unsafeManagedPtrCastPtr container
    maybeChild <- case child of
        Nothing -> return nullPtr
        Just jChild -> do
            jChild' <- unsafeManagedPtrCastPtr jChild
            return jChild'
    (__dynamic_C_ContainerClassSetFocusChildFieldCallback __funPtr) container' maybeChild
    touchManagedPtr container
    whenJust child touchManagedPtr
    return ()

-- | Generate a function pointer callable from C code, from a `C_ContainerClassSetFocusChildFieldCallback`.
foreign import ccall "wrapper"
    mk_ContainerClassSetFocusChildFieldCallback :: C_ContainerClassSetFocusChildFieldCallback -> IO (FunPtr C_ContainerClassSetFocusChildFieldCallback)

-- | /No description available in the introspection data./
type ContainerClassSetFocusChildFieldCallback =
    Gtk.Container.Container
    -- ^ /@container@/: a t'GI.Gtk.Objects.Container.Container'
    -> Maybe Gtk.Widget.Widget
    -- ^ /@child@/: a t'GI.Gtk.Objects.Widget.Widget', or 'P.Nothing'
    -> IO ()

-- | A convenience synonym for @`Nothing` :: `Maybe` `ContainerClassSetFocusChildFieldCallback`@.
noContainerClassSetFocusChildFieldCallback :: Maybe ContainerClassSetFocusChildFieldCallback
noContainerClassSetFocusChildFieldCallback = Nothing

-- | Wrap the callback into a `GClosure`.
genClosure_ContainerClassSetFocusChildFieldCallback :: MonadIO m => ContainerClassSetFocusChildFieldCallback -> m (GClosure C_ContainerClassSetFocusChildFieldCallback)
genClosure_ContainerClassSetFocusChildFieldCallback cb = liftIO $ do
    let cb' = wrap_ContainerClassSetFocusChildFieldCallback Nothing cb
    mk_ContainerClassSetFocusChildFieldCallback cb' >>= B.GClosure.newGClosure


-- | Wrap a `ContainerClassSetFocusChildFieldCallback` into a `C_ContainerClassSetFocusChildFieldCallback`.
wrap_ContainerClassSetFocusChildFieldCallback :: 
    Maybe (Ptr (FunPtr C_ContainerClassSetFocusChildFieldCallback)) ->
    ContainerClassSetFocusChildFieldCallback ->
    C_ContainerClassSetFocusChildFieldCallback
wrap_ContainerClassSetFocusChildFieldCallback gi'funptrptr gi'cb container child = do
    container' <- (newObject Gtk.Container.Container) container
    maybeChild <-
        if child == nullPtr
        then return Nothing
        else do
            child' <- (newObject Gtk.Widget.Widget) child
            return $ Just child'
    gi'cb  container' maybeChild
    maybeReleaseFunPtr gi'funptrptr


-- callback ContainerClassSetChildPropertyFieldCallback
{- Callable
  { returnType = Nothing
  , returnMayBeNull = False
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , args =
      [ Arg
          { argCName = "container"
          , argType =
              TInterface Name { namespace = "Gtk" , name = "Container" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "child"
          , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "property_id"
          , argType = TBasicType TUInt
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "value"
          , argType = TGValue
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "pspec"
          , argType = TParamSpec
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_ContainerClassSetChildPropertyFieldCallback =
    Ptr Gtk.Container.Container ->
    Ptr Gtk.Widget.Widget ->
    Word32 ->
    Ptr GValue ->
    Ptr GParamSpec ->
    IO ()

-- Args: [ Arg
--           { argCName = "container"
--           , argType =
--               TInterface Name { namespace = "Gtk" , name = "Container" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "child"
--           , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "property_id"
--           , argType = TBasicType TUInt
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "value"
--           , argType = TGValue
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "pspec"
--           , argType = TParamSpec
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Nothing
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_ContainerClassSetChildPropertyFieldCallback :: FunPtr C_ContainerClassSetChildPropertyFieldCallback -> C_ContainerClassSetChildPropertyFieldCallback

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_ContainerClassSetChildPropertyFieldCallback ::
    (B.CallStack.HasCallStack, MonadIO m, Gtk.Container.IsContainer a, Gtk.Widget.IsWidget b) =>
    FunPtr C_ContainerClassSetChildPropertyFieldCallback
    -> a
    -> b
    -> Word32
    -> GValue
    -> GParamSpec
    -> m ()
dynamic_ContainerClassSetChildPropertyFieldCallback __funPtr container child propertyId value pspec = liftIO $ do
    container' <- unsafeManagedPtrCastPtr container
    child' <- unsafeManagedPtrCastPtr child
    value' <- unsafeManagedPtrGetPtr value
    pspec' <- unsafeManagedPtrGetPtr pspec
    (__dynamic_C_ContainerClassSetChildPropertyFieldCallback __funPtr) container' child' propertyId value' pspec'
    touchManagedPtr container
    touchManagedPtr child
    touchManagedPtr value
    touchManagedPtr pspec
    return ()

-- | Generate a function pointer callable from C code, from a `C_ContainerClassSetChildPropertyFieldCallback`.
foreign import ccall "wrapper"
    mk_ContainerClassSetChildPropertyFieldCallback :: C_ContainerClassSetChildPropertyFieldCallback -> IO (FunPtr C_ContainerClassSetChildPropertyFieldCallback)

-- | /No description available in the introspection data./
type ContainerClassSetChildPropertyFieldCallback =
    Gtk.Container.Container
    -> Gtk.Widget.Widget
    -> Word32
    -> GValue
    -> GParamSpec
    -> IO ()

-- | A convenience synonym for @`Nothing` :: `Maybe` `ContainerClassSetChildPropertyFieldCallback`@.
noContainerClassSetChildPropertyFieldCallback :: Maybe ContainerClassSetChildPropertyFieldCallback
noContainerClassSetChildPropertyFieldCallback = Nothing

-- | Wrap the callback into a `GClosure`.
genClosure_ContainerClassSetChildPropertyFieldCallback :: MonadIO m => ContainerClassSetChildPropertyFieldCallback -> m (GClosure C_ContainerClassSetChildPropertyFieldCallback)
genClosure_ContainerClassSetChildPropertyFieldCallback cb = liftIO $ do
    let cb' = wrap_ContainerClassSetChildPropertyFieldCallback Nothing cb
    mk_ContainerClassSetChildPropertyFieldCallback cb' >>= B.GClosure.newGClosure


-- | Wrap a `ContainerClassSetChildPropertyFieldCallback` into a `C_ContainerClassSetChildPropertyFieldCallback`.
wrap_ContainerClassSetChildPropertyFieldCallback :: 
    Maybe (Ptr (FunPtr C_ContainerClassSetChildPropertyFieldCallback)) ->
    ContainerClassSetChildPropertyFieldCallback ->
    C_ContainerClassSetChildPropertyFieldCallback
wrap_ContainerClassSetChildPropertyFieldCallback gi'funptrptr gi'cb container child propertyId value pspec = do
    container' <- (newObject Gtk.Container.Container) container
    child' <- (newObject Gtk.Widget.Widget) child
    value' <- B.GValue.newGValueFromPtr value
    pspec' <- B.GParamSpec.newGParamSpecFromPtr pspec
    gi'cb  container' child' propertyId value' pspec'
    maybeReleaseFunPtr gi'funptrptr


-- callback ContainerClassRemoveFieldCallback
{- Callable
  { returnType = Nothing
  , returnMayBeNull = False
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , args =
      [ Arg
          { argCName = "container"
          , argType =
              TInterface Name { namespace = "Gtk" , name = "Container" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText = Just "a #GtkContainer" , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "widget"
          , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText = Just "a current child of @container"
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_ContainerClassRemoveFieldCallback =
    Ptr Gtk.Container.Container ->
    Ptr Gtk.Widget.Widget ->
    IO ()

-- Args: [ Arg
--           { argCName = "container"
--           , argType =
--               TInterface Name { namespace = "Gtk" , name = "Container" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "a #GtkContainer" , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "widget"
--           , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "a current child of @container"
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Nothing
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_ContainerClassRemoveFieldCallback :: FunPtr C_ContainerClassRemoveFieldCallback -> C_ContainerClassRemoveFieldCallback

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_ContainerClassRemoveFieldCallback ::
    (B.CallStack.HasCallStack, MonadIO m, Gtk.Container.IsContainer a, Gtk.Widget.IsWidget b) =>
    FunPtr C_ContainerClassRemoveFieldCallback
    -> a
    -- ^ /@container@/: a t'GI.Gtk.Objects.Container.Container'
    -> b
    -- ^ /@widget@/: a current child of /@container@/
    -> m ()
dynamic_ContainerClassRemoveFieldCallback __funPtr container widget = liftIO $ do
    container' <- unsafeManagedPtrCastPtr container
    widget' <- unsafeManagedPtrCastPtr widget
    (__dynamic_C_ContainerClassRemoveFieldCallback __funPtr) container' widget'
    touchManagedPtr container
    touchManagedPtr widget
    return ()

-- | Generate a function pointer callable from C code, from a `C_ContainerClassRemoveFieldCallback`.
foreign import ccall "wrapper"
    mk_ContainerClassRemoveFieldCallback :: C_ContainerClassRemoveFieldCallback -> IO (FunPtr C_ContainerClassRemoveFieldCallback)

-- | /No description available in the introspection data./
type ContainerClassRemoveFieldCallback =
    Gtk.Container.Container
    -- ^ /@container@/: a t'GI.Gtk.Objects.Container.Container'
    -> Gtk.Widget.Widget
    -- ^ /@widget@/: a current child of /@container@/
    -> IO ()

-- | A convenience synonym for @`Nothing` :: `Maybe` `ContainerClassRemoveFieldCallback`@.
noContainerClassRemoveFieldCallback :: Maybe ContainerClassRemoveFieldCallback
noContainerClassRemoveFieldCallback = Nothing

-- | Wrap the callback into a `GClosure`.
genClosure_ContainerClassRemoveFieldCallback :: MonadIO m => ContainerClassRemoveFieldCallback -> m (GClosure C_ContainerClassRemoveFieldCallback)
genClosure_ContainerClassRemoveFieldCallback cb = liftIO $ do
    let cb' = wrap_ContainerClassRemoveFieldCallback Nothing cb
    mk_ContainerClassRemoveFieldCallback cb' >>= B.GClosure.newGClosure


-- | Wrap a `ContainerClassRemoveFieldCallback` into a `C_ContainerClassRemoveFieldCallback`.
wrap_ContainerClassRemoveFieldCallback :: 
    Maybe (Ptr (FunPtr C_ContainerClassRemoveFieldCallback)) ->
    ContainerClassRemoveFieldCallback ->
    C_ContainerClassRemoveFieldCallback
wrap_ContainerClassRemoveFieldCallback gi'funptrptr gi'cb container widget = do
    container' <- (newObject Gtk.Container.Container) container
    widget' <- (newObject Gtk.Widget.Widget) widget
    gi'cb  container' widget'
    maybeReleaseFunPtr gi'funptrptr


-- callback ContainerClassGetPathForChildFieldCallback
{- Callable
  { returnType =
      Just (TInterface Name { namespace = "Gtk" , name = "WidgetPath" })
  , returnMayBeNull = False
  , returnTransfer = TransferEverything
  , returnDocumentation =
      Documentation
        { rawDocText = Just "A newly created #GtkWidgetPath"
        , sinceVersion = Nothing
        }
  , args =
      [ Arg
          { argCName = "container"
          , argType =
              TInterface Name { namespace = "Gtk" , name = "Container" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText = Just "a #GtkContainer" , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "child"
          , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText = Just "a child of @container"
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_ContainerClassGetPathForChildFieldCallback =
    Ptr Gtk.Container.Container ->
    Ptr Gtk.Widget.Widget ->
    IO (Ptr Gtk.WidgetPath.WidgetPath)

-- Args: [ Arg
--           { argCName = "container"
--           , argType =
--               TInterface Name { namespace = "Gtk" , name = "Container" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "a #GtkContainer" , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "child"
--           , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "a child of @container"
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Just (TInterface Name { namespace = "Gtk" , name = "WidgetPath" })
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_ContainerClassGetPathForChildFieldCallback :: FunPtr C_ContainerClassGetPathForChildFieldCallback -> C_ContainerClassGetPathForChildFieldCallback

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_ContainerClassGetPathForChildFieldCallback ::
    (B.CallStack.HasCallStack, MonadIO m, Gtk.Container.IsContainer a, Gtk.Widget.IsWidget b) =>
    FunPtr C_ContainerClassGetPathForChildFieldCallback
    -> a
    -- ^ /@container@/: a t'GI.Gtk.Objects.Container.Container'
    -> b
    -- ^ /@child@/: a child of /@container@/
    -> m Gtk.WidgetPath.WidgetPath
    -- ^ __Returns:__ A newly created t'GI.Gtk.Structs.WidgetPath.WidgetPath'
dynamic_ContainerClassGetPathForChildFieldCallback __funPtr container child = liftIO $ do
    container' <- unsafeManagedPtrCastPtr container
    child' <- unsafeManagedPtrCastPtr child
    result <- (__dynamic_C_ContainerClassGetPathForChildFieldCallback __funPtr) container' child'
    checkUnexpectedReturnNULL "containerClassGetPathForChildFieldCallback" result
    result' <- (wrapBoxed Gtk.WidgetPath.WidgetPath) result
    touchManagedPtr container
    touchManagedPtr child
    return result'

-- | Generate a function pointer callable from C code, from a `C_ContainerClassGetPathForChildFieldCallback`.
foreign import ccall "wrapper"
    mk_ContainerClassGetPathForChildFieldCallback :: C_ContainerClassGetPathForChildFieldCallback -> IO (FunPtr C_ContainerClassGetPathForChildFieldCallback)

-- | /No description available in the introspection data./
type ContainerClassGetPathForChildFieldCallback =
    Gtk.Container.Container
    -- ^ /@container@/: a t'GI.Gtk.Objects.Container.Container'
    -> Gtk.Widget.Widget
    -- ^ /@child@/: a child of /@container@/
    -> IO Gtk.WidgetPath.WidgetPath
    -- ^ __Returns:__ A newly created t'GI.Gtk.Structs.WidgetPath.WidgetPath'

-- | A convenience synonym for @`Nothing` :: `Maybe` `ContainerClassGetPathForChildFieldCallback`@.
noContainerClassGetPathForChildFieldCallback :: Maybe ContainerClassGetPathForChildFieldCallback
noContainerClassGetPathForChildFieldCallback = Nothing

-- | Wrap the callback into a `GClosure`.
genClosure_ContainerClassGetPathForChildFieldCallback :: MonadIO m => ContainerClassGetPathForChildFieldCallback -> m (GClosure C_ContainerClassGetPathForChildFieldCallback)
genClosure_ContainerClassGetPathForChildFieldCallback cb = liftIO $ do
    let cb' = wrap_ContainerClassGetPathForChildFieldCallback Nothing cb
    mk_ContainerClassGetPathForChildFieldCallback cb' >>= B.GClosure.newGClosure


-- | Wrap a `ContainerClassGetPathForChildFieldCallback` into a `C_ContainerClassGetPathForChildFieldCallback`.
wrap_ContainerClassGetPathForChildFieldCallback :: 
    Maybe (Ptr (FunPtr C_ContainerClassGetPathForChildFieldCallback)) ->
    ContainerClassGetPathForChildFieldCallback ->
    C_ContainerClassGetPathForChildFieldCallback
wrap_ContainerClassGetPathForChildFieldCallback gi'funptrptr gi'cb container child = do
    container' <- (newObject Gtk.Container.Container) container
    child' <- (newObject Gtk.Widget.Widget) child
    result <- gi'cb  container' child'
    maybeReleaseFunPtr gi'funptrptr
    result' <- B.ManagedPtr.disownBoxed result
    return result'


-- callback ContainerClassGetChildPropertyFieldCallback
{- Callable
  { returnType = Nothing
  , returnMayBeNull = False
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , args =
      [ Arg
          { argCName = "container"
          , argType =
              TInterface Name { namespace = "Gtk" , name = "Container" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "child"
          , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "property_id"
          , argType = TBasicType TUInt
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "value"
          , argType = TGValue
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "pspec"
          , argType = TParamSpec
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_ContainerClassGetChildPropertyFieldCallback =
    Ptr Gtk.Container.Container ->
    Ptr Gtk.Widget.Widget ->
    Word32 ->
    Ptr GValue ->
    Ptr GParamSpec ->
    IO ()

-- Args: [ Arg
--           { argCName = "container"
--           , argType =
--               TInterface Name { namespace = "Gtk" , name = "Container" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "child"
--           , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "property_id"
--           , argType = TBasicType TUInt
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "value"
--           , argType = TGValue
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "pspec"
--           , argType = TParamSpec
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Nothing
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_ContainerClassGetChildPropertyFieldCallback :: FunPtr C_ContainerClassGetChildPropertyFieldCallback -> C_ContainerClassGetChildPropertyFieldCallback

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_ContainerClassGetChildPropertyFieldCallback ::
    (B.CallStack.HasCallStack, MonadIO m, Gtk.Container.IsContainer a, Gtk.Widget.IsWidget b) =>
    FunPtr C_ContainerClassGetChildPropertyFieldCallback
    -> a
    -> b
    -> Word32
    -> GValue
    -> GParamSpec
    -> m ()
dynamic_ContainerClassGetChildPropertyFieldCallback __funPtr container child propertyId value pspec = liftIO $ do
    container' <- unsafeManagedPtrCastPtr container
    child' <- unsafeManagedPtrCastPtr child
    value' <- unsafeManagedPtrGetPtr value
    pspec' <- unsafeManagedPtrGetPtr pspec
    (__dynamic_C_ContainerClassGetChildPropertyFieldCallback __funPtr) container' child' propertyId value' pspec'
    touchManagedPtr container
    touchManagedPtr child
    touchManagedPtr value
    touchManagedPtr pspec
    return ()

-- | Generate a function pointer callable from C code, from a `C_ContainerClassGetChildPropertyFieldCallback`.
foreign import ccall "wrapper"
    mk_ContainerClassGetChildPropertyFieldCallback :: C_ContainerClassGetChildPropertyFieldCallback -> IO (FunPtr C_ContainerClassGetChildPropertyFieldCallback)

-- | /No description available in the introspection data./
type ContainerClassGetChildPropertyFieldCallback =
    Gtk.Container.Container
    -> Gtk.Widget.Widget
    -> Word32
    -> GValue
    -> GParamSpec
    -> IO ()

-- | A convenience synonym for @`Nothing` :: `Maybe` `ContainerClassGetChildPropertyFieldCallback`@.
noContainerClassGetChildPropertyFieldCallback :: Maybe ContainerClassGetChildPropertyFieldCallback
noContainerClassGetChildPropertyFieldCallback = Nothing

-- | Wrap the callback into a `GClosure`.
genClosure_ContainerClassGetChildPropertyFieldCallback :: MonadIO m => ContainerClassGetChildPropertyFieldCallback -> m (GClosure C_ContainerClassGetChildPropertyFieldCallback)
genClosure_ContainerClassGetChildPropertyFieldCallback cb = liftIO $ do
    let cb' = wrap_ContainerClassGetChildPropertyFieldCallback Nothing cb
    mk_ContainerClassGetChildPropertyFieldCallback cb' >>= B.GClosure.newGClosure


-- | Wrap a `ContainerClassGetChildPropertyFieldCallback` into a `C_ContainerClassGetChildPropertyFieldCallback`.
wrap_ContainerClassGetChildPropertyFieldCallback :: 
    Maybe (Ptr (FunPtr C_ContainerClassGetChildPropertyFieldCallback)) ->
    ContainerClassGetChildPropertyFieldCallback ->
    C_ContainerClassGetChildPropertyFieldCallback
wrap_ContainerClassGetChildPropertyFieldCallback gi'funptrptr gi'cb container child propertyId value pspec = do
    container' <- (newObject Gtk.Container.Container) container
    child' <- (newObject Gtk.Widget.Widget) child
    value' <- B.GValue.newGValueFromPtr value
    pspec' <- B.GParamSpec.newGParamSpecFromPtr pspec
    gi'cb  container' child' propertyId value' pspec'
    maybeReleaseFunPtr gi'funptrptr


-- callback ContainerClassForallFieldCallback
{- Callable
  { returnType = Nothing
  , returnMayBeNull = False
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , args =
      [ Arg
          { argCName = "container"
          , argType =
              TInterface Name { namespace = "Gtk" , name = "Container" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText = Just "a #GtkContainer" , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "include_internals"
          , argType = TBasicType TBoolean
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "callback"
          , argType =
              TInterface Name { namespace = "Gtk" , name = "Callback" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText = Just "a callback" , sinceVersion = Nothing }
          , argScope = ScopeTypeCall
          , argClosure = 3
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "callback_data"
          , argType = TBasicType TPtr
          , direction = DirectionIn
          , mayBeNull = True
          , argDoc =
              Documentation
                { rawDocText = Just "callback user data" , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_ContainerClassForallFieldCallback =
    Ptr Gtk.Container.Container ->
    CInt ->
    FunPtr C_Callback ->
    Ptr () ->
    IO ()

-- Args: [ Arg
--           { argCName = "container"
--           , argType =
--               TInterface Name { namespace = "Gtk" , name = "Container" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "a #GtkContainer" , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "include_internals"
--           , argType = TBasicType TBoolean
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "callback"
--           , argType =
--               TInterface Name { namespace = "Gtk" , name = "Callback" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "a callback" , sinceVersion = Nothing }
--           , argScope = ScopeTypeCall
--           , argClosure = 3
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "callback_data"
--           , argType = TBasicType TPtr
--           , direction = DirectionIn
--           , mayBeNull = True
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "callback user data" , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Nothing
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_ContainerClassForallFieldCallback :: FunPtr C_ContainerClassForallFieldCallback -> C_ContainerClassForallFieldCallback

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_ContainerClassForallFieldCallback ::
    (B.CallStack.HasCallStack, MonadIO m, Gtk.Container.IsContainer a) =>
    FunPtr C_ContainerClassForallFieldCallback
    -> a
    -- ^ /@container@/: a t'GI.Gtk.Objects.Container.Container'
    -> Bool
    -> Callback_WithClosures
    -- ^ /@callback@/: a callback
    -> Ptr ()
    -- ^ /@callbackData@/: callback user data
    -> m ()
dynamic_ContainerClassForallFieldCallback __funPtr container includeInternals callback callbackData = liftIO $ do
    container' <- unsafeManagedPtrCastPtr container
    let includeInternals' = (fromIntegral . fromEnum) includeInternals
    callback' <- mk_Callback (wrap_Callback Nothing callback)
    (__dynamic_C_ContainerClassForallFieldCallback __funPtr) container' includeInternals' callback' callbackData
    safeFreeFunPtr $ castFunPtrToPtr callback'
    touchManagedPtr container
    return ()

-- | Generate a function pointer callable from C code, from a `C_ContainerClassForallFieldCallback`.
foreign import ccall "wrapper"
    mk_ContainerClassForallFieldCallback :: C_ContainerClassForallFieldCallback -> IO (FunPtr C_ContainerClassForallFieldCallback)

-- | /No description available in the introspection data./
type ContainerClassForallFieldCallback =
    Gtk.Container.Container
    -- ^ /@container@/: a t'GI.Gtk.Objects.Container.Container'
    -> Bool
    -> Callback_WithClosures
    -- ^ /@callback@/: a callback
    -> IO ()

-- | A convenience synonym for @`Nothing` :: `Maybe` `ContainerClassForallFieldCallback`@.
noContainerClassForallFieldCallback :: Maybe ContainerClassForallFieldCallback
noContainerClassForallFieldCallback = Nothing

-- | /No description available in the introspection data./
type ContainerClassForallFieldCallback_WithClosures =
    Gtk.Container.Container
    -- ^ /@container@/: a t'GI.Gtk.Objects.Container.Container'
    -> Bool
    -> Callback_WithClosures
    -- ^ /@callback@/: a callback
    -> Ptr ()
    -- ^ /@callbackData@/: callback user data
    -> IO ()

-- | A convenience synonym for @`Nothing` :: `Maybe` `ContainerClassForallFieldCallback_WithClosures`@.
noContainerClassForallFieldCallback_WithClosures :: Maybe ContainerClassForallFieldCallback_WithClosures
noContainerClassForallFieldCallback_WithClosures = Nothing

-- | A simple wrapper that ignores the closure arguments.
drop_closures_ContainerClassForallFieldCallback :: ContainerClassForallFieldCallback -> ContainerClassForallFieldCallback_WithClosures
drop_closures_ContainerClassForallFieldCallback _f container includeInternals callback _ = _f container includeInternals callback

-- | Wrap the callback into a `GClosure`.
genClosure_ContainerClassForallFieldCallback :: MonadIO m => ContainerClassForallFieldCallback -> m (GClosure C_ContainerClassForallFieldCallback)
genClosure_ContainerClassForallFieldCallback cb = liftIO $ do
    let cb' = drop_closures_ContainerClassForallFieldCallback cb
    let cb'' = wrap_ContainerClassForallFieldCallback Nothing cb'
    mk_ContainerClassForallFieldCallback cb'' >>= B.GClosure.newGClosure


-- | Wrap a `ContainerClassForallFieldCallback` into a `C_ContainerClassForallFieldCallback`.
wrap_ContainerClassForallFieldCallback :: 
    Maybe (Ptr (FunPtr C_ContainerClassForallFieldCallback)) ->
    ContainerClassForallFieldCallback_WithClosures ->
    C_ContainerClassForallFieldCallback
wrap_ContainerClassForallFieldCallback gi'funptrptr gi'cb container includeInternals callback callbackData = do
    container' <- (newObject Gtk.Container.Container) container
    let includeInternals' = (/= 0) includeInternals
    let callback' = dynamic_Callback callback
    gi'cb  container' includeInternals' callback' callbackData
    maybeReleaseFunPtr gi'funptrptr


-- callback ContainerClassCompositeNameFieldCallback
{- Callable
  { returnType = Just (TBasicType TUTF8)
  , returnMayBeNull = False
  , returnTransfer = TransferEverything
  , returnDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , args =
      [ Arg
          { argCName = "container"
          , argType =
              TInterface Name { namespace = "Gtk" , name = "Container" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "child"
          , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_ContainerClassCompositeNameFieldCallback =
    Ptr Gtk.Container.Container ->
    Ptr Gtk.Widget.Widget ->
    IO CString

-- Args: [ Arg
--           { argCName = "container"
--           , argType =
--               TInterface Name { namespace = "Gtk" , name = "Container" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "child"
--           , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Just (TBasicType TUTF8)
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_ContainerClassCompositeNameFieldCallback :: FunPtr C_ContainerClassCompositeNameFieldCallback -> C_ContainerClassCompositeNameFieldCallback

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_ContainerClassCompositeNameFieldCallback ::
    (B.CallStack.HasCallStack, MonadIO m, Gtk.Container.IsContainer a, Gtk.Widget.IsWidget b) =>
    FunPtr C_ContainerClassCompositeNameFieldCallback
    -> a
    -> b
    -> m T.Text
dynamic_ContainerClassCompositeNameFieldCallback __funPtr container child = liftIO $ do
    container' <- unsafeManagedPtrCastPtr container
    child' <- unsafeManagedPtrCastPtr child
    result <- (__dynamic_C_ContainerClassCompositeNameFieldCallback __funPtr) container' child'
    checkUnexpectedReturnNULL "containerClassCompositeNameFieldCallback" result
    result' <- cstringToText result
    freeMem result
    touchManagedPtr container
    touchManagedPtr child
    return result'

-- | Generate a function pointer callable from C code, from a `C_ContainerClassCompositeNameFieldCallback`.
foreign import ccall "wrapper"
    mk_ContainerClassCompositeNameFieldCallback :: C_ContainerClassCompositeNameFieldCallback -> IO (FunPtr C_ContainerClassCompositeNameFieldCallback)

-- | /No description available in the introspection data./
type ContainerClassCompositeNameFieldCallback =
    Gtk.Container.Container
    -> Gtk.Widget.Widget
    -> IO T.Text

-- | A convenience synonym for @`Nothing` :: `Maybe` `ContainerClassCompositeNameFieldCallback`@.
noContainerClassCompositeNameFieldCallback :: Maybe ContainerClassCompositeNameFieldCallback
noContainerClassCompositeNameFieldCallback = Nothing

-- | Wrap the callback into a `GClosure`.
genClosure_ContainerClassCompositeNameFieldCallback :: MonadIO m => ContainerClassCompositeNameFieldCallback -> m (GClosure C_ContainerClassCompositeNameFieldCallback)
genClosure_ContainerClassCompositeNameFieldCallback cb = liftIO $ do
    let cb' = wrap_ContainerClassCompositeNameFieldCallback Nothing cb
    mk_ContainerClassCompositeNameFieldCallback cb' >>= B.GClosure.newGClosure


-- | Wrap a `ContainerClassCompositeNameFieldCallback` into a `C_ContainerClassCompositeNameFieldCallback`.
wrap_ContainerClassCompositeNameFieldCallback :: 
    Maybe (Ptr (FunPtr C_ContainerClassCompositeNameFieldCallback)) ->
    ContainerClassCompositeNameFieldCallback ->
    C_ContainerClassCompositeNameFieldCallback
wrap_ContainerClassCompositeNameFieldCallback gi'funptrptr gi'cb container child = do
    container' <- (newObject Gtk.Container.Container) container
    child' <- (newObject Gtk.Widget.Widget) child
    result <- gi'cb  container' child'
    maybeReleaseFunPtr gi'funptrptr
    result' <- textToCString result
    return result'


-- callback ContainerClassChildTypeFieldCallback
{- Callable
  { returnType = Just (TBasicType TGType)
  , returnMayBeNull = False
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation
        { rawDocText = Just "a #GType." , sinceVersion = Nothing }
  , args =
      [ Arg
          { argCName = "container"
          , argType =
              TInterface Name { namespace = "Gtk" , name = "Container" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText = Just "a #GtkContainer" , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_ContainerClassChildTypeFieldCallback =
    Ptr Gtk.Container.Container ->
    IO CGType

-- Args: [ Arg
--           { argCName = "container"
--           , argType =
--               TInterface Name { namespace = "Gtk" , name = "Container" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "a #GtkContainer" , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Just (TBasicType TGType)
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_ContainerClassChildTypeFieldCallback :: FunPtr C_ContainerClassChildTypeFieldCallback -> C_ContainerClassChildTypeFieldCallback

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_ContainerClassChildTypeFieldCallback ::
    (B.CallStack.HasCallStack, MonadIO m, Gtk.Container.IsContainer a) =>
    FunPtr C_ContainerClassChildTypeFieldCallback
    -> a
    -- ^ /@container@/: a t'GI.Gtk.Objects.Container.Container'
    -> m GType
    -- ^ __Returns:__ a t'GType'.
dynamic_ContainerClassChildTypeFieldCallback __funPtr container = liftIO $ do
    container' <- unsafeManagedPtrCastPtr container
    result <- (__dynamic_C_ContainerClassChildTypeFieldCallback __funPtr) container'
    let result' = GType result
    touchManagedPtr container
    return result'

-- | Generate a function pointer callable from C code, from a `C_ContainerClassChildTypeFieldCallback`.
foreign import ccall "wrapper"
    mk_ContainerClassChildTypeFieldCallback :: C_ContainerClassChildTypeFieldCallback -> IO (FunPtr C_ContainerClassChildTypeFieldCallback)

-- | /No description available in the introspection data./
type ContainerClassChildTypeFieldCallback =
    Gtk.Container.Container
    -- ^ /@container@/: a t'GI.Gtk.Objects.Container.Container'
    -> IO GType
    -- ^ __Returns:__ a t'GType'.

-- | A convenience synonym for @`Nothing` :: `Maybe` `ContainerClassChildTypeFieldCallback`@.
noContainerClassChildTypeFieldCallback :: Maybe ContainerClassChildTypeFieldCallback
noContainerClassChildTypeFieldCallback = Nothing

-- | Wrap the callback into a `GClosure`.
genClosure_ContainerClassChildTypeFieldCallback :: MonadIO m => ContainerClassChildTypeFieldCallback -> m (GClosure C_ContainerClassChildTypeFieldCallback)
genClosure_ContainerClassChildTypeFieldCallback cb = liftIO $ do
    let cb' = wrap_ContainerClassChildTypeFieldCallback Nothing cb
    mk_ContainerClassChildTypeFieldCallback cb' >>= B.GClosure.newGClosure


-- | Wrap a `ContainerClassChildTypeFieldCallback` into a `C_ContainerClassChildTypeFieldCallback`.
wrap_ContainerClassChildTypeFieldCallback :: 
    Maybe (Ptr (FunPtr C_ContainerClassChildTypeFieldCallback)) ->
    ContainerClassChildTypeFieldCallback ->
    C_ContainerClassChildTypeFieldCallback
wrap_ContainerClassChildTypeFieldCallback gi'funptrptr gi'cb container = do
    container' <- (newObject Gtk.Container.Container) container
    result <- gi'cb  container'
    maybeReleaseFunPtr gi'funptrptr
    let result' = gtypeToCGType result
    return result'


-- callback ContainerClassCheckResizeFieldCallback
{- Callable
  { returnType = Nothing
  , returnMayBeNull = False
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , args =
      [ Arg
          { argCName = "container"
          , argType =
              TInterface Name { namespace = "Gtk" , name = "Container" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_ContainerClassCheckResizeFieldCallback =
    Ptr Gtk.Container.Container ->
    IO ()

-- Args: [ Arg
--           { argCName = "container"
--           , argType =
--               TInterface Name { namespace = "Gtk" , name = "Container" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Nothing
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_ContainerClassCheckResizeFieldCallback :: FunPtr C_ContainerClassCheckResizeFieldCallback -> C_ContainerClassCheckResizeFieldCallback

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_ContainerClassCheckResizeFieldCallback ::
    (B.CallStack.HasCallStack, MonadIO m, Gtk.Container.IsContainer a) =>
    FunPtr C_ContainerClassCheckResizeFieldCallback
    -> a
    -> m ()
dynamic_ContainerClassCheckResizeFieldCallback __funPtr container = liftIO $ do
    container' <- unsafeManagedPtrCastPtr container
    (__dynamic_C_ContainerClassCheckResizeFieldCallback __funPtr) container'
    touchManagedPtr container
    return ()

-- | Generate a function pointer callable from C code, from a `C_ContainerClassCheckResizeFieldCallback`.
foreign import ccall "wrapper"
    mk_ContainerClassCheckResizeFieldCallback :: C_ContainerClassCheckResizeFieldCallback -> IO (FunPtr C_ContainerClassCheckResizeFieldCallback)

-- | /No description available in the introspection data./
type ContainerClassCheckResizeFieldCallback =
    Gtk.Container.Container
    -> IO ()

-- | A convenience synonym for @`Nothing` :: `Maybe` `ContainerClassCheckResizeFieldCallback`@.
noContainerClassCheckResizeFieldCallback :: Maybe ContainerClassCheckResizeFieldCallback
noContainerClassCheckResizeFieldCallback = Nothing

-- | Wrap the callback into a `GClosure`.
genClosure_ContainerClassCheckResizeFieldCallback :: MonadIO m => ContainerClassCheckResizeFieldCallback -> m (GClosure C_ContainerClassCheckResizeFieldCallback)
genClosure_ContainerClassCheckResizeFieldCallback cb = liftIO $ do
    let cb' = wrap_ContainerClassCheckResizeFieldCallback Nothing cb
    mk_ContainerClassCheckResizeFieldCallback cb' >>= B.GClosure.newGClosure


-- | Wrap a `ContainerClassCheckResizeFieldCallback` into a `C_ContainerClassCheckResizeFieldCallback`.
wrap_ContainerClassCheckResizeFieldCallback :: 
    Maybe (Ptr (FunPtr C_ContainerClassCheckResizeFieldCallback)) ->
    ContainerClassCheckResizeFieldCallback ->
    C_ContainerClassCheckResizeFieldCallback
wrap_ContainerClassCheckResizeFieldCallback gi'funptrptr gi'cb container = do
    container' <- (newObject Gtk.Container.Container) container
    gi'cb  container'
    maybeReleaseFunPtr gi'funptrptr


-- callback ContainerClassAddFieldCallback
{- Callable
  { returnType = Nothing
  , returnMayBeNull = False
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , args =
      [ Arg
          { argCName = "container"
          , argType =
              TInterface Name { namespace = "Gtk" , name = "Container" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText = Just "a #GtkContainer" , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "widget"
          , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText = Just "a widget to be placed inside @container"
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_ContainerClassAddFieldCallback =
    Ptr Gtk.Container.Container ->
    Ptr Gtk.Widget.Widget ->
    IO ()

-- Args: [ Arg
--           { argCName = "container"
--           , argType =
--               TInterface Name { namespace = "Gtk" , name = "Container" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "a #GtkContainer" , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "widget"
--           , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "a widget to be placed inside @container"
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Nothing
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_ContainerClassAddFieldCallback :: FunPtr C_ContainerClassAddFieldCallback -> C_ContainerClassAddFieldCallback

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_ContainerClassAddFieldCallback ::
    (B.CallStack.HasCallStack, MonadIO m, Gtk.Container.IsContainer a, Gtk.Widget.IsWidget b) =>
    FunPtr C_ContainerClassAddFieldCallback
    -> a
    -- ^ /@container@/: a t'GI.Gtk.Objects.Container.Container'
    -> b
    -- ^ /@widget@/: a widget to be placed inside /@container@/
    -> m ()
dynamic_ContainerClassAddFieldCallback __funPtr container widget = liftIO $ do
    container' <- unsafeManagedPtrCastPtr container
    widget' <- unsafeManagedPtrCastPtr widget
    (__dynamic_C_ContainerClassAddFieldCallback __funPtr) container' widget'
    touchManagedPtr container
    touchManagedPtr widget
    return ()

-- | Generate a function pointer callable from C code, from a `C_ContainerClassAddFieldCallback`.
foreign import ccall "wrapper"
    mk_ContainerClassAddFieldCallback :: C_ContainerClassAddFieldCallback -> IO (FunPtr C_ContainerClassAddFieldCallback)

-- | /No description available in the introspection data./
type ContainerClassAddFieldCallback =
    Gtk.Container.Container
    -- ^ /@container@/: a t'GI.Gtk.Objects.Container.Container'
    -> Gtk.Widget.Widget
    -- ^ /@widget@/: a widget to be placed inside /@container@/
    -> IO ()

-- | A convenience synonym for @`Nothing` :: `Maybe` `ContainerClassAddFieldCallback`@.
noContainerClassAddFieldCallback :: Maybe ContainerClassAddFieldCallback
noContainerClassAddFieldCallback = Nothing

-- | Wrap the callback into a `GClosure`.
genClosure_ContainerClassAddFieldCallback :: MonadIO m => ContainerClassAddFieldCallback -> m (GClosure C_ContainerClassAddFieldCallback)
genClosure_ContainerClassAddFieldCallback cb = liftIO $ do
    let cb' = wrap_ContainerClassAddFieldCallback Nothing cb
    mk_ContainerClassAddFieldCallback cb' >>= B.GClosure.newGClosure


-- | Wrap a `ContainerClassAddFieldCallback` into a `C_ContainerClassAddFieldCallback`.
wrap_ContainerClassAddFieldCallback :: 
    Maybe (Ptr (FunPtr C_ContainerClassAddFieldCallback)) ->
    ContainerClassAddFieldCallback ->
    C_ContainerClassAddFieldCallback
wrap_ContainerClassAddFieldCallback gi'funptrptr gi'cb container widget = do
    container' <- (newObject Gtk.Container.Container) container
    widget' <- (newObject Gtk.Widget.Widget) widget
    gi'cb  container' widget'
    maybeReleaseFunPtr gi'funptrptr


-- callback ColorSelectionChangePaletteWithScreenFunc
{- Callable
  { returnType = Nothing
  , returnMayBeNull = False
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , args =
      [ Arg
          { argCName = "screen"
          , argType = TInterface Name { namespace = "Gdk" , name = "Screen" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "colors"
          , argType =
              TCArray
                False
                (-1)
                2
                (TInterface Name { namespace = "Gdk" , name = "Color" })
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText = Just "Array of colors" , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "n_colors"
          , argType = TBasicType TInt
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText = Just "Number of colors in the array"
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated =
      Just
        DeprecationInfo
          { deprecatedSinceVersion = Just "3.4"
          , deprecationMessage = Nothing
          }
  , callableDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Just "2.2" }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_ColorSelectionChangePaletteWithScreenFunc =
    Ptr Gdk.Screen.Screen ->
    Ptr Gdk.Color.Color ->
    Int32 ->
    IO ()

-- Args: [ Arg
--           { argCName = "screen"
--           , argType = TInterface Name { namespace = "Gdk" , name = "Screen" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "colors"
--           , argType =
--               TCArray
--                 False
--                 (-1)
--                 2
--                 (TInterface Name { namespace = "Gdk" , name = "Color" })
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "Array of colors" , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "n_colors"
--           , argType = TBasicType TInt
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "Number of colors in the array"
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: [ Arg
--              { argCName = "n_colors"
--              , argType = TBasicType TInt
--              , direction = DirectionIn
--              , mayBeNull = False
--              , argDoc =
--                  Documentation
--                    { rawDocText = Just "Number of colors in the array"
--                    , sinceVersion = Nothing
--                    }
--              , argScope = ScopeTypeInvalid
--              , argClosure = -1
--              , argDestroy = -1
--              , argCallerAllocates = False
--              , transfer = TransferNothing
--              }
--          ]
-- returnType: Nothing
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_ColorSelectionChangePaletteWithScreenFunc :: FunPtr C_ColorSelectionChangePaletteWithScreenFunc -> C_ColorSelectionChangePaletteWithScreenFunc

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_ColorSelectionChangePaletteWithScreenFunc ::
    (B.CallStack.HasCallStack, MonadIO m, Gdk.Screen.IsScreen a) =>
    FunPtr C_ColorSelectionChangePaletteWithScreenFunc
    -> a
    -> [Gdk.Color.Color]
    -- ^ /@colors@/: Array of colors
    -> m ()
dynamic_ColorSelectionChangePaletteWithScreenFunc __funPtr screen colors = liftIO $ do
    let nColors = fromIntegral $ P.length colors
    screen' <- unsafeManagedPtrCastPtr screen
    colors' <- mapM unsafeManagedPtrGetPtr colors
    colors'' <- packBlockArray 12 colors'
    (__dynamic_C_ColorSelectionChangePaletteWithScreenFunc __funPtr) screen' colors'' nColors
    touchManagedPtr screen
    mapM_ touchManagedPtr colors
    freeMem colors''
    return ()

-- | Generate a function pointer callable from C code, from a `C_ColorSelectionChangePaletteWithScreenFunc`.
foreign import ccall "wrapper"
    mk_ColorSelectionChangePaletteWithScreenFunc :: C_ColorSelectionChangePaletteWithScreenFunc -> IO (FunPtr C_ColorSelectionChangePaletteWithScreenFunc)

{-# DEPRECATED ColorSelectionChangePaletteWithScreenFunc ["(Since version 3.4)"] #-}
-- | /No description available in the introspection data./
-- 
-- /Since: 2.2/
type ColorSelectionChangePaletteWithScreenFunc =
    Gdk.Screen.Screen
    -> [Gdk.Color.Color]
    -- ^ /@colors@/: Array of colors
    -> IO ()

-- | A convenience synonym for @`Nothing` :: `Maybe` `ColorSelectionChangePaletteWithScreenFunc`@.
noColorSelectionChangePaletteWithScreenFunc :: Maybe ColorSelectionChangePaletteWithScreenFunc
noColorSelectionChangePaletteWithScreenFunc = Nothing

-- | Wrap the callback into a `GClosure`.
genClosure_ColorSelectionChangePaletteWithScreenFunc :: MonadIO m => ColorSelectionChangePaletteWithScreenFunc -> m (GClosure C_ColorSelectionChangePaletteWithScreenFunc)
genClosure_ColorSelectionChangePaletteWithScreenFunc cb = liftIO $ do
    let cb' = wrap_ColorSelectionChangePaletteWithScreenFunc Nothing cb
    mk_ColorSelectionChangePaletteWithScreenFunc cb' >>= B.GClosure.newGClosure


-- | Wrap a `ColorSelectionChangePaletteWithScreenFunc` into a `C_ColorSelectionChangePaletteWithScreenFunc`.
wrap_ColorSelectionChangePaletteWithScreenFunc :: 
    Maybe (Ptr (FunPtr C_ColorSelectionChangePaletteWithScreenFunc)) ->
    ColorSelectionChangePaletteWithScreenFunc ->
    C_ColorSelectionChangePaletteWithScreenFunc
wrap_ColorSelectionChangePaletteWithScreenFunc gi'funptrptr gi'cb screen colors nColors = do
    screen' <- (newObject Gdk.Screen.Screen) screen
    colors' <- (unpackBoxedArrayWithLength 12 nColors) colors
    colors'' <- mapM (newBoxed Gdk.Color.Color) colors'
    gi'cb  screen' colors''
    maybeReleaseFunPtr gi'funptrptr


-- callback ColorSelectionChangePaletteFunc
{- Callable
  { returnType = Nothing
  , returnMayBeNull = False
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , args =
      [ Arg
          { argCName = "colors"
          , argType =
              TCArray
                False
                (-1)
                1
                (TInterface Name { namespace = "Gdk" , name = "Color" })
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText = Just "Array of colors" , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "n_colors"
          , argType = TBasicType TInt
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText = Just "Number of colors in the array"
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated =
      Just
        DeprecationInfo
          { deprecatedSinceVersion = Just "3.4"
          , deprecationMessage = Nothing
          }
  , callableDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_ColorSelectionChangePaletteFunc =
    Ptr Gdk.Color.Color ->
    Int32 ->
    IO ()

-- Args: [ Arg
--           { argCName = "colors"
--           , argType =
--               TCArray
--                 False
--                 (-1)
--                 1
--                 (TInterface Name { namespace = "Gdk" , name = "Color" })
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "Array of colors" , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "n_colors"
--           , argType = TBasicType TInt
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "Number of colors in the array"
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: [ Arg
--              { argCName = "n_colors"
--              , argType = TBasicType TInt
--              , direction = DirectionIn
--              , mayBeNull = False
--              , argDoc =
--                  Documentation
--                    { rawDocText = Just "Number of colors in the array"
--                    , sinceVersion = Nothing
--                    }
--              , argScope = ScopeTypeInvalid
--              , argClosure = -1
--              , argDestroy = -1
--              , argCallerAllocates = False
--              , transfer = TransferNothing
--              }
--          ]
-- returnType: Nothing
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_ColorSelectionChangePaletteFunc :: FunPtr C_ColorSelectionChangePaletteFunc -> C_ColorSelectionChangePaletteFunc

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_ColorSelectionChangePaletteFunc ::
    (B.CallStack.HasCallStack, MonadIO m) =>
    FunPtr C_ColorSelectionChangePaletteFunc
    -> [Gdk.Color.Color]
    -- ^ /@colors@/: Array of colors
    -> m ()
dynamic_ColorSelectionChangePaletteFunc __funPtr colors = liftIO $ do
    let nColors = fromIntegral $ P.length colors
    colors' <- mapM unsafeManagedPtrGetPtr colors
    colors'' <- packBlockArray 12 colors'
    (__dynamic_C_ColorSelectionChangePaletteFunc __funPtr) colors'' nColors
    mapM_ touchManagedPtr colors
    freeMem colors''
    return ()

-- | Generate a function pointer callable from C code, from a `C_ColorSelectionChangePaletteFunc`.
foreign import ccall "wrapper"
    mk_ColorSelectionChangePaletteFunc :: C_ColorSelectionChangePaletteFunc -> IO (FunPtr C_ColorSelectionChangePaletteFunc)

{-# DEPRECATED ColorSelectionChangePaletteFunc ["(Since version 3.4)"] #-}
-- | /No description available in the introspection data./
type ColorSelectionChangePaletteFunc =
    [Gdk.Color.Color]
    -- ^ /@colors@/: Array of colors
    -> IO ()

-- | A convenience synonym for @`Nothing` :: `Maybe` `ColorSelectionChangePaletteFunc`@.
noColorSelectionChangePaletteFunc :: Maybe ColorSelectionChangePaletteFunc
noColorSelectionChangePaletteFunc = Nothing

-- | Wrap the callback into a `GClosure`.
genClosure_ColorSelectionChangePaletteFunc :: MonadIO m => ColorSelectionChangePaletteFunc -> m (GClosure C_ColorSelectionChangePaletteFunc)
genClosure_ColorSelectionChangePaletteFunc cb = liftIO $ do
    let cb' = wrap_ColorSelectionChangePaletteFunc Nothing cb
    mk_ColorSelectionChangePaletteFunc cb' >>= B.GClosure.newGClosure


-- | Wrap a `ColorSelectionChangePaletteFunc` into a `C_ColorSelectionChangePaletteFunc`.
wrap_ColorSelectionChangePaletteFunc :: 
    Maybe (Ptr (FunPtr C_ColorSelectionChangePaletteFunc)) ->
    ColorSelectionChangePaletteFunc ->
    C_ColorSelectionChangePaletteFunc
wrap_ColorSelectionChangePaletteFunc gi'funptrptr gi'cb colors nColors = do
    colors' <- (unpackBoxedArrayWithLength 12 nColors) colors
    colors'' <- mapM (newBoxed Gdk.Color.Color) colors'
    gi'cb  colors''
    maybeReleaseFunPtr gi'funptrptr


-- callback ClipboardURIReceivedFunc
{- Callable
  { returnType = Nothing
  , returnMayBeNull = False
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , args =
      [ Arg
          { argCName = "clipboard"
          , argType =
              TInterface Name { namespace = "Gtk" , name = "Clipboard" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText = Just "the #GtkClipboard" , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "uris"
          , argType = TCArray True (-1) (-1) (TBasicType TUTF8)
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText = Just "the received URIs" , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "data"
          , argType = TBasicType TPtr
          , direction = DirectionIn
          , mayBeNull = True
          , argDoc =
              Documentation
                { rawDocText =
                    Just "the @user_data supplied to\n  gtk_clipboard_request_uris()."
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = 2
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation
        { rawDocText =
            Just
              "A function to be called when the results of\ngtk_clipboard_request_uris() are received, or when the request\nfails."
        , sinceVersion = Just "2.14"
        }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_ClipboardURIReceivedFunc =
    Ptr Gtk.Clipboard.Clipboard ->
    Ptr CString ->
    Ptr () ->
    IO ()

-- Args: [ Arg
--           { argCName = "clipboard"
--           , argType =
--               TInterface Name { namespace = "Gtk" , name = "Clipboard" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "the #GtkClipboard" , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "uris"
--           , argType = TCArray True (-1) (-1) (TBasicType TUTF8)
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "the received URIs" , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "data"
--           , argType = TBasicType TPtr
--           , direction = DirectionIn
--           , mayBeNull = True
--           , argDoc =
--               Documentation
--                 { rawDocText =
--                     Just "the @user_data supplied to\n  gtk_clipboard_request_uris()."
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = 2
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Nothing
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_ClipboardURIReceivedFunc :: FunPtr C_ClipboardURIReceivedFunc -> C_ClipboardURIReceivedFunc

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_ClipboardURIReceivedFunc ::
    (B.CallStack.HasCallStack, MonadIO m, Gtk.Clipboard.IsClipboard a) =>
    FunPtr C_ClipboardURIReceivedFunc
    -> a
    -- ^ /@clipboard@/: the t'GI.Gtk.Objects.Clipboard.Clipboard'
    -> [T.Text]
    -- ^ /@uris@/: the received URIs
    -> Ptr ()
    -- ^ /@data@/: the /@userData@/ supplied to
    --   'GI.Gtk.Objects.Clipboard.clipboardRequestUris'.
    -> m ()
dynamic_ClipboardURIReceivedFunc __funPtr clipboard uris data_ = liftIO $ do
    clipboard' <- unsafeManagedPtrCastPtr clipboard
    uris' <- packZeroTerminatedUTF8CArray uris
    (__dynamic_C_ClipboardURIReceivedFunc __funPtr) clipboard' uris' data_
    touchManagedPtr clipboard
    mapZeroTerminatedCArray freeMem uris'
    freeMem uris'
    return ()

-- | Generate a function pointer callable from C code, from a `C_ClipboardURIReceivedFunc`.
foreign import ccall "wrapper"
    mk_ClipboardURIReceivedFunc :: C_ClipboardURIReceivedFunc -> IO (FunPtr C_ClipboardURIReceivedFunc)

-- | A function to be called when the results of
-- 'GI.Gtk.Objects.Clipboard.clipboardRequestUris' are received, or when the request
-- fails.
-- 
-- /Since: 2.14/
type ClipboardURIReceivedFunc =
    Gtk.Clipboard.Clipboard
    -- ^ /@clipboard@/: the t'GI.Gtk.Objects.Clipboard.Clipboard'
    -> [T.Text]
    -- ^ /@uris@/: the received URIs
    -> IO ()

-- | A convenience synonym for @`Nothing` :: `Maybe` `ClipboardURIReceivedFunc`@.
noClipboardURIReceivedFunc :: Maybe ClipboardURIReceivedFunc
noClipboardURIReceivedFunc = Nothing

-- | A function to be called when the results of
-- 'GI.Gtk.Objects.Clipboard.clipboardRequestUris' are received, or when the request
-- fails.
-- 
-- /Since: 2.14/
type ClipboardURIReceivedFunc_WithClosures =
    Gtk.Clipboard.Clipboard
    -- ^ /@clipboard@/: the t'GI.Gtk.Objects.Clipboard.Clipboard'
    -> [T.Text]
    -- ^ /@uris@/: the received URIs
    -> Ptr ()
    -- ^ /@data@/: the /@userData@/ supplied to
    --   'GI.Gtk.Objects.Clipboard.clipboardRequestUris'.
    -> IO ()

-- | A convenience synonym for @`Nothing` :: `Maybe` `ClipboardURIReceivedFunc_WithClosures`@.
noClipboardURIReceivedFunc_WithClosures :: Maybe ClipboardURIReceivedFunc_WithClosures
noClipboardURIReceivedFunc_WithClosures = Nothing

-- | A simple wrapper that ignores the closure arguments.
drop_closures_ClipboardURIReceivedFunc :: ClipboardURIReceivedFunc -> ClipboardURIReceivedFunc_WithClosures
drop_closures_ClipboardURIReceivedFunc _f clipboard uris _ = _f clipboard uris

-- | Wrap the callback into a `GClosure`.
genClosure_ClipboardURIReceivedFunc :: MonadIO m => ClipboardURIReceivedFunc -> m (GClosure C_ClipboardURIReceivedFunc)
genClosure_ClipboardURIReceivedFunc cb = liftIO $ do
    let cb' = drop_closures_ClipboardURIReceivedFunc cb
    let cb'' = wrap_ClipboardURIReceivedFunc Nothing cb'
    mk_ClipboardURIReceivedFunc cb'' >>= B.GClosure.newGClosure


-- | Wrap a `ClipboardURIReceivedFunc` into a `C_ClipboardURIReceivedFunc`.
wrap_ClipboardURIReceivedFunc :: 
    Maybe (Ptr (FunPtr C_ClipboardURIReceivedFunc)) ->
    ClipboardURIReceivedFunc_WithClosures ->
    C_ClipboardURIReceivedFunc
wrap_ClipboardURIReceivedFunc gi'funptrptr gi'cb clipboard uris data_ = do
    clipboard' <- (newObject Gtk.Clipboard.Clipboard) clipboard
    uris' <- unpackZeroTerminatedUTF8CArray uris
    gi'cb  clipboard' uris' data_
    maybeReleaseFunPtr gi'funptrptr


-- callback ClipboardTextReceivedFunc
{- Callable
  { returnType = Nothing
  , returnMayBeNull = False
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , args =
      [ Arg
          { argCName = "clipboard"
          , argType =
              TInterface Name { namespace = "Gtk" , name = "Clipboard" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText = Just "the #GtkClipboard" , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "text"
          , argType = TBasicType TUTF8
          , direction = DirectionIn
          , mayBeNull = True
          , argDoc =
              Documentation
                { rawDocText =
                    Just
                      "the text received, as a UTF-8 encoded string, or\n  %NULL if retrieving the data failed."
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "data"
          , argType = TBasicType TPtr
          , direction = DirectionIn
          , mayBeNull = True
          , argDoc =
              Documentation
                { rawDocText =
                    Just "the @user_data supplied to\n  gtk_clipboard_request_text()."
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = 2
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation
        { rawDocText =
            Just
              "A function to be called when the results of gtk_clipboard_request_text()\nare received, or when the request fails."
        , sinceVersion = Nothing
        }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_ClipboardTextReceivedFunc =
    Ptr Gtk.Clipboard.Clipboard ->
    CString ->
    Ptr () ->
    IO ()

-- Args: [ Arg
--           { argCName = "clipboard"
--           , argType =
--               TInterface Name { namespace = "Gtk" , name = "Clipboard" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "the #GtkClipboard" , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "text"
--           , argType = TBasicType TUTF8
--           , direction = DirectionIn
--           , mayBeNull = True
--           , argDoc =
--               Documentation
--                 { rawDocText =
--                     Just
--                       "the text received, as a UTF-8 encoded string, or\n  %NULL if retrieving the data failed."
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "data"
--           , argType = TBasicType TPtr
--           , direction = DirectionIn
--           , mayBeNull = True
--           , argDoc =
--               Documentation
--                 { rawDocText =
--                     Just "the @user_data supplied to\n  gtk_clipboard_request_text()."
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = 2
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Nothing
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_ClipboardTextReceivedFunc :: FunPtr C_ClipboardTextReceivedFunc -> C_ClipboardTextReceivedFunc

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_ClipboardTextReceivedFunc ::
    (B.CallStack.HasCallStack, MonadIO m, Gtk.Clipboard.IsClipboard a) =>
    FunPtr C_ClipboardTextReceivedFunc
    -> a
    -- ^ /@clipboard@/: the t'GI.Gtk.Objects.Clipboard.Clipboard'
    -> Maybe (T.Text)
    -- ^ /@text@/: the text received, as a UTF-8 encoded string, or
    --   'P.Nothing' if retrieving the data failed.
    -> Ptr ()
    -- ^ /@data@/: the /@userData@/ supplied to
    --   'GI.Gtk.Objects.Clipboard.clipboardRequestText'.
    -> m ()
dynamic_ClipboardTextReceivedFunc __funPtr clipboard text data_ = liftIO $ do
    clipboard' <- unsafeManagedPtrCastPtr clipboard
    maybeText <- case text of
        Nothing -> return nullPtr
        Just jText -> do
            jText' <- textToCString jText
            return jText'
    (__dynamic_C_ClipboardTextReceivedFunc __funPtr) clipboard' maybeText data_
    touchManagedPtr clipboard
    freeMem maybeText
    return ()

-- | Generate a function pointer callable from C code, from a `C_ClipboardTextReceivedFunc`.
foreign import ccall "wrapper"
    mk_ClipboardTextReceivedFunc :: C_ClipboardTextReceivedFunc -> IO (FunPtr C_ClipboardTextReceivedFunc)

-- | A function to be called when the results of 'GI.Gtk.Objects.Clipboard.clipboardRequestText'
-- are received, or when the request fails.
type ClipboardTextReceivedFunc =
    Gtk.Clipboard.Clipboard
    -- ^ /@clipboard@/: the t'GI.Gtk.Objects.Clipboard.Clipboard'
    -> Maybe T.Text
    -- ^ /@text@/: the text received, as a UTF-8 encoded string, or
    --   'P.Nothing' if retrieving the data failed.
    -> IO ()

-- | A convenience synonym for @`Nothing` :: `Maybe` `ClipboardTextReceivedFunc`@.
noClipboardTextReceivedFunc :: Maybe ClipboardTextReceivedFunc
noClipboardTextReceivedFunc = Nothing

-- | A function to be called when the results of 'GI.Gtk.Objects.Clipboard.clipboardRequestText'
-- are received, or when the request fails.
type ClipboardTextReceivedFunc_WithClosures =
    Gtk.Clipboard.Clipboard
    -- ^ /@clipboard@/: the t'GI.Gtk.Objects.Clipboard.Clipboard'
    -> Maybe T.Text
    -- ^ /@text@/: the text received, as a UTF-8 encoded string, or
    --   'P.Nothing' if retrieving the data failed.
    -> Ptr ()
    -- ^ /@data@/: the /@userData@/ supplied to
    --   'GI.Gtk.Objects.Clipboard.clipboardRequestText'.
    -> IO ()

-- | A convenience synonym for @`Nothing` :: `Maybe` `ClipboardTextReceivedFunc_WithClosures`@.
noClipboardTextReceivedFunc_WithClosures :: Maybe ClipboardTextReceivedFunc_WithClosures
noClipboardTextReceivedFunc_WithClosures = Nothing

-- | A simple wrapper that ignores the closure arguments.
drop_closures_ClipboardTextReceivedFunc :: ClipboardTextReceivedFunc -> ClipboardTextReceivedFunc_WithClosures
drop_closures_ClipboardTextReceivedFunc _f clipboard text _ = _f clipboard text

-- | Wrap the callback into a `GClosure`.
genClosure_ClipboardTextReceivedFunc :: MonadIO m => ClipboardTextReceivedFunc -> m (GClosure C_ClipboardTextReceivedFunc)
genClosure_ClipboardTextReceivedFunc cb = liftIO $ do
    let cb' = drop_closures_ClipboardTextReceivedFunc cb
    let cb'' = wrap_ClipboardTextReceivedFunc Nothing cb'
    mk_ClipboardTextReceivedFunc cb'' >>= B.GClosure.newGClosure


-- | Wrap a `ClipboardTextReceivedFunc` into a `C_ClipboardTextReceivedFunc`.
wrap_ClipboardTextReceivedFunc :: 
    Maybe (Ptr (FunPtr C_ClipboardTextReceivedFunc)) ->
    ClipboardTextReceivedFunc_WithClosures ->
    C_ClipboardTextReceivedFunc
wrap_ClipboardTextReceivedFunc gi'funptrptr gi'cb clipboard text data_ = do
    clipboard' <- (newObject Gtk.Clipboard.Clipboard) clipboard
    maybeText <-
        if text == nullPtr
        then return Nothing
        else do
            text' <- cstringToText text
            return $ Just text'
    gi'cb  clipboard' maybeText data_
    maybeReleaseFunPtr gi'funptrptr


-- callback ClipboardTargetsReceivedFunc
{- Callable
  { returnType = Nothing
  , returnMayBeNull = False
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , args =
      [ Arg
          { argCName = "clipboard"
          , argType =
              TInterface Name { namespace = "Gtk" , name = "Clipboard" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText = Just "the #GtkClipboard" , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "atoms"
          , argType =
              TCArray
                False
                (-1)
                2
                (TInterface Name { namespace = "Gdk" , name = "Atom" })
          , direction = DirectionIn
          , mayBeNull = True
          , argDoc =
              Documentation
                { rawDocText =
                    Just
                      "the supported targets,\n  as array of #GdkAtom, or %NULL if retrieving the data failed."
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "n_atoms"
          , argType = TBasicType TInt
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText = Just "the length of the @atoms array."
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "data"
          , argType = TBasicType TPtr
          , direction = DirectionIn
          , mayBeNull = True
          , argDoc =
              Documentation
                { rawDocText =
                    Just
                      "the @user_data supplied to\n  gtk_clipboard_request_targets()."
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = 3
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation
        { rawDocText =
            Just
              "A function to be called when the results of gtk_clipboard_request_targets()\nare received, or when the request fails."
        , sinceVersion = Just "2.4"
        }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_ClipboardTargetsReceivedFunc =
    Ptr Gtk.Clipboard.Clipboard ->
    Ptr (Ptr Gdk.Atom.Atom) ->
    Int32 ->
    Ptr () ->
    IO ()

-- Args: [ Arg
--           { argCName = "clipboard"
--           , argType =
--               TInterface Name { namespace = "Gtk" , name = "Clipboard" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "the #GtkClipboard" , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "atoms"
--           , argType =
--               TCArray
--                 False
--                 (-1)
--                 2
--                 (TInterface Name { namespace = "Gdk" , name = "Atom" })
--           , direction = DirectionIn
--           , mayBeNull = True
--           , argDoc =
--               Documentation
--                 { rawDocText =
--                     Just
--                       "the supported targets,\n  as array of #GdkAtom, or %NULL if retrieving the data failed."
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "n_atoms"
--           , argType = TBasicType TInt
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "the length of the @atoms array."
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "data"
--           , argType = TBasicType TPtr
--           , direction = DirectionIn
--           , mayBeNull = True
--           , argDoc =
--               Documentation
--                 { rawDocText =
--                     Just
--                       "the @user_data supplied to\n  gtk_clipboard_request_targets()."
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = 3
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: [ Arg
--              { argCName = "n_atoms"
--              , argType = TBasicType TInt
--              , direction = DirectionIn
--              , mayBeNull = False
--              , argDoc =
--                  Documentation
--                    { rawDocText = Just "the length of the @atoms array."
--                    , sinceVersion = Nothing
--                    }
--              , argScope = ScopeTypeInvalid
--              , argClosure = -1
--              , argDestroy = -1
--              , argCallerAllocates = False
--              , transfer = TransferNothing
--              }
--          ]
-- returnType: Nothing
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_ClipboardTargetsReceivedFunc :: FunPtr C_ClipboardTargetsReceivedFunc -> C_ClipboardTargetsReceivedFunc

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_ClipboardTargetsReceivedFunc ::
    (B.CallStack.HasCallStack, MonadIO m, Gtk.Clipboard.IsClipboard a) =>
    FunPtr C_ClipboardTargetsReceivedFunc
    -> a
    -- ^ /@clipboard@/: the t'GI.Gtk.Objects.Clipboard.Clipboard'
    -> Maybe ([Gdk.Atom.Atom])
    -- ^ /@atoms@/: the supported targets,
    --   as array of t'GI.Gdk.Structs.Atom.Atom', or 'P.Nothing' if retrieving the data failed.
    -> Ptr ()
    -- ^ /@data@/: the /@userData@/ supplied to
    --   'GI.Gtk.Objects.Clipboard.clipboardRequestTargets'.
    -> m ()
dynamic_ClipboardTargetsReceivedFunc __funPtr clipboard atoms data_ = liftIO $ do
    let nAtoms = case atoms of
            Nothing -> 0
            Just jAtoms -> fromIntegral $ P.length jAtoms
    clipboard' <- unsafeManagedPtrCastPtr clipboard
    maybeAtoms <- case atoms of
        Nothing -> return nullPtr
        Just jAtoms -> do
            jAtoms' <- mapM unsafeManagedPtrGetPtr jAtoms
            jAtoms'' <- packPtrArray jAtoms'
            return jAtoms''
    (__dynamic_C_ClipboardTargetsReceivedFunc __funPtr) clipboard' maybeAtoms nAtoms data_
    touchManagedPtr clipboard
    whenJust atoms (mapM_ touchManagedPtr)
    freeMem maybeAtoms
    return ()

-- | Generate a function pointer callable from C code, from a `C_ClipboardTargetsReceivedFunc`.
foreign import ccall "wrapper"
    mk_ClipboardTargetsReceivedFunc :: C_ClipboardTargetsReceivedFunc -> IO (FunPtr C_ClipboardTargetsReceivedFunc)

-- | A function to be called when the results of 'GI.Gtk.Objects.Clipboard.clipboardRequestTargets'
-- are received, or when the request fails.
-- 
-- /Since: 2.4/
type ClipboardTargetsReceivedFunc =
    Gtk.Clipboard.Clipboard
    -- ^ /@clipboard@/: the t'GI.Gtk.Objects.Clipboard.Clipboard'
    -> Maybe [Gdk.Atom.Atom]
    -- ^ /@atoms@/: the supported targets,
    --   as array of t'GI.Gdk.Structs.Atom.Atom', or 'P.Nothing' if retrieving the data failed.
    -> IO ()

-- | A convenience synonym for @`Nothing` :: `Maybe` `ClipboardTargetsReceivedFunc`@.
noClipboardTargetsReceivedFunc :: Maybe ClipboardTargetsReceivedFunc
noClipboardTargetsReceivedFunc = Nothing

-- | A function to be called when the results of 'GI.Gtk.Objects.Clipboard.clipboardRequestTargets'
-- are received, or when the request fails.
-- 
-- /Since: 2.4/
type ClipboardTargetsReceivedFunc_WithClosures =
    Gtk.Clipboard.Clipboard
    -- ^ /@clipboard@/: the t'GI.Gtk.Objects.Clipboard.Clipboard'
    -> Maybe [Gdk.Atom.Atom]
    -- ^ /@atoms@/: the supported targets,
    --   as array of t'GI.Gdk.Structs.Atom.Atom', or 'P.Nothing' if retrieving the data failed.
    -> Ptr ()
    -- ^ /@data@/: the /@userData@/ supplied to
    --   'GI.Gtk.Objects.Clipboard.clipboardRequestTargets'.
    -> IO ()

-- | A convenience synonym for @`Nothing` :: `Maybe` `ClipboardTargetsReceivedFunc_WithClosures`@.
noClipboardTargetsReceivedFunc_WithClosures :: Maybe ClipboardTargetsReceivedFunc_WithClosures
noClipboardTargetsReceivedFunc_WithClosures = Nothing

-- | A simple wrapper that ignores the closure arguments.
drop_closures_ClipboardTargetsReceivedFunc :: ClipboardTargetsReceivedFunc -> ClipboardTargetsReceivedFunc_WithClosures
drop_closures_ClipboardTargetsReceivedFunc _f clipboard atoms _ = _f clipboard atoms

-- | Wrap the callback into a `GClosure`.
genClosure_ClipboardTargetsReceivedFunc :: MonadIO m => ClipboardTargetsReceivedFunc -> m (GClosure C_ClipboardTargetsReceivedFunc)
genClosure_ClipboardTargetsReceivedFunc cb = liftIO $ do
    let cb' = drop_closures_ClipboardTargetsReceivedFunc cb
    let cb'' = wrap_ClipboardTargetsReceivedFunc Nothing cb'
    mk_ClipboardTargetsReceivedFunc cb'' >>= B.GClosure.newGClosure


-- | Wrap a `ClipboardTargetsReceivedFunc` into a `C_ClipboardTargetsReceivedFunc`.
wrap_ClipboardTargetsReceivedFunc :: 
    Maybe (Ptr (FunPtr C_ClipboardTargetsReceivedFunc)) ->
    ClipboardTargetsReceivedFunc_WithClosures ->
    C_ClipboardTargetsReceivedFunc
wrap_ClipboardTargetsReceivedFunc gi'funptrptr gi'cb clipboard atoms nAtoms data_ = do
    clipboard' <- (newObject Gtk.Clipboard.Clipboard) clipboard
    maybeAtoms <-
        if atoms == nullPtr
        then return Nothing
        else do
            atoms' <- (unpackPtrArrayWithLength nAtoms) atoms
            atoms'' <- mapM (newPtr Gdk.Atom.Atom) atoms'
            return $ Just atoms''
    gi'cb  clipboard' maybeAtoms data_
    maybeReleaseFunPtr gi'funptrptr


-- callback ClipboardRichTextReceivedFunc
{- Callable
  { returnType = Nothing
  , returnMayBeNull = False
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , args =
      [ Arg
          { argCName = "clipboard"
          , argType =
              TInterface Name { namespace = "Gtk" , name = "Clipboard" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText = Just "the #GtkClipboard" , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "format"
          , argType = TInterface Name { namespace = "Gdk" , name = "Atom" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText = Just "The format of the rich text"
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "text"
          , argType = TBasicType TUTF8
          , direction = DirectionIn
          , mayBeNull = True
          , argDoc =
              Documentation
                { rawDocText =
                    Just
                      "the rich text received, as\n  a UTF-8 encoded string, or %NULL if retrieving the data failed."
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "length"
          , argType = TBasicType TUInt64
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText = Just "Length of the text."
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "data"
          , argType = TBasicType TPtr
          , direction = DirectionIn
          , mayBeNull = True
          , argDoc =
              Documentation
                { rawDocText =
                    Just
                      "the @user_data supplied to\n  gtk_clipboard_request_rich_text()."
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = 4
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation
        { rawDocText =
            Just
              "A function to be called when the results of\ngtk_clipboard_request_rich_text() are received, or when the request\nfails."
        , sinceVersion = Just "2.10"
        }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_ClipboardRichTextReceivedFunc =
    Ptr Gtk.Clipboard.Clipboard ->
    Ptr Gdk.Atom.Atom ->
    CString ->
    Word64 ->
    Ptr () ->
    IO ()

-- Args: [ Arg
--           { argCName = "clipboard"
--           , argType =
--               TInterface Name { namespace = "Gtk" , name = "Clipboard" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "the #GtkClipboard" , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "format"
--           , argType = TInterface Name { namespace = "Gdk" , name = "Atom" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "The format of the rich text"
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "text"
--           , argType = TBasicType TUTF8
--           , direction = DirectionIn
--           , mayBeNull = True
--           , argDoc =
--               Documentation
--                 { rawDocText =
--                     Just
--                       "the rich text received, as\n  a UTF-8 encoded string, or %NULL if retrieving the data failed."
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "length"
--           , argType = TBasicType TUInt64
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "Length of the text."
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "data"
--           , argType = TBasicType TPtr
--           , direction = DirectionIn
--           , mayBeNull = True
--           , argDoc =
--               Documentation
--                 { rawDocText =
--                     Just
--                       "the @user_data supplied to\n  gtk_clipboard_request_rich_text()."
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = 4
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Nothing
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_ClipboardRichTextReceivedFunc :: FunPtr C_ClipboardRichTextReceivedFunc -> C_ClipboardRichTextReceivedFunc

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_ClipboardRichTextReceivedFunc ::
    (B.CallStack.HasCallStack, MonadIO m, Gtk.Clipboard.IsClipboard a) =>
    FunPtr C_ClipboardRichTextReceivedFunc
    -> a
    -- ^ /@clipboard@/: the t'GI.Gtk.Objects.Clipboard.Clipboard'
    -> Gdk.Atom.Atom
    -- ^ /@format@/: The format of the rich text
    -> Maybe (T.Text)
    -- ^ /@text@/: the rich text received, as
    --   a UTF-8 encoded string, or 'P.Nothing' if retrieving the data failed.
    -> Word64
    -- ^ /@length@/: Length of the text.
    -> Ptr ()
    -- ^ /@data@/: the /@userData@/ supplied to
    --   'GI.Gtk.Objects.Clipboard.clipboardRequestRichText'.
    -> m ()
dynamic_ClipboardRichTextReceivedFunc __funPtr clipboard format text length_ data_ = liftIO $ do
    clipboard' <- unsafeManagedPtrCastPtr clipboard
    format' <- unsafeManagedPtrGetPtr format
    maybeText <- case text of
        Nothing -> return nullPtr
        Just jText -> do
            jText' <- textToCString jText
            return jText'
    (__dynamic_C_ClipboardRichTextReceivedFunc __funPtr) clipboard' format' maybeText length_ data_
    touchManagedPtr clipboard
    touchManagedPtr format
    freeMem maybeText
    return ()

-- | Generate a function pointer callable from C code, from a `C_ClipboardRichTextReceivedFunc`.
foreign import ccall "wrapper"
    mk_ClipboardRichTextReceivedFunc :: C_ClipboardRichTextReceivedFunc -> IO (FunPtr C_ClipboardRichTextReceivedFunc)

-- | A function to be called when the results of
-- 'GI.Gtk.Objects.Clipboard.clipboardRequestRichText' are received, or when the request
-- fails.
-- 
-- /Since: 2.10/
type ClipboardRichTextReceivedFunc =
    Gtk.Clipboard.Clipboard
    -- ^ /@clipboard@/: the t'GI.Gtk.Objects.Clipboard.Clipboard'
    -> Gdk.Atom.Atom
    -- ^ /@format@/: The format of the rich text
    -> Maybe T.Text
    -- ^ /@text@/: the rich text received, as
    --   a UTF-8 encoded string, or 'P.Nothing' if retrieving the data failed.
    -> Word64
    -- ^ /@length@/: Length of the text.
    -> IO ()

-- | A convenience synonym for @`Nothing` :: `Maybe` `ClipboardRichTextReceivedFunc`@.
noClipboardRichTextReceivedFunc :: Maybe ClipboardRichTextReceivedFunc
noClipboardRichTextReceivedFunc = Nothing

-- | A function to be called when the results of
-- 'GI.Gtk.Objects.Clipboard.clipboardRequestRichText' are received, or when the request
-- fails.
-- 
-- /Since: 2.10/
type ClipboardRichTextReceivedFunc_WithClosures =
    Gtk.Clipboard.Clipboard
    -- ^ /@clipboard@/: the t'GI.Gtk.Objects.Clipboard.Clipboard'
    -> Gdk.Atom.Atom
    -- ^ /@format@/: The format of the rich text
    -> Maybe T.Text
    -- ^ /@text@/: the rich text received, as
    --   a UTF-8 encoded string, or 'P.Nothing' if retrieving the data failed.
    -> Word64
    -- ^ /@length@/: Length of the text.
    -> Ptr ()
    -- ^ /@data@/: the /@userData@/ supplied to
    --   'GI.Gtk.Objects.Clipboard.clipboardRequestRichText'.
    -> IO ()

-- | A convenience synonym for @`Nothing` :: `Maybe` `ClipboardRichTextReceivedFunc_WithClosures`@.
noClipboardRichTextReceivedFunc_WithClosures :: Maybe ClipboardRichTextReceivedFunc_WithClosures
noClipboardRichTextReceivedFunc_WithClosures = Nothing

-- | A simple wrapper that ignores the closure arguments.
drop_closures_ClipboardRichTextReceivedFunc :: ClipboardRichTextReceivedFunc -> ClipboardRichTextReceivedFunc_WithClosures
drop_closures_ClipboardRichTextReceivedFunc _f clipboard format text length_ _ = _f clipboard format text length_

-- | Wrap the callback into a `GClosure`.
genClosure_ClipboardRichTextReceivedFunc :: MonadIO m => ClipboardRichTextReceivedFunc -> m (GClosure C_ClipboardRichTextReceivedFunc)
genClosure_ClipboardRichTextReceivedFunc cb = liftIO $ do
    let cb' = drop_closures_ClipboardRichTextReceivedFunc cb
    let cb'' = wrap_ClipboardRichTextReceivedFunc Nothing cb'
    mk_ClipboardRichTextReceivedFunc cb'' >>= B.GClosure.newGClosure


-- | Wrap a `ClipboardRichTextReceivedFunc` into a `C_ClipboardRichTextReceivedFunc`.
wrap_ClipboardRichTextReceivedFunc :: 
    Maybe (Ptr (FunPtr C_ClipboardRichTextReceivedFunc)) ->
    ClipboardRichTextReceivedFunc_WithClosures ->
    C_ClipboardRichTextReceivedFunc
wrap_ClipboardRichTextReceivedFunc gi'funptrptr gi'cb clipboard format text length_ data_ = do
    clipboard' <- (newObject Gtk.Clipboard.Clipboard) clipboard
    format' <- (newPtr Gdk.Atom.Atom) format
    maybeText <-
        if text == nullPtr
        then return Nothing
        else do
            text' <- cstringToText text
            return $ Just text'
    gi'cb  clipboard' format' maybeText length_ data_
    maybeReleaseFunPtr gi'funptrptr


-- callback ClipboardReceivedFunc
{- Callable
  { returnType = Nothing
  , returnMayBeNull = False
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , args =
      [ Arg
          { argCName = "clipboard"
          , argType =
              TInterface Name { namespace = "Gtk" , name = "Clipboard" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText = Just "the #GtkClipboard" , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "selection_data"
          , argType =
              TInterface Name { namespace = "Gtk" , name = "SelectionData" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText =
                    Just
                      "a #GtkSelectionData containing the data was received.\n  If retrieving the data failed, then then length field\n  of @selection_data will be negative."
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "data"
          , argType = TBasicType TPtr
          , direction = DirectionIn
          , mayBeNull = True
          , argDoc =
              Documentation
                { rawDocText =
                    Just
                      "the @user_data supplied to\n  gtk_clipboard_request_contents()."
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = 2
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation
        { rawDocText =
            Just
              "A function to be called when the results of gtk_clipboard_request_contents()\nare received, or when the request fails."
        , sinceVersion = Nothing
        }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_ClipboardReceivedFunc =
    Ptr Gtk.Clipboard.Clipboard ->
    Ptr Gtk.SelectionData.SelectionData ->
    Ptr () ->
    IO ()

-- Args: [ Arg
--           { argCName = "clipboard"
--           , argType =
--               TInterface Name { namespace = "Gtk" , name = "Clipboard" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "the #GtkClipboard" , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "selection_data"
--           , argType =
--               TInterface Name { namespace = "Gtk" , name = "SelectionData" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText =
--                     Just
--                       "a #GtkSelectionData containing the data was received.\n  If retrieving the data failed, then then length field\n  of @selection_data will be negative."
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "data"
--           , argType = TBasicType TPtr
--           , direction = DirectionIn
--           , mayBeNull = True
--           , argDoc =
--               Documentation
--                 { rawDocText =
--                     Just
--                       "the @user_data supplied to\n  gtk_clipboard_request_contents()."
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = 2
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Nothing
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_ClipboardReceivedFunc :: FunPtr C_ClipboardReceivedFunc -> C_ClipboardReceivedFunc

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_ClipboardReceivedFunc ::
    (B.CallStack.HasCallStack, MonadIO m, Gtk.Clipboard.IsClipboard a) =>
    FunPtr C_ClipboardReceivedFunc
    -> a
    -- ^ /@clipboard@/: the t'GI.Gtk.Objects.Clipboard.Clipboard'
    -> Gtk.SelectionData.SelectionData
    -- ^ /@selectionData@/: a t'GI.Gtk.Structs.SelectionData.SelectionData' containing the data was received.
    --   If retrieving the data failed, then then length field
    --   of /@selectionData@/ will be negative.
    -> Ptr ()
    -- ^ /@data@/: the /@userData@/ supplied to
    --   'GI.Gtk.Objects.Clipboard.clipboardRequestContents'.
    -> m ()
dynamic_ClipboardReceivedFunc __funPtr clipboard selectionData data_ = liftIO $ do
    clipboard' <- unsafeManagedPtrCastPtr clipboard
    selectionData' <- unsafeManagedPtrGetPtr selectionData
    (__dynamic_C_ClipboardReceivedFunc __funPtr) clipboard' selectionData' data_
    touchManagedPtr clipboard
    touchManagedPtr selectionData
    return ()

-- | Generate a function pointer callable from C code, from a `C_ClipboardReceivedFunc`.
foreign import ccall "wrapper"
    mk_ClipboardReceivedFunc :: C_ClipboardReceivedFunc -> IO (FunPtr C_ClipboardReceivedFunc)

-- | A function to be called when the results of 'GI.Gtk.Objects.Clipboard.clipboardRequestContents'
-- are received, or when the request fails.
type ClipboardReceivedFunc =
    Gtk.Clipboard.Clipboard
    -- ^ /@clipboard@/: the t'GI.Gtk.Objects.Clipboard.Clipboard'
    -> Gtk.SelectionData.SelectionData
    -- ^ /@selectionData@/: a t'GI.Gtk.Structs.SelectionData.SelectionData' containing the data was received.
    --   If retrieving the data failed, then then length field
    --   of /@selectionData@/ will be negative.
    -> IO ()

-- | A convenience synonym for @`Nothing` :: `Maybe` `ClipboardReceivedFunc`@.
noClipboardReceivedFunc :: Maybe ClipboardReceivedFunc
noClipboardReceivedFunc = Nothing

-- | A function to be called when the results of 'GI.Gtk.Objects.Clipboard.clipboardRequestContents'
-- are received, or when the request fails.
type ClipboardReceivedFunc_WithClosures =
    Gtk.Clipboard.Clipboard
    -- ^ /@clipboard@/: the t'GI.Gtk.Objects.Clipboard.Clipboard'
    -> Gtk.SelectionData.SelectionData
    -- ^ /@selectionData@/: a t'GI.Gtk.Structs.SelectionData.SelectionData' containing the data was received.
    --   If retrieving the data failed, then then length field
    --   of /@selectionData@/ will be negative.
    -> Ptr ()
    -- ^ /@data@/: the /@userData@/ supplied to
    --   'GI.Gtk.Objects.Clipboard.clipboardRequestContents'.
    -> IO ()

-- | A convenience synonym for @`Nothing` :: `Maybe` `ClipboardReceivedFunc_WithClosures`@.
noClipboardReceivedFunc_WithClosures :: Maybe ClipboardReceivedFunc_WithClosures
noClipboardReceivedFunc_WithClosures = Nothing

-- | A simple wrapper that ignores the closure arguments.
drop_closures_ClipboardReceivedFunc :: ClipboardReceivedFunc -> ClipboardReceivedFunc_WithClosures
drop_closures_ClipboardReceivedFunc _f clipboard selectionData _ = _f clipboard selectionData

-- | Wrap the callback into a `GClosure`.
genClosure_ClipboardReceivedFunc :: MonadIO m => ClipboardReceivedFunc -> m (GClosure C_ClipboardReceivedFunc)
genClosure_ClipboardReceivedFunc cb = liftIO $ do
    let cb' = drop_closures_ClipboardReceivedFunc cb
    let cb'' = wrap_ClipboardReceivedFunc Nothing cb'
    mk_ClipboardReceivedFunc cb'' >>= B.GClosure.newGClosure


-- | Wrap a `ClipboardReceivedFunc` into a `C_ClipboardReceivedFunc`.
wrap_ClipboardReceivedFunc :: 
    Maybe (Ptr (FunPtr C_ClipboardReceivedFunc)) ->
    ClipboardReceivedFunc_WithClosures ->
    C_ClipboardReceivedFunc
wrap_ClipboardReceivedFunc gi'funptrptr gi'cb clipboard selectionData data_ = do
    clipboard' <- (newObject Gtk.Clipboard.Clipboard) clipboard
    B.ManagedPtr.withTransient  selectionData $ \selectionData' -> do
        gi'cb  clipboard' selectionData' data_
        maybeReleaseFunPtr gi'funptrptr


-- callback ClipboardImageReceivedFunc
{- Callable
  { returnType = Nothing
  , returnMayBeNull = False
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , args =
      [ Arg
          { argCName = "clipboard"
          , argType =
              TInterface Name { namespace = "Gtk" , name = "Clipboard" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText = Just "the #GtkClipboard" , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "pixbuf"
          , argType =
              TInterface Name { namespace = "GdkPixbuf" , name = "Pixbuf" }
          , direction = DirectionIn
          , mayBeNull = True
          , argDoc =
              Documentation
                { rawDocText = Just "the received image" , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "data"
          , argType = TBasicType TPtr
          , direction = DirectionIn
          , mayBeNull = True
          , argDoc =
              Documentation
                { rawDocText =
                    Just "the @user_data supplied to\n  gtk_clipboard_request_image()."
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = 2
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation
        { rawDocText =
            Just
              "A function to be called when the results of gtk_clipboard_request_image()\nare received, or when the request fails."
        , sinceVersion = Just "2.6"
        }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_ClipboardImageReceivedFunc =
    Ptr Gtk.Clipboard.Clipboard ->
    Ptr GdkPixbuf.Pixbuf.Pixbuf ->
    Ptr () ->
    IO ()

-- Args: [ Arg
--           { argCName = "clipboard"
--           , argType =
--               TInterface Name { namespace = "Gtk" , name = "Clipboard" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "the #GtkClipboard" , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "pixbuf"
--           , argType =
--               TInterface Name { namespace = "GdkPixbuf" , name = "Pixbuf" }
--           , direction = DirectionIn
--           , mayBeNull = True
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "the received image" , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "data"
--           , argType = TBasicType TPtr
--           , direction = DirectionIn
--           , mayBeNull = True
--           , argDoc =
--               Documentation
--                 { rawDocText =
--                     Just "the @user_data supplied to\n  gtk_clipboard_request_image()."
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = 2
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Nothing
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_ClipboardImageReceivedFunc :: FunPtr C_ClipboardImageReceivedFunc -> C_ClipboardImageReceivedFunc

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_ClipboardImageReceivedFunc ::
    (B.CallStack.HasCallStack, MonadIO m, Gtk.Clipboard.IsClipboard a, GdkPixbuf.Pixbuf.IsPixbuf b) =>
    FunPtr C_ClipboardImageReceivedFunc
    -> a
    -- ^ /@clipboard@/: the t'GI.Gtk.Objects.Clipboard.Clipboard'
    -> Maybe (b)
    -- ^ /@pixbuf@/: the received image
    -> Ptr ()
    -- ^ /@data@/: the /@userData@/ supplied to
    --   'GI.Gtk.Objects.Clipboard.clipboardRequestImage'.
    -> m ()
dynamic_ClipboardImageReceivedFunc __funPtr clipboard pixbuf data_ = liftIO $ do
    clipboard' <- unsafeManagedPtrCastPtr clipboard
    maybePixbuf <- case pixbuf of
        Nothing -> return nullPtr
        Just jPixbuf -> do
            jPixbuf' <- unsafeManagedPtrCastPtr jPixbuf
            return jPixbuf'
    (__dynamic_C_ClipboardImageReceivedFunc __funPtr) clipboard' maybePixbuf data_
    touchManagedPtr clipboard
    whenJust pixbuf touchManagedPtr
    return ()

-- | Generate a function pointer callable from C code, from a `C_ClipboardImageReceivedFunc`.
foreign import ccall "wrapper"
    mk_ClipboardImageReceivedFunc :: C_ClipboardImageReceivedFunc -> IO (FunPtr C_ClipboardImageReceivedFunc)

-- | A function to be called when the results of 'GI.Gtk.Objects.Clipboard.clipboardRequestImage'
-- are received, or when the request fails.
-- 
-- /Since: 2.6/
type ClipboardImageReceivedFunc =
    Gtk.Clipboard.Clipboard
    -- ^ /@clipboard@/: the t'GI.Gtk.Objects.Clipboard.Clipboard'
    -> Maybe GdkPixbuf.Pixbuf.Pixbuf
    -- ^ /@pixbuf@/: the received image
    -> IO ()

-- | A convenience synonym for @`Nothing` :: `Maybe` `ClipboardImageReceivedFunc`@.
noClipboardImageReceivedFunc :: Maybe ClipboardImageReceivedFunc
noClipboardImageReceivedFunc = Nothing

-- | A function to be called when the results of 'GI.Gtk.Objects.Clipboard.clipboardRequestImage'
-- are received, or when the request fails.
-- 
-- /Since: 2.6/
type ClipboardImageReceivedFunc_WithClosures =
    Gtk.Clipboard.Clipboard
    -- ^ /@clipboard@/: the t'GI.Gtk.Objects.Clipboard.Clipboard'
    -> Maybe GdkPixbuf.Pixbuf.Pixbuf
    -- ^ /@pixbuf@/: the received image
    -> Ptr ()
    -- ^ /@data@/: the /@userData@/ supplied to
    --   'GI.Gtk.Objects.Clipboard.clipboardRequestImage'.
    -> IO ()

-- | A convenience synonym for @`Nothing` :: `Maybe` `ClipboardImageReceivedFunc_WithClosures`@.
noClipboardImageReceivedFunc_WithClosures :: Maybe ClipboardImageReceivedFunc_WithClosures
noClipboardImageReceivedFunc_WithClosures = Nothing

-- | A simple wrapper that ignores the closure arguments.
drop_closures_ClipboardImageReceivedFunc :: ClipboardImageReceivedFunc -> ClipboardImageReceivedFunc_WithClosures
drop_closures_ClipboardImageReceivedFunc _f clipboard pixbuf _ = _f clipboard pixbuf

-- | Wrap the callback into a `GClosure`.
genClosure_ClipboardImageReceivedFunc :: MonadIO m => ClipboardImageReceivedFunc -> m (GClosure C_ClipboardImageReceivedFunc)
genClosure_ClipboardImageReceivedFunc cb = liftIO $ do
    let cb' = drop_closures_ClipboardImageReceivedFunc cb
    let cb'' = wrap_ClipboardImageReceivedFunc Nothing cb'
    mk_ClipboardImageReceivedFunc cb'' >>= B.GClosure.newGClosure


-- | Wrap a `ClipboardImageReceivedFunc` into a `C_ClipboardImageReceivedFunc`.
wrap_ClipboardImageReceivedFunc :: 
    Maybe (Ptr (FunPtr C_ClipboardImageReceivedFunc)) ->
    ClipboardImageReceivedFunc_WithClosures ->
    C_ClipboardImageReceivedFunc
wrap_ClipboardImageReceivedFunc gi'funptrptr gi'cb clipboard pixbuf data_ = do
    clipboard' <- (newObject Gtk.Clipboard.Clipboard) clipboard
    maybePixbuf <-
        if pixbuf == nullPtr
        then return Nothing
        else do
            pixbuf' <- (newObject GdkPixbuf.Pixbuf.Pixbuf) pixbuf
            return $ Just pixbuf'
    gi'cb  clipboard' maybePixbuf data_
    maybeReleaseFunPtr gi'funptrptr


-- callback ClipboardGetFunc
{- Callable
  { returnType = Nothing
  , returnMayBeNull = False
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , args =
      [ Arg
          { argCName = "clipboard"
          , argType =
              TInterface Name { namespace = "Gtk" , name = "Clipboard" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText = Just "the #GtkClipboard" , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "selection_data"
          , argType =
              TInterface Name { namespace = "Gtk" , name = "SelectionData" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText =
                    Just
                      "a #GtkSelectionData argument in which the requested\n  data should be stored."
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "info"
          , argType = TBasicType TUInt
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText =
                    Just
                      "the info field corresponding to the requested target from the\n  #GtkTargetEntry array passed to gtk_clipboard_set_with_data() or\n  gtk_clipboard_set_with_owner()."
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "user_data_or_owner"
          , argType = TBasicType TPtr
          , direction = DirectionIn
          , mayBeNull = True
          , argDoc =
              Documentation
                { rawDocText =
                    Just
                      "the @user_data argument passed to\n  gtk_clipboard_set_with_data(), or the @owner argument passed to\n  gtk_clipboard_set_with_owner()"
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation
        { rawDocText =
            Just
              "A function that will be called to provide the contents of the selection.\nIf multiple types of data were advertised, the requested type can\nbe determined from the @info parameter or by checking the target field\nof @selection_data. If the data could successfully be converted into\nthen it should be stored into the @selection_data object by\ncalling gtk_selection_data_set() (or related functions such\nas gtk_selection_data_set_text()). If no data is set, the requestor\nwill be informed that the attempt to get the data failed."
        , sinceVersion = Nothing
        }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_ClipboardGetFunc =
    Ptr Gtk.Clipboard.Clipboard ->
    Ptr Gtk.SelectionData.SelectionData ->
    Word32 ->
    Ptr () ->
    IO ()

-- Args: [ Arg
--           { argCName = "clipboard"
--           , argType =
--               TInterface Name { namespace = "Gtk" , name = "Clipboard" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "the #GtkClipboard" , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "selection_data"
--           , argType =
--               TInterface Name { namespace = "Gtk" , name = "SelectionData" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText =
--                     Just
--                       "a #GtkSelectionData argument in which the requested\n  data should be stored."
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "info"
--           , argType = TBasicType TUInt
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText =
--                     Just
--                       "the info field corresponding to the requested target from the\n  #GtkTargetEntry array passed to gtk_clipboard_set_with_data() or\n  gtk_clipboard_set_with_owner()."
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "user_data_or_owner"
--           , argType = TBasicType TPtr
--           , direction = DirectionIn
--           , mayBeNull = True
--           , argDoc =
--               Documentation
--                 { rawDocText =
--                     Just
--                       "the @user_data argument passed to\n  gtk_clipboard_set_with_data(), or the @owner argument passed to\n  gtk_clipboard_set_with_owner()"
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Nothing
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_ClipboardGetFunc :: FunPtr C_ClipboardGetFunc -> C_ClipboardGetFunc

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_ClipboardGetFunc ::
    (B.CallStack.HasCallStack, MonadIO m, Gtk.Clipboard.IsClipboard a) =>
    FunPtr C_ClipboardGetFunc
    -> a
    -- ^ /@clipboard@/: the t'GI.Gtk.Objects.Clipboard.Clipboard'
    -> Gtk.SelectionData.SelectionData
    -- ^ /@selectionData@/: a t'GI.Gtk.Structs.SelectionData.SelectionData' argument in which the requested
    --   data should be stored.
    -> Word32
    -- ^ /@info@/: the info field corresponding to the requested target from the
    --   t'GI.Gtk.Structs.TargetEntry.TargetEntry' array passed to @/gtk_clipboard_set_with_data()/@ or
    --   @/gtk_clipboard_set_with_owner()/@.
    -> Ptr ()
    -- ^ /@userDataOrOwner@/: the /@userData@/ argument passed to
    --   @/gtk_clipboard_set_with_data()/@, or the /@owner@/ argument passed to
    --   @/gtk_clipboard_set_with_owner()/@
    -> m ()
dynamic_ClipboardGetFunc __funPtr clipboard selectionData info userDataOrOwner = liftIO $ do
    clipboard' <- unsafeManagedPtrCastPtr clipboard
    selectionData' <- unsafeManagedPtrGetPtr selectionData
    (__dynamic_C_ClipboardGetFunc __funPtr) clipboard' selectionData' info userDataOrOwner
    touchManagedPtr clipboard
    touchManagedPtr selectionData
    return ()

-- | Generate a function pointer callable from C code, from a `C_ClipboardGetFunc`.
foreign import ccall "wrapper"
    mk_ClipboardGetFunc :: C_ClipboardGetFunc -> IO (FunPtr C_ClipboardGetFunc)

-- | A function that will be called to provide the contents of the selection.
-- If multiple types of data were advertised, the requested type can
-- be determined from the /@info@/ parameter or by checking the target field
-- of /@selectionData@/. If the data could successfully be converted into
-- then it should be stored into the /@selectionData@/ object by
-- calling 'GI.Gtk.Structs.SelectionData.selectionDataSet' (or related functions such
-- as 'GI.Gtk.Structs.SelectionData.selectionDataSetText'). If no data is set, the requestor
-- will be informed that the attempt to get the data failed.
type ClipboardGetFunc =
    Gtk.Clipboard.Clipboard
    -- ^ /@clipboard@/: the t'GI.Gtk.Objects.Clipboard.Clipboard'
    -> Gtk.SelectionData.SelectionData
    -- ^ /@selectionData@/: a t'GI.Gtk.Structs.SelectionData.SelectionData' argument in which the requested
    --   data should be stored.
    -> Word32
    -- ^ /@info@/: the info field corresponding to the requested target from the
    --   t'GI.Gtk.Structs.TargetEntry.TargetEntry' array passed to @/gtk_clipboard_set_with_data()/@ or
    --   @/gtk_clipboard_set_with_owner()/@.
    -> Ptr ()
    -- ^ /@userDataOrOwner@/: the /@userData@/ argument passed to
    --   @/gtk_clipboard_set_with_data()/@, or the /@owner@/ argument passed to
    --   @/gtk_clipboard_set_with_owner()/@
    -> IO ()

-- | A convenience synonym for @`Nothing` :: `Maybe` `ClipboardGetFunc`@.
noClipboardGetFunc :: Maybe ClipboardGetFunc
noClipboardGetFunc = Nothing

-- | Wrap the callback into a `GClosure`.
genClosure_ClipboardGetFunc :: MonadIO m => ClipboardGetFunc -> m (GClosure C_ClipboardGetFunc)
genClosure_ClipboardGetFunc cb = liftIO $ do
    let cb' = wrap_ClipboardGetFunc Nothing cb
    mk_ClipboardGetFunc cb' >>= B.GClosure.newGClosure


-- | Wrap a `ClipboardGetFunc` into a `C_ClipboardGetFunc`.
wrap_ClipboardGetFunc :: 
    Maybe (Ptr (FunPtr C_ClipboardGetFunc)) ->
    ClipboardGetFunc ->
    C_ClipboardGetFunc
wrap_ClipboardGetFunc gi'funptrptr gi'cb clipboard selectionData info userDataOrOwner = do
    clipboard' <- (newObject Gtk.Clipboard.Clipboard) clipboard
    B.ManagedPtr.withTransient  selectionData $ \selectionData' -> do
        gi'cb  clipboard' selectionData' info userDataOrOwner
        maybeReleaseFunPtr gi'funptrptr


-- callback ClipboardClearFunc
{- Callable
  { returnType = Nothing
  , returnMayBeNull = False
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , args =
      [ Arg
          { argCName = "clipboard"
          , argType =
              TInterface Name { namespace = "Gtk" , name = "Clipboard" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText = Just "the #GtkClipboard" , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "user_data_or_owner"
          , argType = TBasicType TPtr
          , direction = DirectionIn
          , mayBeNull = True
          , argDoc =
              Documentation
                { rawDocText =
                    Just
                      "the @user_data argument passed to gtk_clipboard_set_with_data(),\n  or the @owner argument passed to gtk_clipboard_set_with_owner()"
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation
        { rawDocText =
            Just
              "A function that will be called when the contents of the clipboard are changed\nor cleared. Once this has called, the @user_data_or_owner argument\nwill not be used again."
        , sinceVersion = Nothing
        }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_ClipboardClearFunc =
    Ptr Gtk.Clipboard.Clipboard ->
    Ptr () ->
    IO ()

-- Args: [ Arg
--           { argCName = "clipboard"
--           , argType =
--               TInterface Name { namespace = "Gtk" , name = "Clipboard" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "the #GtkClipboard" , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "user_data_or_owner"
--           , argType = TBasicType TPtr
--           , direction = DirectionIn
--           , mayBeNull = True
--           , argDoc =
--               Documentation
--                 { rawDocText =
--                     Just
--                       "the @user_data argument passed to gtk_clipboard_set_with_data(),\n  or the @owner argument passed to gtk_clipboard_set_with_owner()"
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Nothing
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_ClipboardClearFunc :: FunPtr C_ClipboardClearFunc -> C_ClipboardClearFunc

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_ClipboardClearFunc ::
    (B.CallStack.HasCallStack, MonadIO m, Gtk.Clipboard.IsClipboard a) =>
    FunPtr C_ClipboardClearFunc
    -> a
    -- ^ /@clipboard@/: the t'GI.Gtk.Objects.Clipboard.Clipboard'
    -> Ptr ()
    -- ^ /@userDataOrOwner@/: the /@userData@/ argument passed to @/gtk_clipboard_set_with_data()/@,
    --   or the /@owner@/ argument passed to @/gtk_clipboard_set_with_owner()/@
    -> m ()
dynamic_ClipboardClearFunc __funPtr clipboard userDataOrOwner = liftIO $ do
    clipboard' <- unsafeManagedPtrCastPtr clipboard
    (__dynamic_C_ClipboardClearFunc __funPtr) clipboard' userDataOrOwner
    touchManagedPtr clipboard
    return ()

-- | Generate a function pointer callable from C code, from a `C_ClipboardClearFunc`.
foreign import ccall "wrapper"
    mk_ClipboardClearFunc :: C_ClipboardClearFunc -> IO (FunPtr C_ClipboardClearFunc)

-- | A function that will be called when the contents of the clipboard are changed
-- or cleared. Once this has called, the /@userDataOrOwner@/ argument
-- will not be used again.
type ClipboardClearFunc =
    Gtk.Clipboard.Clipboard
    -- ^ /@clipboard@/: the t'GI.Gtk.Objects.Clipboard.Clipboard'
    -> Ptr ()
    -- ^ /@userDataOrOwner@/: the /@userData@/ argument passed to @/gtk_clipboard_set_with_data()/@,
    --   or the /@owner@/ argument passed to @/gtk_clipboard_set_with_owner()/@
    -> IO ()

-- | A convenience synonym for @`Nothing` :: `Maybe` `ClipboardClearFunc`@.
noClipboardClearFunc :: Maybe ClipboardClearFunc
noClipboardClearFunc = Nothing

-- | Wrap the callback into a `GClosure`.
genClosure_ClipboardClearFunc :: MonadIO m => ClipboardClearFunc -> m (GClosure C_ClipboardClearFunc)
genClosure_ClipboardClearFunc cb = liftIO $ do
    let cb' = wrap_ClipboardClearFunc Nothing cb
    mk_ClipboardClearFunc cb' >>= B.GClosure.newGClosure


-- | Wrap a `ClipboardClearFunc` into a `C_ClipboardClearFunc`.
wrap_ClipboardClearFunc :: 
    Maybe (Ptr (FunPtr C_ClipboardClearFunc)) ->
    ClipboardClearFunc ->
    C_ClipboardClearFunc
wrap_ClipboardClearFunc gi'funptrptr gi'cb clipboard userDataOrOwner = do
    clipboard' <- (newObject Gtk.Clipboard.Clipboard) clipboard
    gi'cb  clipboard' userDataOrOwner
    maybeReleaseFunPtr gi'funptrptr


-- callback CellLayoutDataFunc
{- Callable
  { returnType = Nothing
  , returnMayBeNull = False
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , args =
      [ Arg
          { argCName = "cell_layout"
          , argType =
              TInterface Name { namespace = "Gtk" , name = "CellLayout" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText = Just "a #GtkCellLayout" , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "cell"
          , argType =
              TInterface Name { namespace = "Gtk" , name = "CellRenderer" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText = Just "the cell renderer whose value is to be set"
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "tree_model"
          , argType =
              TInterface Name { namespace = "Gtk" , name = "TreeModel" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText = Just "the model" , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "iter"
          , argType =
              TInterface Name { namespace = "Gtk" , name = "TreeIter" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText =
                    Just "a #GtkTreeIter indicating the row to set the value for"
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "data"
          , argType = TBasicType TPtr
          , direction = DirectionIn
          , mayBeNull = True
          , argDoc =
              Documentation
                { rawDocText =
                    Just "user data passed to gtk_cell_layout_set_cell_data_func()"
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = 4
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation
        { rawDocText =
            Just
              "A function which should set the value of @cell_layout\8217s cell renderer(s)\nas appropriate."
        , sinceVersion = Nothing
        }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_CellLayoutDataFunc =
    Ptr Gtk.CellLayout.CellLayout ->
    Ptr Gtk.CellRenderer.CellRenderer ->
    Ptr Gtk.TreeModel.TreeModel ->
    Ptr Gtk.TreeIter.TreeIter ->
    Ptr () ->
    IO ()

-- Args: [ Arg
--           { argCName = "cell_layout"
--           , argType =
--               TInterface Name { namespace = "Gtk" , name = "CellLayout" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "a #GtkCellLayout" , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "cell"
--           , argType =
--               TInterface Name { namespace = "Gtk" , name = "CellRenderer" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "the cell renderer whose value is to be set"
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "tree_model"
--           , argType =
--               TInterface Name { namespace = "Gtk" , name = "TreeModel" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "the model" , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "iter"
--           , argType =
--               TInterface Name { namespace = "Gtk" , name = "TreeIter" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText =
--                     Just "a #GtkTreeIter indicating the row to set the value for"
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "data"
--           , argType = TBasicType TPtr
--           , direction = DirectionIn
--           , mayBeNull = True
--           , argDoc =
--               Documentation
--                 { rawDocText =
--                     Just "user data passed to gtk_cell_layout_set_cell_data_func()"
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = 4
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Nothing
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_CellLayoutDataFunc :: FunPtr C_CellLayoutDataFunc -> C_CellLayoutDataFunc

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_CellLayoutDataFunc ::
    (B.CallStack.HasCallStack, MonadIO m, Gtk.CellLayout.IsCellLayout a, Gtk.CellRenderer.IsCellRenderer b, Gtk.TreeModel.IsTreeModel c) =>
    FunPtr C_CellLayoutDataFunc
    -> a
    -- ^ /@cellLayout@/: a t'GI.Gtk.Interfaces.CellLayout.CellLayout'
    -> b
    -- ^ /@cell@/: the cell renderer whose value is to be set
    -> c
    -- ^ /@treeModel@/: the model
    -> Gtk.TreeIter.TreeIter
    -- ^ /@iter@/: a t'GI.Gtk.Structs.TreeIter.TreeIter' indicating the row to set the value for
    -> Ptr ()
    -- ^ /@data@/: user data passed to 'GI.Gtk.Interfaces.CellLayout.cellLayoutSetCellDataFunc'
    -> m ()
dynamic_CellLayoutDataFunc __funPtr cellLayout cell treeModel iter data_ = liftIO $ do
    cellLayout' <- unsafeManagedPtrCastPtr cellLayout
    cell' <- unsafeManagedPtrCastPtr cell
    treeModel' <- unsafeManagedPtrCastPtr treeModel
    iter' <- unsafeManagedPtrGetPtr iter
    (__dynamic_C_CellLayoutDataFunc __funPtr) cellLayout' cell' treeModel' iter' data_
    touchManagedPtr cellLayout
    touchManagedPtr cell
    touchManagedPtr treeModel
    touchManagedPtr iter
    return ()

-- | Generate a function pointer callable from C code, from a `C_CellLayoutDataFunc`.
foreign import ccall "wrapper"
    mk_CellLayoutDataFunc :: C_CellLayoutDataFunc -> IO (FunPtr C_CellLayoutDataFunc)

-- | A function which should set the value of /@cellLayout@/’s cell renderer(s)
-- as appropriate.
type CellLayoutDataFunc =
    Gtk.CellLayout.CellLayout
    -- ^ /@cellLayout@/: a t'GI.Gtk.Interfaces.CellLayout.CellLayout'
    -> Gtk.CellRenderer.CellRenderer
    -- ^ /@cell@/: the cell renderer whose value is to be set
    -> Gtk.TreeModel.TreeModel
    -- ^ /@treeModel@/: the model
    -> Gtk.TreeIter.TreeIter
    -- ^ /@iter@/: a t'GI.Gtk.Structs.TreeIter.TreeIter' indicating the row to set the value for
    -> IO ()

-- | A convenience synonym for @`Nothing` :: `Maybe` `CellLayoutDataFunc`@.
noCellLayoutDataFunc :: Maybe CellLayoutDataFunc
noCellLayoutDataFunc = Nothing

-- | A function which should set the value of /@cellLayout@/’s cell renderer(s)
-- as appropriate.
type CellLayoutDataFunc_WithClosures =
    Gtk.CellLayout.CellLayout
    -- ^ /@cellLayout@/: a t'GI.Gtk.Interfaces.CellLayout.CellLayout'
    -> Gtk.CellRenderer.CellRenderer
    -- ^ /@cell@/: the cell renderer whose value is to be set
    -> Gtk.TreeModel.TreeModel
    -- ^ /@treeModel@/: the model
    -> Gtk.TreeIter.TreeIter
    -- ^ /@iter@/: a t'GI.Gtk.Structs.TreeIter.TreeIter' indicating the row to set the value for
    -> Ptr ()
    -- ^ /@data@/: user data passed to 'GI.Gtk.Interfaces.CellLayout.cellLayoutSetCellDataFunc'
    -> IO ()

-- | A convenience synonym for @`Nothing` :: `Maybe` `CellLayoutDataFunc_WithClosures`@.
noCellLayoutDataFunc_WithClosures :: Maybe CellLayoutDataFunc_WithClosures
noCellLayoutDataFunc_WithClosures = Nothing

-- | A simple wrapper that ignores the closure arguments.
drop_closures_CellLayoutDataFunc :: CellLayoutDataFunc -> CellLayoutDataFunc_WithClosures
drop_closures_CellLayoutDataFunc _f cellLayout cell treeModel iter _ = _f cellLayout cell treeModel iter

-- | Wrap the callback into a `GClosure`.
genClosure_CellLayoutDataFunc :: MonadIO m => CellLayoutDataFunc -> m (GClosure C_CellLayoutDataFunc)
genClosure_CellLayoutDataFunc cb = liftIO $ do
    let cb' = drop_closures_CellLayoutDataFunc cb
    let cb'' = wrap_CellLayoutDataFunc Nothing cb'
    mk_CellLayoutDataFunc cb'' >>= B.GClosure.newGClosure


-- | Wrap a `CellLayoutDataFunc` into a `C_CellLayoutDataFunc`.
wrap_CellLayoutDataFunc :: 
    Maybe (Ptr (FunPtr C_CellLayoutDataFunc)) ->
    CellLayoutDataFunc_WithClosures ->
    C_CellLayoutDataFunc
wrap_CellLayoutDataFunc gi'funptrptr gi'cb cellLayout cell treeModel iter data_ = do
    cellLayout' <- (newObject Gtk.CellLayout.CellLayout) cellLayout
    cell' <- (newObject Gtk.CellRenderer.CellRenderer) cell
    treeModel' <- (newObject Gtk.TreeModel.TreeModel) treeModel
    B.ManagedPtr.withTransient  iter $ \iter' -> do
        gi'cb  cellLayout' cell' treeModel' iter' data_
        maybeReleaseFunPtr gi'funptrptr


-- callback CellCallback
{- Callable
  { returnType = Just (TBasicType TBoolean)
  , returnMayBeNull = False
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation
        { rawDocText = Just "%TRUE to stop iterating over cells."
        , sinceVersion = Nothing
        }
  , args =
      [ Arg
          { argCName = "renderer"
          , argType =
              TInterface Name { namespace = "Gtk" , name = "CellRenderer" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText = Just "the cell renderer to operate on"
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "data"
          , argType = TBasicType TPtr
          , direction = DirectionIn
          , mayBeNull = True
          , argDoc =
              Documentation
                { rawDocText = Just "user-supplied data" , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = 1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation
        { rawDocText =
            Just
              "The type of the callback functions used for iterating over\nthe cell renderers of a #GtkCellArea, see gtk_cell_area_foreach()."
        , sinceVersion = Nothing
        }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_CellCallback =
    Ptr Gtk.CellRenderer.CellRenderer ->
    Ptr () ->
    IO CInt

-- Args: [ Arg
--           { argCName = "renderer"
--           , argType =
--               TInterface Name { namespace = "Gtk" , name = "CellRenderer" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "the cell renderer to operate on"
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "data"
--           , argType = TBasicType TPtr
--           , direction = DirectionIn
--           , mayBeNull = True
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "user-supplied data" , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = 1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Just (TBasicType TBoolean)
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_CellCallback :: FunPtr C_CellCallback -> C_CellCallback

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_CellCallback ::
    (B.CallStack.HasCallStack, MonadIO m, Gtk.CellRenderer.IsCellRenderer a) =>
    FunPtr C_CellCallback
    -> a
    -- ^ /@renderer@/: the cell renderer to operate on
    -> Ptr ()
    -- ^ /@data@/: user-supplied data
    -> m Bool
    -- ^ __Returns:__ 'P.True' to stop iterating over cells.
dynamic_CellCallback __funPtr renderer data_ = liftIO $ do
    renderer' <- unsafeManagedPtrCastPtr renderer
    result <- (__dynamic_C_CellCallback __funPtr) renderer' data_
    let result' = (/= 0) result
    touchManagedPtr renderer
    return result'

-- | Generate a function pointer callable from C code, from a `C_CellCallback`.
foreign import ccall "wrapper"
    mk_CellCallback :: C_CellCallback -> IO (FunPtr C_CellCallback)

-- | The type of the callback functions used for iterating over
-- the cell renderers of a t'GI.Gtk.Objects.CellArea.CellArea', see 'GI.Gtk.Objects.CellArea.cellAreaForeach'.
type CellCallback =
    Gtk.CellRenderer.CellRenderer
    -- ^ /@renderer@/: the cell renderer to operate on
    -> IO Bool
    -- ^ __Returns:__ 'P.True' to stop iterating over cells.

-- | A convenience synonym for @`Nothing` :: `Maybe` `CellCallback`@.
noCellCallback :: Maybe CellCallback
noCellCallback = Nothing

-- | The type of the callback functions used for iterating over
-- the cell renderers of a t'GI.Gtk.Objects.CellArea.CellArea', see 'GI.Gtk.Objects.CellArea.cellAreaForeach'.
type CellCallback_WithClosures =
    Gtk.CellRenderer.CellRenderer
    -- ^ /@renderer@/: the cell renderer to operate on
    -> Ptr ()
    -- ^ /@data@/: user-supplied data
    -> IO Bool
    -- ^ __Returns:__ 'P.True' to stop iterating over cells.

-- | A convenience synonym for @`Nothing` :: `Maybe` `CellCallback_WithClosures`@.
noCellCallback_WithClosures :: Maybe CellCallback_WithClosures
noCellCallback_WithClosures = Nothing

-- | A simple wrapper that ignores the closure arguments.
drop_closures_CellCallback :: CellCallback -> CellCallback_WithClosures
drop_closures_CellCallback _f renderer _ = _f renderer

-- | Wrap the callback into a `GClosure`.
genClosure_CellCallback :: MonadIO m => CellCallback -> m (GClosure C_CellCallback)
genClosure_CellCallback cb = liftIO $ do
    let cb' = drop_closures_CellCallback cb
    let cb'' = wrap_CellCallback Nothing cb'
    mk_CellCallback cb'' >>= B.GClosure.newGClosure


-- | Wrap a `CellCallback` into a `C_CellCallback`.
wrap_CellCallback :: 
    Maybe (Ptr (FunPtr C_CellCallback)) ->
    CellCallback_WithClosures ->
    C_CellCallback
wrap_CellCallback gi'funptrptr gi'cb renderer data_ = do
    renderer' <- (newObject Gtk.CellRenderer.CellRenderer) renderer
    result <- gi'cb  renderer' data_
    maybeReleaseFunPtr gi'funptrptr
    let result' = (fromIntegral . fromEnum) result
    return result'


-- callback CellAllocCallback
{- Callable
  { returnType = Just (TBasicType TBoolean)
  , returnMayBeNull = False
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation
        { rawDocText = Just "%TRUE to stop iterating over cells."
        , sinceVersion = Nothing
        }
  , args =
      [ Arg
          { argCName = "renderer"
          , argType =
              TInterface Name { namespace = "Gtk" , name = "CellRenderer" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText = Just "the cell renderer to operate on"
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "cell_area"
          , argType =
              TInterface Name { namespace = "Gdk" , name = "Rectangle" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText =
                    Just
                      "the area allocated to @renderer inside the rectangle\n    provided to gtk_cell_area_foreach_alloc()."
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "cell_background"
          , argType =
              TInterface Name { namespace = "Gdk" , name = "Rectangle" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText =
                    Just
                      "the background area for @renderer inside the\n    background area provided to gtk_cell_area_foreach_alloc()."
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "data"
          , argType = TBasicType TPtr
          , direction = DirectionIn
          , mayBeNull = True
          , argDoc =
              Documentation
                { rawDocText = Just "user-supplied data" , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = 3
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation
        { rawDocText =
            Just
              "The type of the callback functions used for iterating over the\ncell renderers and their allocated areas inside a #GtkCellArea,\nsee gtk_cell_area_foreach_alloc()."
        , sinceVersion = Nothing
        }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_CellAllocCallback =
    Ptr Gtk.CellRenderer.CellRenderer ->
    Ptr Gdk.Rectangle.Rectangle ->
    Ptr Gdk.Rectangle.Rectangle ->
    Ptr () ->
    IO CInt

-- Args: [ Arg
--           { argCName = "renderer"
--           , argType =
--               TInterface Name { namespace = "Gtk" , name = "CellRenderer" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "the cell renderer to operate on"
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "cell_area"
--           , argType =
--               TInterface Name { namespace = "Gdk" , name = "Rectangle" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText =
--                     Just
--                       "the area allocated to @renderer inside the rectangle\n    provided to gtk_cell_area_foreach_alloc()."
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "cell_background"
--           , argType =
--               TInterface Name { namespace = "Gdk" , name = "Rectangle" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText =
--                     Just
--                       "the background area for @renderer inside the\n    background area provided to gtk_cell_area_foreach_alloc()."
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "data"
--           , argType = TBasicType TPtr
--           , direction = DirectionIn
--           , mayBeNull = True
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "user-supplied data" , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = 3
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Just (TBasicType TBoolean)
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_CellAllocCallback :: FunPtr C_CellAllocCallback -> C_CellAllocCallback

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_CellAllocCallback ::
    (B.CallStack.HasCallStack, MonadIO m, Gtk.CellRenderer.IsCellRenderer a) =>
    FunPtr C_CellAllocCallback
    -> a
    -- ^ /@renderer@/: the cell renderer to operate on
    -> Gdk.Rectangle.Rectangle
    -- ^ /@cellArea@/: the area allocated to /@renderer@/ inside the rectangle
    --     provided to 'GI.Gtk.Objects.CellArea.cellAreaForeachAlloc'.
    -> Gdk.Rectangle.Rectangle
    -- ^ /@cellBackground@/: the background area for /@renderer@/ inside the
    --     background area provided to 'GI.Gtk.Objects.CellArea.cellAreaForeachAlloc'.
    -> Ptr ()
    -- ^ /@data@/: user-supplied data
    -> m Bool
    -- ^ __Returns:__ 'P.True' to stop iterating over cells.
dynamic_CellAllocCallback __funPtr renderer cellArea cellBackground data_ = liftIO $ do
    renderer' <- unsafeManagedPtrCastPtr renderer
    cellArea' <- unsafeManagedPtrGetPtr cellArea
    cellBackground' <- unsafeManagedPtrGetPtr cellBackground
    result <- (__dynamic_C_CellAllocCallback __funPtr) renderer' cellArea' cellBackground' data_
    let result' = (/= 0) result
    touchManagedPtr renderer
    touchManagedPtr cellArea
    touchManagedPtr cellBackground
    return result'

-- | Generate a function pointer callable from C code, from a `C_CellAllocCallback`.
foreign import ccall "wrapper"
    mk_CellAllocCallback :: C_CellAllocCallback -> IO (FunPtr C_CellAllocCallback)

-- | The type of the callback functions used for iterating over the
-- cell renderers and their allocated areas inside a t'GI.Gtk.Objects.CellArea.CellArea',
-- see 'GI.Gtk.Objects.CellArea.cellAreaForeachAlloc'.
type CellAllocCallback =
    Gtk.CellRenderer.CellRenderer
    -- ^ /@renderer@/: the cell renderer to operate on
    -> Gdk.Rectangle.Rectangle
    -- ^ /@cellArea@/: the area allocated to /@renderer@/ inside the rectangle
    --     provided to 'GI.Gtk.Objects.CellArea.cellAreaForeachAlloc'.
    -> Gdk.Rectangle.Rectangle
    -- ^ /@cellBackground@/: the background area for /@renderer@/ inside the
    --     background area provided to 'GI.Gtk.Objects.CellArea.cellAreaForeachAlloc'.
    -> IO Bool
    -- ^ __Returns:__ 'P.True' to stop iterating over cells.

-- | A convenience synonym for @`Nothing` :: `Maybe` `CellAllocCallback`@.
noCellAllocCallback :: Maybe CellAllocCallback
noCellAllocCallback = Nothing

-- | The type of the callback functions used for iterating over the
-- cell renderers and their allocated areas inside a t'GI.Gtk.Objects.CellArea.CellArea',
-- see 'GI.Gtk.Objects.CellArea.cellAreaForeachAlloc'.
type CellAllocCallback_WithClosures =
    Gtk.CellRenderer.CellRenderer
    -- ^ /@renderer@/: the cell renderer to operate on
    -> Gdk.Rectangle.Rectangle
    -- ^ /@cellArea@/: the area allocated to /@renderer@/ inside the rectangle
    --     provided to 'GI.Gtk.Objects.CellArea.cellAreaForeachAlloc'.
    -> Gdk.Rectangle.Rectangle
    -- ^ /@cellBackground@/: the background area for /@renderer@/ inside the
    --     background area provided to 'GI.Gtk.Objects.CellArea.cellAreaForeachAlloc'.
    -> Ptr ()
    -- ^ /@data@/: user-supplied data
    -> IO Bool
    -- ^ __Returns:__ 'P.True' to stop iterating over cells.

-- | A convenience synonym for @`Nothing` :: `Maybe` `CellAllocCallback_WithClosures`@.
noCellAllocCallback_WithClosures :: Maybe CellAllocCallback_WithClosures
noCellAllocCallback_WithClosures = Nothing

-- | A simple wrapper that ignores the closure arguments.
drop_closures_CellAllocCallback :: CellAllocCallback -> CellAllocCallback_WithClosures
drop_closures_CellAllocCallback _f renderer cellArea cellBackground _ = _f renderer cellArea cellBackground

-- | Wrap the callback into a `GClosure`.
genClosure_CellAllocCallback :: MonadIO m => CellAllocCallback -> m (GClosure C_CellAllocCallback)
genClosure_CellAllocCallback cb = liftIO $ do
    let cb' = drop_closures_CellAllocCallback cb
    let cb'' = wrap_CellAllocCallback Nothing cb'
    mk_CellAllocCallback cb'' >>= B.GClosure.newGClosure


-- | Wrap a `CellAllocCallback` into a `C_CellAllocCallback`.
wrap_CellAllocCallback :: 
    Maybe (Ptr (FunPtr C_CellAllocCallback)) ->
    CellAllocCallback_WithClosures ->
    C_CellAllocCallback
wrap_CellAllocCallback gi'funptrptr gi'cb renderer cellArea cellBackground data_ = do
    renderer' <- (newObject Gtk.CellRenderer.CellRenderer) renderer
    B.ManagedPtr.withTransient  cellArea $ \cellArea' -> do
        B.ManagedPtr.withTransient  cellBackground $ \cellBackground' -> do
            result <- gi'cb  renderer' cellArea' cellBackground' data_
            maybeReleaseFunPtr gi'funptrptr
            let result' = (fromIntegral . fromEnum) result
            return result'


-- callback Callback
{- Callable
  { returnType = Nothing
  , returnMayBeNull = False
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , args =
      [ Arg
          { argCName = "widget"
          , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText = Just "the widget to operate on"
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "data"
          , argType = TBasicType TPtr
          , direction = DirectionIn
          , mayBeNull = True
          , argDoc =
              Documentation
                { rawDocText = Just "user-supplied data" , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = 1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation
        { rawDocText =
            Just
              "The type of the callback functions used for e.g. iterating over\nthe children of a container, see gtk_container_foreach()."
        , sinceVersion = Nothing
        }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_Callback =
    Ptr Gtk.Widget.Widget ->
    Ptr () ->
    IO ()

-- Args: [ Arg
--           { argCName = "widget"
--           , argType = TInterface Name { namespace = "Gtk" , name = "Widget" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "the widget to operate on"
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "data"
--           , argType = TBasicType TPtr
--           , direction = DirectionIn
--           , mayBeNull = True
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "user-supplied data" , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = 1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Nothing
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_Callback :: FunPtr C_Callback -> C_Callback

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_Callback ::
    (B.CallStack.HasCallStack, MonadIO m, Gtk.Widget.IsWidget a) =>
    FunPtr C_Callback
    -> a
    -- ^ /@widget@/: the widget to operate on
    -> Ptr ()
    -- ^ /@data@/: user-supplied data
    -> m ()
dynamic_Callback __funPtr widget data_ = liftIO $ do
    widget' <- unsafeManagedPtrCastPtr widget
    (__dynamic_C_Callback __funPtr) widget' data_
    touchManagedPtr widget
    return ()

-- | Generate a function pointer callable from C code, from a `C_Callback`.
foreign import ccall "wrapper"
    mk_Callback :: C_Callback -> IO (FunPtr C_Callback)

-- | The type of the callback functions used for e.g. iterating over
-- the children of a container, see 'GI.Gtk.Objects.Container.containerForeach'.
type Callback =
    Gtk.Widget.Widget
    -- ^ /@widget@/: the widget to operate on
    -> IO ()

-- | A convenience synonym for @`Nothing` :: `Maybe` `Callback`@.
noCallback :: Maybe Callback
noCallback = Nothing

-- | The type of the callback functions used for e.g. iterating over
-- the children of a container, see 'GI.Gtk.Objects.Container.containerForeach'.
type Callback_WithClosures =
    Gtk.Widget.Widget
    -- ^ /@widget@/: the widget to operate on
    -> Ptr ()
    -- ^ /@data@/: user-supplied data
    -> IO ()

-- | A convenience synonym for @`Nothing` :: `Maybe` `Callback_WithClosures`@.
noCallback_WithClosures :: Maybe Callback_WithClosures
noCallback_WithClosures = Nothing

-- | A simple wrapper that ignores the closure arguments.
drop_closures_Callback :: Callback -> Callback_WithClosures
drop_closures_Callback _f widget _ = _f widget

-- | Wrap the callback into a `GClosure`.
genClosure_Callback :: MonadIO m => Callback -> m (GClosure C_Callback)
genClosure_Callback cb = liftIO $ do
    let cb' = drop_closures_Callback cb
    let cb'' = wrap_Callback Nothing cb'
    mk_Callback cb'' >>= B.GClosure.newGClosure


-- | Wrap a `Callback` into a `C_Callback`.
wrap_Callback :: 
    Maybe (Ptr (FunPtr C_Callback)) ->
    Callback_WithClosures ->
    C_Callback
wrap_Callback gi'funptrptr gi'cb widget data_ = do
    widget' <- (newObject Gtk.Widget.Widget) widget
    gi'cb  widget' data_
    maybeReleaseFunPtr gi'funptrptr


-- callback CalendarDetailFunc
{- Callable
  { returnType = Just (TBasicType TUTF8)
  , returnMayBeNull = True
  , returnTransfer = TransferEverything
  , returnDocumentation =
      Documentation
        { rawDocText =
            Just
              "Newly allocated string with Pango markup\n    with details for the specified day or %NULL."
        , sinceVersion = Nothing
        }
  , args =
      [ Arg
          { argCName = "calendar"
          , argType =
              TInterface Name { namespace = "Gtk" , name = "Calendar" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText = Just "a #GtkCalendar." , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "year"
          , argType = TBasicType TUInt
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText = Just "the year for which details are needed."
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "month"
          , argType = TBasicType TUInt
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText = Just "the month for which details are needed."
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "day"
          , argType = TBasicType TUInt
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText =
                    Just "the day of @month for which details are needed."
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "user_data"
          , argType = TBasicType TPtr
          , direction = DirectionIn
          , mayBeNull = True
          , argDoc =
              Documentation
                { rawDocText =
                    Just "the data passed with gtk_calendar_set_detail_func()."
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = 4
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation
        { rawDocText =
            Just
              "This kind of functions provide Pango markup with detail information for the\nspecified day. Examples for such details are holidays or appointments. The\nfunction returns %NULL when no information is available."
        , sinceVersion = Just "2.14"
        }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_CalendarDetailFunc =
    Ptr Gtk.Calendar.Calendar ->
    Word32 ->
    Word32 ->
    Word32 ->
    Ptr () ->
    IO CString

-- Args: [ Arg
--           { argCName = "calendar"
--           , argType =
--               TInterface Name { namespace = "Gtk" , name = "Calendar" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "a #GtkCalendar." , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "year"
--           , argType = TBasicType TUInt
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "the year for which details are needed."
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "month"
--           , argType = TBasicType TUInt
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "the month for which details are needed."
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "day"
--           , argType = TBasicType TUInt
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText =
--                     Just "the day of @month for which details are needed."
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "user_data"
--           , argType = TBasicType TPtr
--           , direction = DirectionIn
--           , mayBeNull = True
--           , argDoc =
--               Documentation
--                 { rawDocText =
--                     Just "the data passed with gtk_calendar_set_detail_func()."
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = 4
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Just (TBasicType TUTF8)
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_CalendarDetailFunc :: FunPtr C_CalendarDetailFunc -> C_CalendarDetailFunc

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_CalendarDetailFunc ::
    (B.CallStack.HasCallStack, MonadIO m, Gtk.Calendar.IsCalendar a) =>
    FunPtr C_CalendarDetailFunc
    -> a
    -- ^ /@calendar@/: a t'GI.Gtk.Objects.Calendar.Calendar'.
    -> Word32
    -- ^ /@year@/: the year for which details are needed.
    -> Word32
    -- ^ /@month@/: the month for which details are needed.
    -> Word32
    -- ^ /@day@/: the day of /@month@/ for which details are needed.
    -> Ptr ()
    -- ^ /@userData@/: the data passed with 'GI.Gtk.Objects.Calendar.calendarSetDetailFunc'.
    -> m (Maybe T.Text)
    -- ^ __Returns:__ Newly allocated string with Pango markup
    --     with details for the specified day or 'P.Nothing'.
dynamic_CalendarDetailFunc __funPtr calendar year month day userData = liftIO $ do
    calendar' <- unsafeManagedPtrCastPtr calendar
    result <- (__dynamic_C_CalendarDetailFunc __funPtr) calendar' year month day userData
    maybeResult <- convertIfNonNull result $ \result' -> do
        result'' <- cstringToText result'
        freeMem result'
        return result''
    touchManagedPtr calendar
    return maybeResult

-- | Generate a function pointer callable from C code, from a `C_CalendarDetailFunc`.
foreign import ccall "wrapper"
    mk_CalendarDetailFunc :: C_CalendarDetailFunc -> IO (FunPtr C_CalendarDetailFunc)

-- | This kind of functions provide Pango markup with detail information for the
-- specified day. Examples for such details are holidays or appointments. The
-- function returns 'P.Nothing' when no information is available.
-- 
-- /Since: 2.14/
type CalendarDetailFunc =
    Gtk.Calendar.Calendar
    -- ^ /@calendar@/: a t'GI.Gtk.Objects.Calendar.Calendar'.
    -> Word32
    -- ^ /@year@/: the year for which details are needed.
    -> Word32
    -- ^ /@month@/: the month for which details are needed.
    -> Word32
    -- ^ /@day@/: the day of /@month@/ for which details are needed.
    -> IO (Maybe T.Text)
    -- ^ __Returns:__ Newly allocated string with Pango markup
    --     with details for the specified day or 'P.Nothing'.

-- | A convenience synonym for @`Nothing` :: `Maybe` `CalendarDetailFunc`@.
noCalendarDetailFunc :: Maybe CalendarDetailFunc
noCalendarDetailFunc = Nothing

-- | This kind of functions provide Pango markup with detail information for the
-- specified day. Examples for such details are holidays or appointments. The
-- function returns 'P.Nothing' when no information is available.
-- 
-- /Since: 2.14/
type CalendarDetailFunc_WithClosures =
    Gtk.Calendar.Calendar
    -- ^ /@calendar@/: a t'GI.Gtk.Objects.Calendar.Calendar'.
    -> Word32
    -- ^ /@year@/: the year for which details are needed.
    -> Word32
    -- ^ /@month@/: the month for which details are needed.
    -> Word32
    -- ^ /@day@/: the day of /@month@/ for which details are needed.
    -> Ptr ()
    -- ^ /@userData@/: the data passed with 'GI.Gtk.Objects.Calendar.calendarSetDetailFunc'.
    -> IO (Maybe T.Text)
    -- ^ __Returns:__ Newly allocated string with Pango markup
    --     with details for the specified day or 'P.Nothing'.

-- | A convenience synonym for @`Nothing` :: `Maybe` `CalendarDetailFunc_WithClosures`@.
noCalendarDetailFunc_WithClosures :: Maybe CalendarDetailFunc_WithClosures
noCalendarDetailFunc_WithClosures = Nothing

-- | A simple wrapper that ignores the closure arguments.
drop_closures_CalendarDetailFunc :: CalendarDetailFunc -> CalendarDetailFunc_WithClosures
drop_closures_CalendarDetailFunc _f calendar year month day _ = _f calendar year month day

-- | Wrap the callback into a `GClosure`.
genClosure_CalendarDetailFunc :: MonadIO m => CalendarDetailFunc -> m (GClosure C_CalendarDetailFunc)
genClosure_CalendarDetailFunc cb = liftIO $ do
    let cb' = drop_closures_CalendarDetailFunc cb
    let cb'' = wrap_CalendarDetailFunc Nothing cb'
    mk_CalendarDetailFunc cb'' >>= B.GClosure.newGClosure


-- | Wrap a `CalendarDetailFunc` into a `C_CalendarDetailFunc`.
wrap_CalendarDetailFunc :: 
    Maybe (Ptr (FunPtr C_CalendarDetailFunc)) ->
    CalendarDetailFunc_WithClosures ->
    C_CalendarDetailFunc
wrap_CalendarDetailFunc gi'funptrptr gi'cb calendar year month day userData = do
    calendar' <- (newObject Gtk.Calendar.Calendar) calendar
    result <- gi'cb  calendar' year month day userData
    maybeReleaseFunPtr gi'funptrptr
    maybeM FP.nullPtr result $ \result' -> do
        result'' <- textToCString result'
        return result''


-- callback BuilderConnectFunc
{- Callable
  { returnType = Nothing
  , returnMayBeNull = False
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , args =
      [ Arg
          { argCName = "builder"
          , argType =
              TInterface Name { namespace = "Gtk" , name = "Builder" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText = Just "a #GtkBuilder" , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "object"
          , argType =
              TInterface Name { namespace = "GObject" , name = "Object" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText = Just "object to connect a signal to"
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "signal_name"
          , argType = TBasicType TUTF8
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText = Just "name of the signal" , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "handler_name"
          , argType = TBasicType TUTF8
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText = Just "name of the handler"
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "connect_object"
          , argType =
              TInterface Name { namespace = "GObject" , name = "Object" }
          , direction = DirectionIn
          , mayBeNull = True
          , argDoc =
              Documentation
                { rawDocText =
                    Just "a #GObject, if non-%NULL, use g_signal_connect_object()"
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "flags"
          , argType =
              TInterface Name { namespace = "GObject" , name = "ConnectFlags" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText = Just "#GConnectFlags to use"
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "user_data"
          , argType = TBasicType TPtr
          , direction = DirectionIn
          , mayBeNull = True
          , argDoc =
              Documentation
                { rawDocText = Just "user data" , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = 6
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation
        { rawDocText =
            Just
              "This is the signature of a function used to connect signals.  It is used\nby the gtk_builder_connect_signals() and gtk_builder_connect_signals_full()\nmethods.  It is mainly intended for interpreted language bindings, but\ncould be useful where the programmer wants more control over the signal\nconnection process. Note that this function can only be called once,\nsubsequent calls will do nothing."
        , sinceVersion = Just "2.12"
        }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_BuilderConnectFunc =
    Ptr Gtk.Builder.Builder ->
    Ptr GObject.Object.Object ->
    CString ->
    CString ->
    Ptr GObject.Object.Object ->
    CUInt ->
    Ptr () ->
    IO ()

-- Args: [ Arg
--           { argCName = "builder"
--           , argType =
--               TInterface Name { namespace = "Gtk" , name = "Builder" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "a #GtkBuilder" , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "object"
--           , argType =
--               TInterface Name { namespace = "GObject" , name = "Object" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "object to connect a signal to"
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "signal_name"
--           , argType = TBasicType TUTF8
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "name of the signal" , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "handler_name"
--           , argType = TBasicType TUTF8
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "name of the handler"
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "connect_object"
--           , argType =
--               TInterface Name { namespace = "GObject" , name = "Object" }
--           , direction = DirectionIn
--           , mayBeNull = True
--           , argDoc =
--               Documentation
--                 { rawDocText =
--                     Just "a #GObject, if non-%NULL, use g_signal_connect_object()"
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "flags"
--           , argType =
--               TInterface Name { namespace = "GObject" , name = "ConnectFlags" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "#GConnectFlags to use"
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "user_data"
--           , argType = TBasicType TPtr
--           , direction = DirectionIn
--           , mayBeNull = True
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "user data" , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = 6
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Nothing
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_BuilderConnectFunc :: FunPtr C_BuilderConnectFunc -> C_BuilderConnectFunc

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_BuilderConnectFunc ::
    (B.CallStack.HasCallStack, MonadIO m, Gtk.Builder.IsBuilder a, GObject.Object.IsObject b, GObject.Object.IsObject c) =>
    FunPtr C_BuilderConnectFunc
    -> a
    -- ^ /@builder@/: a t'GI.Gtk.Objects.Builder.Builder'
    -> b
    -- ^ /@object@/: object to connect a signal to
    -> T.Text
    -- ^ /@signalName@/: name of the signal
    -> T.Text
    -- ^ /@handlerName@/: name of the handler
    -> Maybe (c)
    -- ^ /@connectObject@/: a t'GI.GObject.Objects.Object.Object', if non-'P.Nothing', use @/g_signal_connect_object()/@
    -> [GObject.Flags.ConnectFlags]
    -- ^ /@flags@/: t'GI.GObject.Flags.ConnectFlags' to use
    -> Ptr ()
    -- ^ /@userData@/: user data
    -> m ()
dynamic_BuilderConnectFunc __funPtr builder object signalName handlerName connectObject flags userData = liftIO $ do
    builder' <- unsafeManagedPtrCastPtr builder
    object' <- unsafeManagedPtrCastPtr object
    signalName' <- textToCString signalName
    handlerName' <- textToCString handlerName
    maybeConnectObject <- case connectObject of
        Nothing -> return nullPtr
        Just jConnectObject -> do
            jConnectObject' <- unsafeManagedPtrCastPtr jConnectObject
            return jConnectObject'
    let flags' = gflagsToWord flags
    (__dynamic_C_BuilderConnectFunc __funPtr) builder' object' signalName' handlerName' maybeConnectObject flags' userData
    touchManagedPtr builder
    touchManagedPtr object
    whenJust connectObject touchManagedPtr
    freeMem signalName'
    freeMem handlerName'
    return ()

-- | Generate a function pointer callable from C code, from a `C_BuilderConnectFunc`.
foreign import ccall "wrapper"
    mk_BuilderConnectFunc :: C_BuilderConnectFunc -> IO (FunPtr C_BuilderConnectFunc)

-- | This is the signature of a function used to connect signals.  It is used
-- by the 'GI.Gtk.Objects.Builder.builderConnectSignals' and 'GI.Gtk.Objects.Builder.builderConnectSignalsFull'
-- methods.  It is mainly intended for interpreted language bindings, but
-- could be useful where the programmer wants more control over the signal
-- connection process. Note that this function can only be called once,
-- subsequent calls will do nothing.
-- 
-- /Since: 2.12/
type BuilderConnectFunc =
    Gtk.Builder.Builder
    -- ^ /@builder@/: a t'GI.Gtk.Objects.Builder.Builder'
    -> GObject.Object.Object
    -- ^ /@object@/: object to connect a signal to
    -> T.Text
    -- ^ /@signalName@/: name of the signal
    -> T.Text
    -- ^ /@handlerName@/: name of the handler
    -> Maybe GObject.Object.Object
    -- ^ /@connectObject@/: a t'GI.GObject.Objects.Object.Object', if non-'P.Nothing', use @/g_signal_connect_object()/@
    -> [GObject.Flags.ConnectFlags]
    -- ^ /@flags@/: t'GI.GObject.Flags.ConnectFlags' to use
    -> IO ()

-- | A convenience synonym for @`Nothing` :: `Maybe` `BuilderConnectFunc`@.
noBuilderConnectFunc :: Maybe BuilderConnectFunc
noBuilderConnectFunc = Nothing

-- | This is the signature of a function used to connect signals.  It is used
-- by the 'GI.Gtk.Objects.Builder.builderConnectSignals' and 'GI.Gtk.Objects.Builder.builderConnectSignalsFull'
-- methods.  It is mainly intended for interpreted language bindings, but
-- could be useful where the programmer wants more control over the signal
-- connection process. Note that this function can only be called once,
-- subsequent calls will do nothing.
-- 
-- /Since: 2.12/
type BuilderConnectFunc_WithClosures =
    Gtk.Builder.Builder
    -- ^ /@builder@/: a t'GI.Gtk.Objects.Builder.Builder'
    -> GObject.Object.Object
    -- ^ /@object@/: object to connect a signal to
    -> T.Text
    -- ^ /@signalName@/: name of the signal
    -> T.Text
    -- ^ /@handlerName@/: name of the handler
    -> Maybe GObject.Object.Object
    -- ^ /@connectObject@/: a t'GI.GObject.Objects.Object.Object', if non-'P.Nothing', use @/g_signal_connect_object()/@
    -> [GObject.Flags.ConnectFlags]
    -- ^ /@flags@/: t'GI.GObject.Flags.ConnectFlags' to use
    -> Ptr ()
    -- ^ /@userData@/: user data
    -> IO ()

-- | A convenience synonym for @`Nothing` :: `Maybe` `BuilderConnectFunc_WithClosures`@.
noBuilderConnectFunc_WithClosures :: Maybe BuilderConnectFunc_WithClosures
noBuilderConnectFunc_WithClosures = Nothing

-- | A simple wrapper that ignores the closure arguments.
drop_closures_BuilderConnectFunc :: BuilderConnectFunc -> BuilderConnectFunc_WithClosures
drop_closures_BuilderConnectFunc _f builder object signalName handlerName connectObject flags _ = _f builder object signalName handlerName connectObject flags

-- | Wrap the callback into a `GClosure`.
genClosure_BuilderConnectFunc :: MonadIO m => BuilderConnectFunc -> m (GClosure C_BuilderConnectFunc)
genClosure_BuilderConnectFunc cb = liftIO $ do
    let cb' = drop_closures_BuilderConnectFunc cb
    let cb'' = wrap_BuilderConnectFunc Nothing cb'
    mk_BuilderConnectFunc cb'' >>= B.GClosure.newGClosure


-- | Wrap a `BuilderConnectFunc` into a `C_BuilderConnectFunc`.
wrap_BuilderConnectFunc :: 
    Maybe (Ptr (FunPtr C_BuilderConnectFunc)) ->
    BuilderConnectFunc_WithClosures ->
    C_BuilderConnectFunc
wrap_BuilderConnectFunc gi'funptrptr gi'cb builder object signalName handlerName connectObject flags userData = do
    builder' <- (newObject Gtk.Builder.Builder) builder
    object' <- (newObject GObject.Object.Object) object
    signalName' <- cstringToText signalName
    handlerName' <- cstringToText handlerName
    maybeConnectObject <-
        if connectObject == nullPtr
        then return Nothing
        else do
            connectObject' <- (newObject GObject.Object.Object) connectObject
            return $ Just connectObject'
    let flags' = wordToGFlags flags
    gi'cb  builder' object' signalName' handlerName' maybeConnectObject flags' userData
    maybeReleaseFunPtr gi'funptrptr


-- callback AssistantPageFunc
{- Callable
  { returnType = Just (TBasicType TInt)
  , returnMayBeNull = False
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation
        { rawDocText = Just "The next page number."
        , sinceVersion = Nothing
        }
  , args =
      [ Arg
          { argCName = "current_page"
          , argType = TBasicType TInt
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText =
                    Just "The page number used to calculate the next page."
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "data"
          , argType = TBasicType TPtr
          , direction = DirectionIn
          , mayBeNull = True
          , argDoc =
              Documentation
                { rawDocText = Just "user data." , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = 1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation
        { rawDocText =
            Just
              "A function used by gtk_assistant_set_forward_page_func() to know which\nis the next page given a current one. It\8217s called both for computing the\nnext page when the user presses the \8220forward\8221 button and for handling\nthe behavior of the \8220last\8221 button."
        , sinceVersion = Nothing
        }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_AssistantPageFunc =
    Int32 ->
    Ptr () ->
    IO Int32

-- Args: [ Arg
--           { argCName = "current_page"
--           , argType = TBasicType TInt
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText =
--                     Just "The page number used to calculate the next page."
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "data"
--           , argType = TBasicType TPtr
--           , direction = DirectionIn
--           , mayBeNull = True
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "user data." , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = 1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Just (TBasicType TInt)
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_AssistantPageFunc :: FunPtr C_AssistantPageFunc -> C_AssistantPageFunc

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_AssistantPageFunc ::
    (B.CallStack.HasCallStack, MonadIO m) =>
    FunPtr C_AssistantPageFunc
    -> Int32
    -- ^ /@currentPage@/: The page number used to calculate the next page.
    -> Ptr ()
    -- ^ /@data@/: user data.
    -> m Int32
    -- ^ __Returns:__ The next page number.
dynamic_AssistantPageFunc __funPtr currentPage data_ = liftIO $ do
    result <- (__dynamic_C_AssistantPageFunc __funPtr) currentPage data_
    return result

-- | Generate a function pointer callable from C code, from a `C_AssistantPageFunc`.
foreign import ccall "wrapper"
    mk_AssistantPageFunc :: C_AssistantPageFunc -> IO (FunPtr C_AssistantPageFunc)

-- | A function used by 'GI.Gtk.Objects.Assistant.assistantSetForwardPageFunc' to know which
-- is the next page given a current one. It’s called both for computing the
-- next page when the user presses the “forward” button and for handling
-- the behavior of the “last” button.
type AssistantPageFunc =
    Int32
    -- ^ /@currentPage@/: The page number used to calculate the next page.
    -> IO Int32
    -- ^ __Returns:__ The next page number.

-- | A convenience synonym for @`Nothing` :: `Maybe` `AssistantPageFunc`@.
noAssistantPageFunc :: Maybe AssistantPageFunc
noAssistantPageFunc = Nothing

-- | A function used by 'GI.Gtk.Objects.Assistant.assistantSetForwardPageFunc' to know which
-- is the next page given a current one. It’s called both for computing the
-- next page when the user presses the “forward” button and for handling
-- the behavior of the “last” button.
type AssistantPageFunc_WithClosures =
    Int32
    -- ^ /@currentPage@/: The page number used to calculate the next page.
    -> Ptr ()
    -- ^ /@data@/: user data.
    -> IO Int32
    -- ^ __Returns:__ The next page number.

-- | A convenience synonym for @`Nothing` :: `Maybe` `AssistantPageFunc_WithClosures`@.
noAssistantPageFunc_WithClosures :: Maybe AssistantPageFunc_WithClosures
noAssistantPageFunc_WithClosures = Nothing

-- | A simple wrapper that ignores the closure arguments.
drop_closures_AssistantPageFunc :: AssistantPageFunc -> AssistantPageFunc_WithClosures
drop_closures_AssistantPageFunc _f currentPage _ = _f currentPage

-- | Wrap the callback into a `GClosure`.
genClosure_AssistantPageFunc :: MonadIO m => AssistantPageFunc -> m (GClosure C_AssistantPageFunc)
genClosure_AssistantPageFunc cb = liftIO $ do
    let cb' = drop_closures_AssistantPageFunc cb
    let cb'' = wrap_AssistantPageFunc Nothing cb'
    mk_AssistantPageFunc cb'' >>= B.GClosure.newGClosure


-- | Wrap a `AssistantPageFunc` into a `C_AssistantPageFunc`.
wrap_AssistantPageFunc :: 
    Maybe (Ptr (FunPtr C_AssistantPageFunc)) ->
    AssistantPageFunc_WithClosures ->
    C_AssistantPageFunc
wrap_AssistantPageFunc gi'funptrptr gi'cb currentPage data_ = do
    result <- gi'cb  currentPage data_
    maybeReleaseFunPtr gi'funptrptr
    return result


-- callback AccelMapForeach
{- Callable
  { returnType = Nothing
  , returnMayBeNull = False
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , args =
      [ Arg
          { argCName = "data"
          , argType = TBasicType TPtr
          , direction = DirectionIn
          , mayBeNull = True
          , argDoc =
              Documentation
                { rawDocText =
                    Just
                      "User data passed to gtk_accel_map_foreach() or\n gtk_accel_map_foreach_unfiltered()"
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "accel_path"
          , argType = TBasicType TUTF8
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText = Just "Accel path of the current accelerator"
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "accel_key"
          , argType = TBasicType TUInt
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText = Just "Key of the current accelerator"
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "accel_mods"
          , argType =
              TInterface Name { namespace = "Gdk" , name = "ModifierType" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText = Just "Modifiers of the current accelerator"
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "changed"
          , argType = TBasicType TBoolean
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation
                { rawDocText =
                    Just
                      "Changed flag of the accelerator (if %TRUE, accelerator has changed\n during runtime and would need to be saved during an accelerator dump)"
                , sinceVersion = Nothing
                }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_AccelMapForeach =
    Ptr () ->
    CString ->
    Word32 ->
    CUInt ->
    CInt ->
    IO ()

-- Args: [ Arg
--           { argCName = "data"
--           , argType = TBasicType TPtr
--           , direction = DirectionIn
--           , mayBeNull = True
--           , argDoc =
--               Documentation
--                 { rawDocText =
--                     Just
--                       "User data passed to gtk_accel_map_foreach() or\n gtk_accel_map_foreach_unfiltered()"
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "accel_path"
--           , argType = TBasicType TUTF8
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "Accel path of the current accelerator"
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "accel_key"
--           , argType = TBasicType TUInt
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "Key of the current accelerator"
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "accel_mods"
--           , argType =
--               TInterface Name { namespace = "Gdk" , name = "ModifierType" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText = Just "Modifiers of the current accelerator"
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "changed"
--           , argType = TBasicType TBoolean
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation
--                 { rawDocText =
--                     Just
--                       "Changed flag of the accelerator (if %TRUE, accelerator has changed\n during runtime and would need to be saved during an accelerator dump)"
--                 , sinceVersion = Nothing
--                 }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Nothing
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_AccelMapForeach :: FunPtr C_AccelMapForeach -> C_AccelMapForeach

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_AccelMapForeach ::
    (B.CallStack.HasCallStack, MonadIO m) =>
    FunPtr C_AccelMapForeach
    -> Ptr ()
    -- ^ /@data@/: User data passed to 'GI.Gtk.Objects.AccelMap.accelMapForeach' or
    --  'GI.Gtk.Objects.AccelMap.accelMapForeachUnfiltered'
    -> T.Text
    -- ^ /@accelPath@/: Accel path of the current accelerator
    -> Word32
    -- ^ /@accelKey@/: Key of the current accelerator
    -> [Gdk.Flags.ModifierType]
    -- ^ /@accelMods@/: Modifiers of the current accelerator
    -> Bool
    -- ^ /@changed@/: Changed flag of the accelerator (if 'P.True', accelerator has changed
    --  during runtime and would need to be saved during an accelerator dump)
    -> m ()
dynamic_AccelMapForeach __funPtr data_ accelPath accelKey accelMods changed = liftIO $ do
    accelPath' <- textToCString accelPath
    let accelMods' = gflagsToWord accelMods
    let changed' = (fromIntegral . fromEnum) changed
    (__dynamic_C_AccelMapForeach __funPtr) data_ accelPath' accelKey accelMods' changed'
    freeMem accelPath'
    return ()

-- | Generate a function pointer callable from C code, from a `C_AccelMapForeach`.
foreign import ccall "wrapper"
    mk_AccelMapForeach :: C_AccelMapForeach -> IO (FunPtr C_AccelMapForeach)

-- | /No description available in the introspection data./
type AccelMapForeach =
    Ptr ()
    -- ^ /@data@/: User data passed to 'GI.Gtk.Objects.AccelMap.accelMapForeach' or
    --  'GI.Gtk.Objects.AccelMap.accelMapForeachUnfiltered'
    -> T.Text
    -- ^ /@accelPath@/: Accel path of the current accelerator
    -> Word32
    -- ^ /@accelKey@/: Key of the current accelerator
    -> [Gdk.Flags.ModifierType]
    -- ^ /@accelMods@/: Modifiers of the current accelerator
    -> Bool
    -- ^ /@changed@/: Changed flag of the accelerator (if 'P.True', accelerator has changed
    --  during runtime and would need to be saved during an accelerator dump)
    -> IO ()

-- | A convenience synonym for @`Nothing` :: `Maybe` `AccelMapForeach`@.
noAccelMapForeach :: Maybe AccelMapForeach
noAccelMapForeach = Nothing

-- | Wrap the callback into a `GClosure`.
genClosure_AccelMapForeach :: MonadIO m => AccelMapForeach -> m (GClosure C_AccelMapForeach)
genClosure_AccelMapForeach cb = liftIO $ do
    let cb' = wrap_AccelMapForeach Nothing cb
    mk_AccelMapForeach cb' >>= B.GClosure.newGClosure


-- | Wrap a `AccelMapForeach` into a `C_AccelMapForeach`.
wrap_AccelMapForeach :: 
    Maybe (Ptr (FunPtr C_AccelMapForeach)) ->
    AccelMapForeach ->
    C_AccelMapForeach
wrap_AccelMapForeach gi'funptrptr gi'cb data_ accelPath accelKey accelMods changed = do
    accelPath' <- cstringToText accelPath
    let accelMods' = wordToGFlags accelMods
    let changed' = (/= 0) changed
    gi'cb  data_ accelPath' accelKey accelMods' changed'
    maybeReleaseFunPtr gi'funptrptr


-- callback AccelGroupFindFunc
{- Callable
  { returnType = Just (TBasicType TBoolean)
  , returnMayBeNull = False
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , args =
      [ Arg
          { argCName = "key"
          , argType =
              TInterface Name { namespace = "Gtk" , name = "AccelKey" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "closure"
          , argType = TGClosure Nothing
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "data"
          , argType = TBasicType TPtr
          , direction = DirectionIn
          , mayBeNull = True
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = 2
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Just "2.2" }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_AccelGroupFindFunc =
    Ptr Gtk.AccelKey.AccelKey ->
    Ptr (GClosure ()) ->
    Ptr () ->
    IO CInt

-- Args: [ Arg
--           { argCName = "key"
--           , argType =
--               TInterface Name { namespace = "Gtk" , name = "AccelKey" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "closure"
--           , argType = TGClosure Nothing
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "data"
--           , argType = TBasicType TPtr
--           , direction = DirectionIn
--           , mayBeNull = True
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = 2
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Just (TBasicType TBoolean)
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_AccelGroupFindFunc :: FunPtr C_AccelGroupFindFunc -> C_AccelGroupFindFunc

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_AccelGroupFindFunc ::
    (B.CallStack.HasCallStack, MonadIO m) =>
    FunPtr C_AccelGroupFindFunc
    -> Gtk.AccelKey.AccelKey
    -> GClosure a
    -> Ptr ()
    -> m Bool
dynamic_AccelGroupFindFunc __funPtr key closure data_ = liftIO $ do
    key' <- unsafeManagedPtrGetPtr key
    closure' <- unsafeManagedPtrCastPtr closure
    result <- (__dynamic_C_AccelGroupFindFunc __funPtr) key' closure' data_
    let result' = (/= 0) result
    touchManagedPtr key
    touchManagedPtr closure
    return result'

-- | Generate a function pointer callable from C code, from a `C_AccelGroupFindFunc`.
foreign import ccall "wrapper"
    mk_AccelGroupFindFunc :: C_AccelGroupFindFunc -> IO (FunPtr C_AccelGroupFindFunc)

-- | /No description available in the introspection data./
-- 
-- /Since: 2.2/
type AccelGroupFindFunc =
    Gtk.AccelKey.AccelKey
    -> GClosure ()
    -> IO Bool

-- | A convenience synonym for @`Nothing` :: `Maybe` `AccelGroupFindFunc`@.
noAccelGroupFindFunc :: Maybe AccelGroupFindFunc
noAccelGroupFindFunc = Nothing

-- | /No description available in the introspection data./
-- 
-- /Since: 2.2/
type AccelGroupFindFunc_WithClosures =
    Gtk.AccelKey.AccelKey
    -> GClosure ()
    -> Ptr ()
    -> IO Bool

-- | A convenience synonym for @`Nothing` :: `Maybe` `AccelGroupFindFunc_WithClosures`@.
noAccelGroupFindFunc_WithClosures :: Maybe AccelGroupFindFunc_WithClosures
noAccelGroupFindFunc_WithClosures = Nothing

-- | A simple wrapper that ignores the closure arguments.
drop_closures_AccelGroupFindFunc :: AccelGroupFindFunc -> AccelGroupFindFunc_WithClosures
drop_closures_AccelGroupFindFunc _f key closure _ = _f key closure

-- | Wrap the callback into a `GClosure`.
genClosure_AccelGroupFindFunc :: MonadIO m => AccelGroupFindFunc -> m (GClosure C_AccelGroupFindFunc)
genClosure_AccelGroupFindFunc cb = liftIO $ do
    let cb' = drop_closures_AccelGroupFindFunc cb
    let cb'' = wrap_AccelGroupFindFunc Nothing cb'
    mk_AccelGroupFindFunc cb'' >>= B.GClosure.newGClosure


-- | Wrap a `AccelGroupFindFunc` into a `C_AccelGroupFindFunc`.
wrap_AccelGroupFindFunc :: 
    Maybe (Ptr (FunPtr C_AccelGroupFindFunc)) ->
    AccelGroupFindFunc_WithClosures ->
    C_AccelGroupFindFunc
wrap_AccelGroupFindFunc gi'funptrptr gi'cb key closure data_ = do
    key' <- (newPtr Gtk.AccelKey.AccelKey) key
    closure' <- (B.GClosure.newGClosureFromPtr . FP.castPtr) closure
    result <- gi'cb  key' closure' data_
    maybeReleaseFunPtr gi'funptrptr
    let result' = (fromIntegral . fromEnum) result
    return result'


-- callback AccelGroupActivate
{- Callable
  { returnType = Just (TBasicType TBoolean)
  , returnMayBeNull = False
  , returnTransfer = TransferNothing
  , returnDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , args =
      [ Arg
          { argCName = "accel_group"
          , argType =
              TInterface Name { namespace = "Gtk" , name = "AccelGroup" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "acceleratable"
          , argType =
              TInterface Name { namespace = "GObject" , name = "Object" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "keyval"
          , argType = TBasicType TUInt
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      , Arg
          { argCName = "modifier"
          , argType =
              TInterface Name { namespace = "Gdk" , name = "ModifierType" }
          , direction = DirectionIn
          , mayBeNull = False
          , argDoc =
              Documentation { rawDocText = Nothing , sinceVersion = Nothing }
          , argScope = ScopeTypeInvalid
          , argClosure = -1
          , argDestroy = -1
          , argCallerAllocates = False
          , transfer = TransferNothing
          }
      ]
  , skipReturn = False
  , callableThrows = False
  , callableDeprecated = Nothing
  , callableDocumentation =
      Documentation { rawDocText = Nothing , sinceVersion = Nothing }
  , callableResolvable = Nothing
  }
-}
-- | Type for the callback on the (unwrapped) C side.
type C_AccelGroupActivate =
    Ptr Gtk.AccelGroup.AccelGroup ->
    Ptr GObject.Object.Object ->
    Word32 ->
    CUInt ->
    IO CInt

-- Args: [ Arg
--           { argCName = "accel_group"
--           , argType =
--               TInterface Name { namespace = "Gtk" , name = "AccelGroup" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "acceleratable"
--           , argType =
--               TInterface Name { namespace = "GObject" , name = "Object" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "keyval"
--           , argType = TBasicType TUInt
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       , Arg
--           { argCName = "modifier"
--           , argType =
--               TInterface Name { namespace = "Gdk" , name = "ModifierType" }
--           , direction = DirectionIn
--           , mayBeNull = False
--           , argDoc =
--               Documentation { rawDocText = Nothing , sinceVersion = Nothing }
--           , argScope = ScopeTypeInvalid
--           , argClosure = -1
--           , argDestroy = -1
--           , argCallerAllocates = False
--           , transfer = TransferNothing
--           }
--       ]
-- Lengths: []
-- returnType: Just (TBasicType TBoolean)
-- throws : False
-- Skip return : False

foreign import ccall "dynamic" __dynamic_C_AccelGroupActivate :: FunPtr C_AccelGroupActivate -> C_AccelGroupActivate

-- | Given a pointer to a foreign C function, wrap it into a function callable from Haskell.
dynamic_AccelGroupActivate ::
    (B.CallStack.HasCallStack, MonadIO m, Gtk.AccelGroup.IsAccelGroup a, GObject.Object.IsObject b) =>
    FunPtr C_AccelGroupActivate
    -> a
    -> b
    -> Word32
    -> [Gdk.Flags.ModifierType]
    -> m Bool
dynamic_AccelGroupActivate __funPtr accelGroup acceleratable keyval modifier = liftIO $ do
    accelGroup' <- unsafeManagedPtrCastPtr accelGroup
    acceleratable' <- unsafeManagedPtrCastPtr acceleratable
    let modifier' = gflagsToWord modifier
    result <- (__dynamic_C_AccelGroupActivate __funPtr) accelGroup' acceleratable' keyval modifier'
    let result' = (/= 0) result
    touchManagedPtr accelGroup
    touchManagedPtr acceleratable
    return result'

-- | Generate a function pointer callable from C code, from a `C_AccelGroupActivate`.
foreign import ccall "wrapper"
    mk_AccelGroupActivate :: C_AccelGroupActivate -> IO (FunPtr C_AccelGroupActivate)

-- | /No description available in the introspection data./
type AccelGroupActivate =
    Gtk.AccelGroup.AccelGroup
    -> GObject.Object.Object
    -> Word32
    -> [Gdk.Flags.ModifierType]
    -> IO Bool

-- | A convenience synonym for @`Nothing` :: `Maybe` `AccelGroupActivate`@.
noAccelGroupActivate :: Maybe AccelGroupActivate
noAccelGroupActivate = Nothing

-- | Wrap the callback into a `GClosure`.
genClosure_AccelGroupActivate :: MonadIO m => AccelGroupActivate -> m (GClosure C_AccelGroupActivate)
genClosure_AccelGroupActivate cb = liftIO $ do
    let cb' = wrap_AccelGroupActivate Nothing cb
    mk_AccelGroupActivate cb' >>= B.GClosure.newGClosure


-- | Wrap a `AccelGroupActivate` into a `C_AccelGroupActivate`.
wrap_AccelGroupActivate :: 
    Maybe (Ptr (FunPtr C_AccelGroupActivate)) ->
    AccelGroupActivate ->
    C_AccelGroupActivate
wrap_AccelGroupActivate gi'funptrptr gi'cb accelGroup acceleratable keyval modifier = do
    accelGroup' <- (newObject Gtk.AccelGroup.AccelGroup) accelGroup
    acceleratable' <- (newObject GObject.Object.Object) acceleratable
    let modifier' = wordToGFlags modifier
    result <- gi'cb  accelGroup' acceleratable' keyval modifier'
    maybeReleaseFunPtr gi'funptrptr
    let result' = (fromIntegral . fromEnum) result
    return result'



